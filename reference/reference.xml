<?xml version="1.0" encoding="utf-8"?>
<!--  -*- Mode: xmldoc -*-  -->
<!DOCTYPE book [
<!ELEMENT book (chapter*)>
<!ELEMENT chapter (title,type,arguments?,package?,description,seealso*,link*,section,file?)>
<!ELEMENT title (#PCDATA)>
<!ELEMENT type (#PCDATA)>
<!ELEMENT arguments (#PCDATA)>
<!ELEMENT package (#PCDATA)>
<!ELEMENT description (#PCDATA)>
<!ELEMENT seealso (#PCDATA)>
<!ELEMENT link (#PCDATA)>
<!ELEMENT section (#PCDATA)>
<!ELEMENT file (#PCDATA)>
]>
<!--
book
  └ chapter
      ├ title
      ├ type           Function, Special Form, Macro
      │                Misc, Tips, Variable, BufferLocal
      │                Keyword, Accessor
      ├ arguments      VariableやTipsはなし
      ├ package        Tipsはなし
      ├ description
      ├ seealso        0?n個
      ├ link           0?n個
      ├ section        データ型 変数と定数 制御構造
      │                パッケージ 関数 マクロ シンボル
      │                数値 文字 文字列 シーケンス
      │                リスト ハッシュ 配列 チャンク
      │                評価 入出力 ファイルシステム
      │                エラー ウィンドウ バッファ
      │                ミニバッファ リージョン モード
      │                シンタックス キーマップ テキスト
      │                検索・正規表現 ダイアログ 日付・時間
      │                メニュー ファイラ ポジション
      │                プロセス システム その他
      └ file            0 or 1
-->
<!--
<!ELEMENT (a, b)>     順番に出現
<!ELEMENT (a|b|c)>    どれか１つが出現
<!ELEMENT x (a?)>     0または1出現
<!ELEMENT x (a+)>     1回以上出現
<!ELEMENT x (a*)>     0回以上出現
-->
<!--
Copyright (c) 2007 The Xyzzy Documentation Project
Copyright (C) 2012 xyzzy Project

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without 
limitation the rights to use, copy, modify, merge, publish, distribute, 
sublicense, and/or sell copies of the Software, and to permit persons to 
whom the Software is furnished to do so, subject to the following 
conditions:

The above copyright notice and this permission notice shall be included 
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<!--
制作著作：xyzzy reference.xml(気が向いたら)作成プロジェクト・メンバー
        逸見雅人        henmi@synform.co.jp
        服部昌司        gyo@he.mirai.ne.jp
        サイトウ        HiroshiSaito@pob.org
        山本泰三        ymtz@pop02.odn.ne.jp
        花井達          変換ツール作成協力
        s.oowada
        OHKUBO KOHEI    kuboon@mbe.nifty.com
        HIE Masahiro    madoinu@ybb.ne.jp
        SANO Masatoshi  t01450ms@sfc.keio.ac.jp
        Nobuaki Arima   narima1109@hotmail.com
        広井誠          m_hiroi@yahoo.co.jp
        ※敬称略
-->
<!--
reference.xmlについての詳細は以下のサイトにて
・http://xyzzy.s53.xrea.com/wiki/?%A5%EA%A5%D5%A5%A1%A5%EC%A5%F3%A5%B9
-->
<book>


<chapter>
<title>*</title>
<type>Function</type>
<arguments>* &amp;rest NUMBERS</arguments>
<package>lisp</package>
<description>
引数を全て乗算した数値を返します。

使用例：  
  (* 1 2 3)
  =&gt; 6
</description>
<seealso>/</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>Emacs 互換ではない正規表現は結構あるのでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
\'  \`  \=  \c  \C これだけです。
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>*activate-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファがactivateされたときに任意の処理を行うために使用されます。
デフォルトではファイルの修正日付を確認しています。
</description>
<seealso>verify-buffers-file-modtime</seealso>
<seealso>*deactivate-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*after-save-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分 save-buffer の最後に実行されます。
</description>
<seealso>save-buffer</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*apropos-no-regexp*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil に設定すると、apropos 実行時に、正規表現のメタ文字はエスケープさ
れます。デフォルトは nil です。
</description>
<seealso>apropos</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>*auto-fill-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
auto-fill-mode の時に、self-insert-command から *last-command-char*
を引数として実行されます。普通は do-auto-fill が設定されています。
多分修正しない方が良いと思います。
※ run-hooks ではなく、 funcall されるので注意すること
</description>
<seealso>auto-fill-mode</seealso>
<seealso>auto-fill-hook</seealso>
<seealso>self-insert-command</seealso>
<seealso>funcall</seealso>
<link></link>
<section>変数と定数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>*auto-mode-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モード判定用の連想リストです。(key . datum)の組で登録します。
(string-matchp key filename)がnon-nilになった場合に、
datumをfuncallします。

datumにdecode-auto-modeのプロパティが存在する場合には、バッファを
第一引数にしてdatumをfuncallします。
cc-mode.lのdecode-c-modeを参照

使用例：
  (pushnew '("\\.asp" . basic-mode) *auto-mode-alist* :test 'equal)
</description>
<seealso>*find-file-auto-mode-function*</seealso>
<seealso>*auto-mode-parameter-alist*</seealso>
<link></link>
<section>モード</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*auto-update-per-device-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ファイラで移動したときにドライブ毎のデフォルトのディレクトリについて制御します。

  t   移動するたびに更新する
  nil set-perdevice-directoryで指定したディレクトリに固定する
</description>
<seealso>set-per-device-directory</seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>*before-delete-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
delete-bufferを継続するかどうかを制御します。登録された関数が一
つでもnilを返すとdelete-bufferを中止します。

参考：
  ;;; 呼び出し方
  (run-hook-with-args-until-success
       '*before-delete-buffer-hook* (selected-buffer))

使用例：
  (add-hook '*before-delete-buffer-hook* 'func)
  =&gt;(func)
  (defun func (x) (yes-or-no-p "delete-buffer ~A ?" (buffer-name x)))
  =&gt;func
</description>
<seealso>delete-buffer</seealso>
<seealso>*delete-buffer-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*before-find-file-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-fileの最初で実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso>find-file</seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*before-save-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分 save-buffer の最初に実行されます。
※ run-hook-with-args-until-success で実行されるので注意すること
</description>
<seealso>save-buffer</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファ・バー上で右クリックしたときに出てくるコンテキストメニューです。
define-popup-menu で作成されています。（作成は app-menu.l）
</description>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu-buffer*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファバー上で選択されているバッファです。ただし、バッファバー上の
コンテキストメニューで取得専用くらいしか使用できません。
</description>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu-handler*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
デフォルトのバッファバー用コンテキストメニューハンドラです。
setq-default によって定義されている標準の動作は、 
*buffer-bar-context-menu-buffer* を定義し、*buffer-bar-context-menu* を
返します。
</description>
<seealso>*buffer-bar-context-menu*</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-selected-buffer-to-first*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil なら、選択されたバッファがバッファバー上で一番先頭になります。
キーでタブを移動した場合は移動されません。デフォルトは nil です。
(setq *buffer-bar-selected-buffer-to-first* t) とやって、バッファバーを
クリックすれば分かると思います。
</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*buffer-menu-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
buffer-menuの起動時に実行されます。

参考：
  (run-hooks '*buffer-menu-mode-hook*)
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>buf-menu.l</file>
</chapter>

<chapter>
<title>*change-buffer-colors-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
途中
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*command-line-mailto-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドラインで指定された -mailto オプションの引数を元に実行されます。 
※run-hooksではなくfuncallされるので注意すること
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*command-output-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
execute-subprocessの中でcommand-output-mode起動時に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>process.l</file>
</chapter>

<chapter>
<title>*create-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分create-new-bufferで実行されます。
</description>
<seealso>*default-buffer-mode*</seealso>
<seealso>create-new-buffer</seealso>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*css-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
css-mode起動時に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>css-mode.l</file>
</chapter>

<chapter>
<title>*css-level*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
css-modeで利用するCSS Levelを指定します。
デフォルトは 3 (CSS Level 3)です。

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>css-mode.l</file>
</chapter>

<chapter>
<title>*css-keyword-file*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
css-modeで利用するCSS Level 2のキーワードファイルを指定します。
*css-level*が2の場合に読み込まれます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>css-mode.l</file>
</chapter>

<chapter>
<title>*css3-keyword-files*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
css-modeで利用するCSS Level 3のキーワードファイルを指定します。
*css-level*が3の場合に読み込まれます。

CSS3用のキーワードファイルはCSSモジュールごとに分かれているので、
必要なモジュールのキーワードのみを読み込むことができます。

デフォルトはCSS Level 3の全モジュール、ブラウザごとの拡張、
HTML4/5 の要素をキーワードとして読み込みます。

  ;; css-modeで利用するキーワードの設定 (CSS Level 3)
  (setq *css3-keyword-files*
    '(;; CSS3 modules
      "CSS3/2d-transforms"
      "CSS3/3d-transforms"
      "CSS3/animations"
      "CSS3/backgrounds-and-borders"
      "CSS3/basic-box"
      "CSS3/basic-user-interface"
      "CSS3/behavioral-extensions"
      "CSS3/color"
      "CSS3/flexible-box-layout"
      "CSS3/fonts"
      "CSS3/generated-and-replaced-content"
      "CSS3/hyperlinks"
      "CSS3/layout"
      "CSS3/line"
      "CSS3/lists"
      "CSS3/marquee"
      "CSS3/multi-column"
      "CSS3/paged-media"
      "CSS3/presentation-levels"
      "CSS3/ruby"
      "CSS3/speech"
      "CSS3/tables"
      "CSS3/text"
      "CSS3/transitions"
      ;; vendor extensions
      "CSS3/microsoft-extensions"
      "CSS3/mozilla-extensions"
      "CSS3/webkit-extensions"
      ;; HTML elements
      "CSS3/html4-elements"
      "CSS3/html5-elements"
      ))

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>css-mode.l</file>
</chapter>

<chapter>
<title>*dabbrev-search-this-buffer-only*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
dabbrev-expandの検索対象を設定します。

  t   カレントバッファのみを検索します
  nil 全バッファを検索します
</description>
<seealso>dabbrev-expand</seealso>
<link></link>
<section>テキスト</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>*dabbrevs-no-undo*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
dabbrev-expand時のundoの方法を設定します。
dabbrev-expandを行なった際に候補が順次挿入されますが...
  non-nil  dabbrev-expandの直前まで一気に取り消す
  nil      途中の挿入過程を順番に取り消す
</description>
<seealso>undo</seealso>
<seealso>dabbrev-expand</seealso>
<link></link>
<section>バッファ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*deactivate-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファがdeactivateされたときに任意の処理を行うために使用されま
す。デフォルトではクリップボードの同期を行っています。
</description>
<seealso>*activate-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*default-buffer-mode*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
新しくバッファを作成した場合のモードを指定します。
例えば、lisp-modeを指定しておけば、新しく作成したバッファは全てlisp-mode
になります。

使用例：  
  (setq *default-buffer-mode* 'lisp-mode)
  =&gt; lisp-mode
  (switch-to-buffer "*new*")
  =&gt; #&lt;buffer: *new*&gt;
  buffer-mode
  =&gt; lisp-mode
</description>
<section>バッファ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*default-load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
siteinit.lから*load-path*を修正するために用いられます。
siteinit.lの直後に*default-load-path*の内容が、*load-path*にマー
ジされ、*pre-startup-hook*から有効になります。
追加するパスはリストで設定します。

使用例：
  (setq *default-load-path* '("C:/APPLICATIONS/XYZZY/lib"))
</description>
<seealso>*load-path*</seealso>
<link></link>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>*delete-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
delete-bufferで実行されます。
</description>
<seealso>delete-buffer</seealso>
<seealso>*before-delete-buffer-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*diff-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
diff起動時に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>diff.l</file>
</chapter>

<chapter>
<title>*do-completion</title>
<type>Function</type>
<arguments>*do-completion STRING TYPE &amp;optional WORDP LIST</arguments>
<package>editor</package>
<description>
指定した文字列を条件に従い補完します。

  STRING : 補完したい文字列
  TYPE   : 補完する型
        :symbol-name
        :function-name
        :command-name
        :variable-name
        :non-trivial-symbol-name
        :exist-file-name
        :file-name
        :file-name-list
        :directory-name
        :buffer-name
        :exist-buffer-name
        :list
        :list-ignore-case
  WORD   : nilでなければ単語ごとの補完
  LIST   : TYPE が :list か :list-ignore-case の場合の補完リスト

戻り値は以下のとおりです。

  多値で3つの値が戻ってきますので、multiple-value-bind で受け取るといい
  でしょう。complete.lの中にある do-completion-internal を参考にしてくだ
  さい。以下は場合分けをしています。

        [1] 補完の候補が存在しない場合     :no-completions と nil
        [2] マッチする候補がなかった場合   :no-match と nil
        [3] 与えられた文字列がすでに候補の
            いずれかと一致していて
            補完する必要がない場合
            [3.1] 一致した候補が一つだけ   :solo-match と list と prefix
            [3.2] 複数と一致した場合       :not-unique と list と prefix
        [4] 補完した場合                   補完した結果の文字列と list と prefix

  list は、一致した候補のリスト。
  prefix は、例えばファイル名の補完のときのディレクトリ名とか、
  シンボルの補完のときのパッケージ修飾部分とか。
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*drag-and-drop-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
D&amp;D時に実行されます。デフォルトでは、D&amp;D先がミニバッファ
ならミニバッファへの入力として扱い、それ以外ならfind-fileする
ようになっています。

※run-hooksではなくfuncallされます。引数は2つで、ドロップされたウィンド
  ウとドロップしたファイルのリストです。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>mouse.l</file>
</chapter>

<chapter>
<title>*enter-minibuffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファに入ったときに実行されます。(interactive...)で指定さ
れた引数が渡されます。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>*eol-cr*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのCRを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-lf*</seealso>
<seealso>*eol-crlf*</seealso>
<seealso>set-buffer-eol-code</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*eol-crlf*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのCRLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-cr*</seealso>
<seealso>*eol-lf*</seealso>
<seealso>set-buffer-eol-code</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*eol-lf*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-cr*</seealso>
<seealso>*eol-crlf*</seealso>
<seealso>set-buffer-eol-code</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*error-regexp-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
first-error/next-errorで使用するエラー発生位置の表記形式を変更することが可能です。
*error-regexp-list*の形式は以下のとおりです。

  ((正規表現1 ファイル名のマッチ位置1 行のマッチ位置1)
   (正規表現2 ファイル名のマッチ位置2 行のマッチ位置2)
    ...
   (正規表現N ファイル名のマッチ位置N 行のマッチ位置N))

[xyzzy:05447]で亀井さんが示しているとおり、pushを使って追加するのが無難です。
(push (list (compile-regexp "^\"\\([^\"\n]+\\)\", line \\([0-9]+\\):") 1 2)
      *error-regexp-list*)
</description>
<seealso>next-error</seealso>
<seealso>first-error</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>*etc-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
キーワードファイル等を格納するパスが設定されています。
標準では(merge-pathnames "etc" (si:system-root))が設定されています。

参照例：
  *etc-path*
  =&gt; "C:/APPLICATIONS/XYZZY/etc"
</description>
<seealso>etc-path</seealso>
<link></link>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>*executing-macro*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
マクロを実行中か否かを返します。
  t    マクロを実行中
  nil  マクロを実行中ではない
</description>
<seealso></seealso>
<link></link>
<section>マクロ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>*exit-minibuffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファから出たときに実行されます。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-chdir-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（ファイラでディレクトリが変更されたりすると実行されます。用途不明） 
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-chdir-primary-p*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（詳細不明）
<!-- ファイラにてアクティブなウィンドウのディレクトリを変更したかどうか。 -->
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-click-toggle-marks-always*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
nilなら、ファイラで左クリックしたとき、その位置にカーソルがある場合の
みマークを反転します。
non-nil なら、カーソルの移動とマークの反転の両方を同時に行います。
デフォルトは t です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-directories*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラのジャンプ用のディレクトリを連想リストで設定します。

使用例：
  (setq *filer-directories*
      '((" [デスクトップ]" . "c:/windows/デスクトップ")
        (" [スプール]" . "c:/spool")))
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-drag-and-drop-helper</title>
<type>Function</type>
<arguments>*filer-drag-and-drop-helper EFFECT FILES SRC DEST</arguments>
<package>editor</package>
<description>
（詳細不明）
<!-- ファイラへドラッグアンドドロップした時の動作です。 -->
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-dual-window*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファなどでディレクトリを入力した時に立ち上がるファイラを選択し
ます。 nil なら一画面ファイラ、non-nil なら二画面ファイラが起動します。
デフォルトは nil です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-eat-esc*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
nilなら、モードレスファイラでESCを押しても閉じません。
デフォルトは t です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-echo-filename*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（途中）
ファイラのステータスウィンドウへのファイル名の表示を制御します。
ファイル名の表示は暇なときに行なっているようです。
  non-nil  暇なときに表示する
  nil      表示しない
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-format-comma*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nilなら、ファイルサイズをカンマ区切りで表示します。
[共通設定] - [ファイラ] - [ファイルサイズをカンマ区切りで表示(C)] で値を
指定することができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-guide-text*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラ下部に表示されるガイドテキストを設定します。

使用例：
  (setq *filer-guide-text*
      '("(A)ttribute  (B)yteCompile  (C)opy  (D)elete  (E)xtract  (F)ind"
        "(G)o  (J)ump  m(K)dir  &lt;L&gt;Cd  (M)ove  re(N)ame"))
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-last-command-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラにてコマンドを実行した時に最後に入力された文字を示します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-last-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
一画面ファイラの初期のファイルマスクをリストで設定します。
</description>
<seealso>*filer-primary-file-mask*</seealso>
<seealso>*filer-secondary-file-mask*</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-left-window-p*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラを閉じたとき、どちらのウィンドウがアクティブだったかが保存
されます。ファイラ未起動時の値は t です。

  nil     : 右側のウィンドウ
  non-nil : 左側のウィンドウ
<!--
  使用例：
  ; [xyzzy:07026]
  ; ファイラの起動時に表示するディレクトリを前回の終了時と同じに
  (register-history-variable '*filer-primary-directory*)
  (register-history-variable '*filer-secondary-directory*)
  (register-history-variable '*filer-left-window-p*) 
-->
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-mark-file-size-unit*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラのマークファイルの合計サイズの単位を指定します。
#\B, #\K, #\M, #\G, #\Tの何れかを指定可能です。ただし、例えば#\K
が設定されたとき、サイズが1K未満ならバイト単位になります。デフォ
ルトではnilに設定されています。

使用例：
  (setq *filer-mark-file-size-unit* #\M)
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-modal*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラの動作を指定します。

モーダルの場合には、ファイラはエディタとは同期的に動作します。
ファイラ起動中はエディタでの編集は不能です。
モードレスの場合には、ファイラはエディタとは非同期に動作します。
ファイラ起動中にエディタでの編集が可能です。

  t   モーダルで動作させます
  nil モードレスで動作させます
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-path-masks*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラのファイルマスクを設定します。

使用例：
  (pushnew '("Microsoft" "*.doc" "*.xls" "*.ppt" "*.sys" "*.bat" "*.ini")
           *filer-path-masks* :test 'equal)
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-primary-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラのアクティブな方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラ未起動時は左側のディレクトリを指定できます。

使用例：
  ; [xyzzy:07218]
  ; 常にカレントディレクトリからファイラを起動する。
  (defun foo ()
    (interactive)
    (let ((*filer-primary-directory* nil)
          (*filer-secondary-directory* nil))
      (open-filer)))
</description>
<seealso>*filer-secondary-directory*</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-primary-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラ左側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-primary-file-mask* '("*"))
</description>
<seealso>filer</seealso>
<seealso>*filer-secondary-file-mask*</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-retrieve-icon*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil のとき、ファイラでファイルタイプに応じたアイコンを表示します。
[共通設定] - [ファイラ] - [アイコンをファイルから取ってくる(I)] で値を指
定することができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-secondary-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラのアクティブでない方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラ未起動時は右側のディレクトリを指定できます。
</description>
<seealso>*filer-primary-directory*</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-secondary-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラ右側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-secondary-file-mask* '("*"))
</description>
<seealso>*filer-primary-file-mask*</seealso>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*filer-use-recycle-bin*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラでファイルの削除にゴミ箱を使用するかを設定します。
  non-nil  ファイラで削除したときはゴミ箱行き
  nil      直接削除
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*find-file-file-not-found-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-file で指定されたファイルが存在しないときに実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso>find-file</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-file-hooks*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-file および find-file-read-only で新しいファイルを開くたびに、最後に実行されます。
すでにファイルを開いているバッファが存在した場合には実行されません。
</description>
<seealso>*find-file-read-only-hook*</seealso>
<seealso>find-file-read-only</seealso>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-file-read-only-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-file-read-only でファイルごとに最後に実行されます。
*find-file-hooks* と異なり、すでにファイルが開かれていた場合にも実行されます。
</description>
<seealso>*find-file-hooks*</seealso>
<seealso>find-file-read-only</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*grep-directory-name-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep-dialogでgrep対象のディレクトリを個々に設定したい場合に実行
されます。
※funcallされるので注意すること
</description>
<seealso>*grep-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grepd.l</file>
</chapter>

<chapter>
<title>*grep-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep起動後に実行されます。
</description>
<seealso>*grepd-hook*</seealso>
<seealso>*before-grep-hook*</seealso>
<seealso>*before-grepd-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grep.l</file>
</chapter>

<chapter>
<title>*before-grep-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep起動前に実行されます。
フックの引数は検索キーワード(or regex string)です。
フック実行時のselected-bufferはgrepバッファです。
</description>
<seealso>*grep-hook*</seealso>
<seealso>*grepd-hook*</seealso>
<seealso>*before-grepd-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grep.l</file>
</chapter>

<chapter>
<title>*grepd-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep-dialog起動後に実行されます。
</description>
<seealso>*grep-hook*</seealso>
<seealso>*before-grep-hook*</seealso>
<seealso>*before-grepd-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grepd.l</file>
</chapter>

<chapter>
<title>*before-grepd-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep-dialog起動前に実行されます。
フックの引数は検索キーワード(or regex string)です。
フック実行時のselected-bufferはgrepバッファです。
</description>
<seealso>*grep-hook*</seealso>
<seealso>*grepd-hook*</seealso>
<seealso>*before-grep-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grepd.l</file>
</chapter>

<chapter>
<title>*gresreg-directory-name-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
gresreg-dialog で gresreg 対象のディレクトリを個々に設定したい場合
に実行されます。
※funcallで実行されるので注意すること
</description>
<seealso>gresreg-dialog</seealso>
<link></link>
<section>変数と定数</section>
<file>gresregd.l</file>
</chapter>

<chapter>
<title>*history-file-name*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ヒストリを保存するファイル名です。
nil の場合は関数 history-file-name において
適当に決定されます。

例:
  *history-file-name*
  =&gt;"X:/xyzzy/usr/username/wxp/.xyzzy.history"
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*ime-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
IMEの切替え時に呼び出されます。
</description>
<seealso>toggle-ime</seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>*init-app-menus-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy実行後に実行されます。*app-menu*を直接変更する用途で用いら
れます。

使用例：
  (add-hook '*init-app-menus-hook*
            #'(lambda ()
                (add-menu-item *app-menu* 'close-box :close-box
                               #'kill-selected-buffer)))
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>メニュー</section>
<file>app-menu.l</file>
</chapter>

<chapter>
<title>*isearch-scanner-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
isearch-scannerで実行されます。scan-bufferするパターンを書き換えることが
出来そうです。migemo用？

参考：
  (funcall *isearch-scanner-hook* pattern)
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file>isearch.l</file>
</chapter>

<chapter>
<title>*kbd-translate-table*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分、入力された物理的なキーを論理的なキーに変換するためのものです。
この論理的なキーは、F13〜F24などのように存在しないキーに振り向けることが
出来ます。例えば、キートップのラベルに別の文字のラベルを貼り付けるような
ものだと思います。

  ・物理的なキーから論理的なキーへの変換
  ・ローカルキーマップに論理的なキーの設定があればコマンド実行
  ・グローバルキーマップに論理的なキーの設定があればコマンド実行

使用例：
  ;;; C-[ と ESC を別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-[)) #\F15)
  (global-set-key #\F15 'xxxx)

  ;;; BSとCtrl-hを別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)
</description>
<seealso>キー表現使用可能文字</seealso>
<section>キーマップ</section>
<file>keyboard.l</file>
</chapter>

<chapter>
<title>*keyword-load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
キーワードファイルのパスをリストで設定します。
指定されたキーワードファイルがこのリストから見つからない場合には、
etc-pathで取得されるパスを検索します。

使用例：
  (pushnew (merge-pathnames "keyword" (si:system-root))
           *keyword-load-path* :test #'string=)
</description>
<seealso>load-keyword-file</seealso>
<seealso>*etc-path*</seealso>
<seealso>キーワードファイルの書き方</seealso>
<seealso>キーワードファイルのカスタマイズ</seealso>
<link></link>
<section>変数と定数</section>
<file>kwd.l</file>
</chapter>

<chapter>
<title>*kill-buffer-kills-scratch*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
*kill-buffer-kills-scratch*がnon-nilの場合には、kill-bufferで
*scratch*が削除可能です。デフォルトはnilになっています。
</description>
<seealso>kill-buffer</seealso>
<link></link>
<section>変数と定数</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>*kill-ring*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
killした文字列を格納します。
*kill-ring*は長さが*kill-ring-max*であるリングバッファです。
</description>
<seealso>*kill-ring-max*</seealso>
<seealso>kill-region</seealso>
<seealso>yank</seealso>
<seealso>*selection-ring*</seealso>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*kill-ring-max*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
killで保存する個数です。*kill-ring*の長さです。
</description>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*kill-xyzzy-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzyの終了時に実行されます。
</description>
<seealso>kill-xyzzy</seealso>
<seealso>*query-kill-xyzzy-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*last-command*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
最後に実行したコマンドが入っています。直前の *this-command* の値が設定されます。
</description>
<seealso>*this-command*</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*load-history-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
.xyzzy処理後に実行されます。コマンドバー、セッション等のヒストリ変
数の読み込みに使用されています。
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ライブラリをロードするパスがリストで設定されています。
直接リストを修正するよりも、siteinit.lで *default-load-path* 
に追加する方が好ましいようです。
</description>
<seealso>si:*load-library</seealso>
<seealso>load-library</seealso>
<seealso>*default-load-path*</seealso>
<seealso>find-load-path</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*make-backup-filename-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（多分触らないほうがいいと思われます） 
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>backup.l</file>
</chapter>

<chapter>
<title>*menu-display-length*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
メニューの「最近使ったファイル」で表示されるファイルパスの長さを指定します。
デフォルトでは40です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>app-menu.l</file>
</chapter>

<chapter>
<title>*minibuffer-buffer-name-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのバッファ名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-directory-name-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのディレクトリ名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-execute-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（詳細不明）
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-file-name-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのファイル名の履歴です。
</description>
<seealso>add-file-history-to-menu</seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-lisp-sexp-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのS式の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-popup-completion-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファで補完リストをポップアップ表示するかを設定します。

使用例：
  (setq *popup-completion-list-default* :always)
  (setq *minibuffer-popup-completion-list* :never)

動作：
  *minibuffer-popup-completion-list*
    :always   ポップアップ表示
    :never    *Completion*バッファで表示
  
    *popup-completion-list-default*
      :always ポップアップ表示
      :never  *Completion*バッファで表示
  
    non-nil   ポップアップ表示
    nil       *Completion*バッファで表示
</description>
<seealso>*popup-completion-list-default*</seealso>
<link></link>
<section>ミニバッファ</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-save-ime-status*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのIMEの状態を制御します。
  nil  ミニバッファのIMEの状態を保存しません。
  t    ミニバッファのIMEの状態を保存します。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>*minibuffer-search-string-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファの検索文字の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-symbol-name-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのシンボル名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*modal-filer-save-position*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モーダルでファイラを動作させているときの、ファイラ終了時の動作を設定します。

  t   位置を保存します
  nil 位置を保存しません
</description>
<seealso>*modal-filer-save-size*</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*modal-filer-save-size*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モーダルでファイラを動作させているときの、ファイラ終了時の動作を設定します。

  t   大きさを保存します
  nil 大きさを保存しません
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>*modules*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ロードされたモジュールの一覧が格納されています。
(require "foo")で実際にモジュールを読み込むか否かは*modules*に登録されて
いるかどうかで決まります。モジュールの中で(provide "foo")すると、そのモ
ジュールが*modules*に追加されます。

使用例：
  ;;; モジュールの一覧を見てみる。
  *modules*
  =&gt; ( ... )
  (provide "foo")
  =&gt; ("foo" ... )
  *modules*
  =&gt; ("foo" ... )
</description>
<seealso>provide</seealso>
<seealso>require</seealso>
<seealso>modulep</seealso>
<seealso>各種ロード関係の関数の違い</seealso>
<link></link>
<section>システム</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>*move-forward-after-undo-deletion*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
削除をundoした場合のカーソルの位置を制御します。
  non-nil  削除範囲の最後尾
  nil      削除範囲の先頭
</description>
<seealso>undo</seealso>
<link></link>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*next-buffer-in-tab-order*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-bufferで次に移動するバッファを、タブでの順番どおりにするか否かを設
定します。もちろんprevious-bufferにも影響します。
  t    バッファバーでの次のバッファに移動する。
  nil  どうなるでしょうか？
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*next-screen-context-lines*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
previous-page と next-page で重なって表示される行数を指定します。
*page-scroll-half-window* が non-nilのときは効果はありません。
</description>
<seealso>next-page</seealso>
<seealso>previous-page</seealso>
<seealso>*page-scroll-half-window*</seealso>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>*package*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
実行中のパッケージを保持しています。
in-packageで別のパッケージに移ることができます。

使用例：
  *package*
  =&gt; #&lt;package: user&gt;
</description>
<seealso>パッケージ</seealso>
<seealso>defpackage</seealso>
<seealso>in-package</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>*page-scroll-half-window*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-page/previous-pageのスクロールの単位を半画面ずつにするか制御します。

  t     半画面ずつスクロール
  nil   一画面ずつスクロール
</description>
<seealso>next-page</seealso>
<seealso>previous-page</seealso>
<seealso>*next-screen-context-lines*</seealso>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>*page-scroll-keep-window-position*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-page実行時にバッファの最後がウィンドウ内にある場合、バッファ
の最後に移動します。previous-pageも同様です。

  t   移動しません
  nil 移動します
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>page.l</file>
</chapter>

<chapter>
<title>window-columns</title>
<type>Function</type>
<arguments>window-columns &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウの文字を表示可能な領域の幅をキャラクタ単位で返します。
window-width が対象とする幅から、必要に応じて「行番号」表示領域、「折り
返し」マーク表示領域を除いた幅を計算対象とします。
キャラクタ幅に満たない幅については切り捨てますが、返す最小値は 1 です。

補足：
  具体的には、window-width の返す値から、「行番号」表示時は、行番号表示
  桁数 (xyzzy 0.2.2.233 では 6) ＋境界線分 (1) が引かれます。
  さらに、「折り返し」表示かつ、テキストの折り返しが「ウィンドウ幅」の場
  合には、「折り返し」マーク分 (1) が引かれます。
</description>
<seealso>window-width</seealso>
<seealso>window-lines</seealso>
<seealso>window-height</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*popup-completion-list-default*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
補完リスト表示のデフォルトの動作を制御します。
  :always   必ずポップアップ表示します。
  :never    *Completion*バッファで表示します。
  上記以外  個々の設定(*minibuffer-popup-completion-list*等)が
            適用されます。
</description>
<seealso>*minibuffer-popup-completion-list*</seealso>
<seealso>*lisp-popup-completion-list*</seealso>
<link></link>
<section>その他</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>*post-command-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドループにおいてコマンドの実行後に実行されます。
</description>
<seealso>*pre-command-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*post-startup-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
初期設定ファイル.xyzzy実行後に以下の順番でフック変数が評価されま
す。
  1. *load-history-hook*
  2. *init-app-menu-hook*
  3. *command-line-mailto-hook*（-mailtoがある場合）
  4. *process-command-line-hook*（不明なオプションがある場合）
  5. *post-startup-hook*
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*pre-abbrev-expand-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
expand-abbrevの最初に実行されます。
</description>
<seealso>expand-abbrev</seealso>
<link></link>
<section>変数と定数</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>*pre-command-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドループにおいてコマンドの実行前に実行されます。 
</description>
<seealso>*post-command-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*pre-startup-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
初期設定ファイルsiteinit.l実行後に実行されます。
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*prefix-args*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドが数引き数付きで呼ばれた場合に設定される変数です。

  (defun test1 ()
    (interactive)
    (message "~s,~s " *prefix-args* *prefix-value*))

例えば、C-u 10 M-x test1と呼び出されると、
*prefix-args* が non nil になり、 *prefix-value* に値が入ります。
</description>
<seealso>*prefix-value*</seealso>
<seealso>universal-argument</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*prefix-value*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドが数引き数付きで呼ばれた時に数値が入ります。
</description>
<seealso>*prefix-args*</seealso>
<seealso>universal-argument</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*print-completion-list-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
do-completion実行時に、補完リストを表示するために使用されています。
ポップアップ表示の前に処理されます。 
※funcallで実行されるので注意すること
  
使用例：
  (setq *print-completion-list-hook*
        #'(lambda (list prefix &amp;optional string)
            (popup-string
             (format nil
                     "Possible completions are ~D items:\n~{\n~A~}"
                     (length list) list) (point))))
</description>
<seealso>*popup-completion-list-default*</seealso>
<link></link>
<section>変数と定数</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>*process-command-line-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy.exeに渡されたオプション引数を判定する際に呼び出されます。
*post-startup-hook*の直前で呼び出されます。

参考：
  (run-hook-with-args-until-success
   '*process-command-line-hook* arg)
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>システム</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*query-kill-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
kill-buffer で実行されます。バッファの破棄を確認するために使用します。
※run-hook-with-args-while-successで実行されるので注意すること。
</description>
<seealso>kill-buffer</seealso>
<seealso>run-hook-with-args-while-success</seealso>
<link></link>
<section>変数と定数</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*query-kill-xyzzy-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy終了時に実行されます。このフック変数の実行がnilだと終了しません。
[xyzzy:03872]を参照
</description>
<seealso>*kill-xyzzy-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*quotation-prefix*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
引用を表す接頭子です。具体的には、 quote-region したときにリージョンの行頭
に挿入する文字列です。

参考：
  ;;; 初期値ではこんなものが設定されています。
  (defvar *quotation-prefix* "| ")
</description>
<seealso>quote-region</seealso>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*read-eval*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
読み取り時評価(read-time evaluation)を制御します。
*read-eval*がnon-nilなら #. リーダマクロは通常どうりに動作します。
nilならreader-errorが発生します。

標準はtです。

(let ((*read-eval* nil))
  (read-from-string "#.(+ 1 1)"))
=&gt; Line 1: リード時の評価が許されていません

(let ((*read-eval* t))
  (read-from-string "#.(+ 1 1)"))
=&gt; 2
   9

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*save-buffer-no-filenames-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
get-buffer-file-name が nil とかだと実行されます。
使用例:
  (add-hook '*save-buffer-no-filenames-hook*
          #'(lambda ()
              (if (yes-or-no-p "保存しますか")
                  ;;この時点で set-buffer-file-name をしても遅い。
                  ;;emacs-write-file なりを呼んでからnon-nilを渡すべき
                  (emacs-write-file (read-file-name "filename:"))
                ;;次のhookに処理を渡す場合はnilを渡す
                nil)))
</description>
<seealso>save-buffer</seealso>
<seealso>get-buffer-file-name</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*save-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
保存するヒストリの個数です。
[共通設定] - [いろいろ] - [保存するヒストリの個数(S)] で値を指定すること
ができます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*save-history-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
*kill-xyzzy-hook*実行時に呼び出されます。
コマンドバー、セッション等のヒストリ変数の保存に使用されています。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*save-resume-info*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil ならば終了時の状態を保存します。
[共通設定] - [さまざま] - [終了時の状態を保存する(U)] で値を指定すること
ができます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*select-pseudo-frame-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
フレームを選択、移動、および新規作成したときに実行されます。
すべてのフレームに対して適用されます。

フレームごとに違う動作をさせたい場合は、
フレーム構造体のスロット selected-fn に関数を設定します。
</description>
<seealso>new-pseudo-frame</seealso>
<seealso>select-pseudo-frame</seealso>
<seealso>ed::pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>*selection-ring*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
copy-selectionやkill-selectionで切り取った選択された領域を管理します。
*selection-ring*は*kill-ring*と同様にリングバッファとして管理されます。
</description>
<seealso>yank-selection</seealso>
<seealso>copy-selection</seealso>
<seealso>*kill-ring*</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>*show-cursor-line-always*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントでないウィンドウでもカーソルラインを表示します。

使用例：
  (setq *show-cursor-line-always* t)
</description>
<seealso>toggle-cursor-line</seealso>
<seealso>inverse-cursor-line</seealso>
<link></link>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*show-match-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
検索で一致したものの表示に使用しています。設定されていなければ、
show-matchが実行されます。
※run-hook-with-args-while-successで実行されるので注意すること。
</description>
<seealso>search-dialog</seealso>
<link></link>
<section>変数と定数</section>
<file>search.l</file>
</chapter>

<chapter>
<title>*show-matched-parenthesis*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
対応する括弧の表示を制御します。括弧に使用する文字は
set-syntax-match で指定します。
  non-nil  対応する括弧を表示する
  nil      対応する括弧を表示しない
</description>
<seealso>set-syntax-match</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>*smart-indentation*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
インデント処理の前後で全く変更する必要が無かった場合の制御を設定します。

  nil      位置が同じでも従来通り常に変更する
  t        位置が違う場合のみ変更する（タブとスペースの組み合わせは気にする）
  上記以外 位置が違う場合のみ変更する（タブとスペースの組み合わせは気にしない）
</description>
<seealso>smart-indentation</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>*standard-output*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
標準出力を表すストリームです。
普段はステータスバーのウィンドウへの出力になっています。
lisp-interaction-mode の C-j(eval-print-last-sexp) では
そのバッファへの出力になっています。

使用例：
  ;;; eval-expression で評価した場合
  *standard-output*  
  =&gt; #&lt;status window stream 48042808&gt;

  ;;; eval-print-last-sexp で評価した場合
  *standard-output*
  =&gt; #&lt;buffer stream 48042280&gt;
</description>
<seealso>*standard-input*</seealso>
<link></link>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>*status-bar-format*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ステータスバーに表示する情報を指定する文字列です。文字の並び順に表示されます。

  t     時計
  p     カーソル位置
  c     カーソル位置の文字コード(内部コード)
  u     カーソル位置の文字コード(ユニコード)
  T     時計（曜日入り）

使用例：
  (setq *status-bar-format* "cupT")
</description>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>*std-control-default-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、デフォルト選択用の
キャラクタを設定します。

使用例：
  (setq *std-control-default-char* #\RET)
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*std-control-down-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、下方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-down-char* #\C-n)
</description>
<seealso>*std-control-up-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*std-control-next-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、
ページダウンするキャラクタを設定します。

使用例：
  (setq *std-control-next-char* #\C-v)
</description>
<seealso>*std-control-prior-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>*std-control-prior-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、
ページアップするキャラクタを設定します。

使用例：
  (setq *std-control-prior-char* #\C-u)
</description>
<seealso>*std-control-next-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>*std-control-up-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、上方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-up-char* #\C-p)
</description>
<seealso>*std-control-down-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*tail-f-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
tail-f起動時に実行されます。
</description>
<seealso>tail-f</seealso>
<link></link>
<section>モード</section>
<file>tail-f.l</file>
</chapter>

<chapter>
<title>*this-command*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
現在実行中の関数名のシンボルを格納しています。*last-command*に設定されます。
*pre-command-hook* / *post-command-hook*で特別な処理をかますのに使ったり、
実行中のコマンドを偽ったりできます。
</description>
<seealso>*last-command*</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*wrap-search*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
文字列検索でバッファの最後までいったら、最初に戻るかどうかを制御します。

| search-forward-again で、バッファの最後まで行くと、最初に
| 戻って探しつづけますよね。
| あれって禁止できないでしょうか？

  (setq *wrap-search* nil)

とすればできますけど、たまに禁止したいとなるとちょっと面倒ですね。

| と言うか、それはそれで便利なんだけど、禁止したい時もあるんです。
| 「ここ以降にあるか無いか」と言うことを知りたい時とか・・・

現在位置から最後までを narrow してサーチするとか。
count-matches が 0 だったら無いとか。
検索ダイアログから指定するとか。
</description>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>+</title>
<type>Function</type>
<arguments>+ &amp;rest NUMBERS</arguments>
<package>lisp</package>
<description>
引数を全て加算して返します。

使用例：  
  (+ 1 2 3)
  =&gt; 6
  (+ 1.2 4 -2)
  =&gt; 3.2
</description>
<seealso>-</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>-</title>
<type>Function</type>
<arguments>- NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が一つの場合にはその数値をマイナスにしたものを返します。
引数が二つ以上の場合には一つ目の引数からその他の引数を減算した数値を返します。

使用例：
  (- 3)
  =&gt; -3
  (- 3 2 1)
  =&gt; 0
</description>
<seealso>+</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>/=</title>
<type>Function</type>
<arguments>/= NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数がすべて異なっていればt、そうでなければnilを返します。

使用例：  
  (/= 2 3)
  =&gt; t
  (/= 3 3)
  =&gt; nil
  (/= 2 3 4 5)
  =&gt; t
  (/= 2 3 4 2)
  =&gt; nil
</description>
<seealso>=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>/</title>
<type>Function</type>
<arguments>/ NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が一つの場合には 1 を引数で除算した数値を返します。
引数が二つ以上の場合には一つ目の引数を二つ目の引数全てで除算した数値を返します。
  
使用例：  
  (/ 2)
  =&gt; 1/2  
  (/ 3 2 1)
  =&gt; 3/2
  (/ 4 3 2)
  =&gt; 2/3
</description>
<seealso>denominator</seealso>
<seealso>numerator</seealso>
<seealso>*</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>:case-fold</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
検索する場合に大文字と小文字を区別するかどうかを指定します。

  t     大文字と小文字を区別しません。
  nil   大文字と小文字を区別します。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:no-dup</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
検索する場合に同じ位置から行うかどうかを指定します。

  t     ひとつ次から検索を行う。
  nil   同じ位置から検索を行う。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:regexp</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
検索文字列が正規表現か否かを指定します。

  t     検索文字列は正規表現
  nil   検索文字列はただの文字列
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:reverse</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
検索する場合に正方向か逆方向かを指定します。

  t     逆方向に検索します。
  nil   正方向に検索します。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:right-bound</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:tail</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
検索した場合にカーソルを文字列の先頭か末尾のどちらに位置づけるかを指定します。

  t     カーソルを末尾に位置づけます。
  nil   カーソルを先頭に位置づけます。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>&lt;=</title>
<type>Function</type>
<arguments>&lt;= NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
隣り合った引数がすべて&lt;=の関係ならt、そうでなければnilを返します。

使用例：  
  (&lt;= 2 3 3 4)
  =&gt; t
  (&lt;= 2 4 3 5)
  =&gt; nil
</description>
<seealso>&gt;=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&lt;</title>
<type>Function</type>
<arguments>&lt; NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が小さい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (&lt; 2 3 4)
  =&gt; t
  (&lt; 2 4 3 5)
  =&gt; nil
</description>
<seealso>&gt;</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>=</title>
<type>Function</type>
<arguments>= NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数の数値がすべて等しければt、そうでなければnilを返します。

使用例：  
  (= 3 3)
  =&gt; t
  (= 3 4)
  =&gt; nil
  (= 3 3 3 3)
  =&gt; t
  (= 3 3 3 4)
  =&gt; nil
</description>
<seealso>equal</seealso>
<seealso>equalp</seealso>
<seealso>/=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&gt;=</title>
<type>Function</type>
<arguments>&gt;= NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
隣り合った引数がすべて&gt;=の関係ならt、そうでなければnilを返します。
  
使用例：  
  (&gt;= 4 3 3 2 1)
  =&gt; t
  (&gt;= 4 2 3 1)
  =&gt; nil
</description>
<seealso>&lt;=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&gt;</title>
<type>Function</type>
<arguments>&gt; NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が大きい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (&gt; 3 2 1)
  =&gt; t
  (&gt; 3 2 1 4)
  =&gt; nil
</description>
<seealso>&lt;</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>``'(backquote)</title>
<type>Misc</type>
<arguments>form</arguments>
<package>???</package>
<description>
注：タイプはリードマクロなんですが・・・
　　info-modokiでどうしようか悩んでしまいます。

``'(逆引用符(backquote))はリストをquoteします。ただし、特別な標識 `,' 
及び `,@' を用いることで、リストの要素を選択的に評価することができます。

使用例：
  ;;; 逆引用符を使用してリストを作成
  (setq f0 '(0 1 2 3))         =&gt;  (0 1 2 3)  
  (setq f1 `(0 1 2 3))         =&gt;  (0 1 2 3)
  (setq f2 `(4 5 ,(car f1)))   =&gt;  (4 5 0)
  (setq f3 `(6 7 ,(cdr f1)))   =&gt;  (6 7 (1 2 3))
  (setq f4 `(8 9 ,@(cdr f1)))  =&gt;  (8 9 1 2 3)
</description>
<seealso></seealso>
<section>マクロ</section>
<file></file>
</chapter>

<chapter>
<title>substitute-key-definition</title>
<type>Function</type>
<arguments>substitute-key-definition OLDDEF NEWDEF &amp;optional (KEYMAP *global-keymap*) (OKEYMAP KEYMAP)</arguments>
<package>editor</package>
<description>
OKEYMAP において OLDDEF が割り当てられているすべてのキーに対して、
KEYMAP において NEWDEF を割り当てます。

例：
  ;;; text-mode での行の移動を物理行単位にする
  (substitute-key-definition 'next-virtual-line 'next-line
                             *text-mode-map* *global-keymap*)
  (substitute-key-definition 'previous-virtual-line 'previous-line
                             *text-mode-map* *global-keymap*)
</description>
<seealso>define-key</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>describe-bindings</title>
<type>Function</type>
<arguments>describe-bindings</arguments>
<package>editor</package>
<description>
カレントバッファのキー割り当て一覧を表示します。
</description>
<seealso></seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>*full-keymap-length*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
make-keymap で作られるキーマップの長さです。
</description>
<seealso>make-keymap</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>local-keymap</title>
<type>Function</type>
<arguments>local-keymap &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファ BUFFER のローカルキーマップ (use-keymap で設定されたキーマッ
プ) を返します。

BUFFER が省略された場合はカレントバッファが対象になります。
</description>
<seealso>use-kaymap</seealso>
<seealso>local-set-key</seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gentemp</title>
<type>Function</type>
<arguments>gentemp &amp;optional (PREFIX t) (PACKAGE *package*)</arguments>
<package>lisp</package>
<description>
intern されたシンボルを生成します
PACKAGE に intern された PREFIX と内部カウンタをつなげたシンボルを返します

必ず衝突しないシンボルを生成します。
</description>
<seealso>gensym</seealso>
<seealso>intern</seealso>
<link></link>
<section>シンボル</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>どの関数の頭に何がつくのでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
| パッケージという概念に関係があるんだと思いますが、どの関数の頭に何がつくの
| かというのはどこを見ればわかるんでしょうか。

  M-x apropos make-chunk RET

としたときに、

  system:make-chunk

のように表示されるものはパッケージが必要なものです。ちなみに、
si は system パッケージの、c は foreign パッケージのニックネー
ムです。
----------------------------------

  editor::xyzzy-mode  `:'が2つ表示される場合はexportされていない
        ^^
  editor:xyzzy-mode   `:'が1つ表示される場合はexportされている
        ^
  xyzzy-mode          パッケージが表示されない場合は現在のパッケージから
                      直接アクセスできる
</description>
<seealso>パッケージの概要</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>エラー処理関係</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
エラーの種類のツリー（階層）です。

condition
├simple-condition
├serious-condition
│├error
││├simple-error
│││└plain-error
││├arithmetic-error
│││├division-by-zero
│││├floating-point-overflow
│││├floating-point-underflow
│││├domain-error
│││├bignum-overflow
│││└power-number-too-large
││├cell-error
│││├unbound-variable
│││├modify-constant
│││└undefined-function
││├control-error
│││└target-missing
││├file-error
│││├file-not-found
│││├path-not-found
│││├access-denied
│││├invalid-drive
│││├current-directory
│││├not-same-device
│││├write-protected
│││├bad-unit
│││├device-not-ready
│││├sharing-violation
│││├lock-violation
│││├wrong-disk
│││├file-exists
│││├not-empty
│││├archiver-error
│││├network-error
│││└file-lost-error
││├package-error
│││└simple-package-error
││├program-error
│││├no-target
│││├bad-macro-form
│││├invalid-function
│││├invalid-variable-list
│││├invalid-lambda-list
│││└invalid-keyword-list
││├type-error
││├range-error
││├stream-error
│││└end-of-file
││├reader-error
││├too-few-arguments
││├too-many-arguments
││├bad-type-specifier
││├read-only-buffer
││└dde-error
││  ├dde-timeout
││  ├dde-busy
││  ├dde-low-memory
││  ├dde-no-conv
││  ├dde-not-processed
││  ├dde-server-died
││  └dde-terminated-transaction
│├storage-condition
│├stack-overflow
│└invalid-byte-code
├quit
│└silent-quit
└warning
  └simple-warning


| xyzzyはもちろん、Emacs Lispでなくて Common Lispに合わせているんですよね。

そうです。コンディションタイプには独自のがありますけど。Stallman先生は、
直接ではないですがCommonのコンディションシステムに影響を与えているらしい
ので、仕組み的には似てます。

| コンディションって何ですか？

Commonでは、エラーと言わずにコンディションと言うらしいです(エラー以外も
投げられるから?)。簡単に言うとC++のtry-catchと同じです(多分、C++がパクっ
たんだろうけど)。

  class condition {};
  class serious_condition: public condition {};
  class error: public serious_condition {};
  class arithmetic_error: public error {};
  class division_by_zero: public arithmetic_error {};

ってのがある場合、

  throw division_by_zero;

とすると、

  try {...} catch (division_by_zero &amp;) {...}

でも、

  try {...} catch (error &amp;) {...}

でも、

  try {...} catch (condition &amp;) {...}

でも捕まえられますよね?
それと同様に

  (error 'division-by-zero)

は、

  (handler-case ... (division-by-zero (c) ...))
  (handler-case ... (error (c) ...))
  (handler-case ... (condition (c) ...))

どれででも捕まえることができます。ま、名前が違うだけでEmacsの
condition-caseと同じです(多分)。catch&amp;throwのタグに継承関係を付けた
のとも同じかも。

また、Emacsでできるかどうかは知りませんが、↓な感じで次のキャッチャにコ
ンディションを渡すこともできます。

  (handler-case
      (any-expression)
    (error (c)
      (some-expression)
      (error c)))

C++での
  try
    {
      any-expression;
    }
  catch (error &amp;)
    {
      some-expression;
      throw;
    }
と同じですけど。
</description>
<section>エラー</section>
<file></file>
</chapter>

<chapter>
<title>キーワードファイルの書き方</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
キーワードファイルは*keyword-load-path*もしくはetc-pathから検索
をします。$XYZZY/etc配下のファイルを参照して下さい。

形式：
  属性を指定する場合には以下の二つの形式で記述します。

  ;*n[attrib]
  ;**fg[bg[attrib]]

      n       キーワード番号(0-5) 3-5は0-2と同じ色の反転
      fg      文字色 0-f (0ならば普通の色)
      bg      背景色 0-f (0ならば普通の色）
      attrib  属性みたいなもの。以下のものの組み合わせ
              b bold
              u underline
              s strike-out
              l 一行丸ごと
  ;@include &lt;path&gt;  etc-pathからの相対パスでキーワードファイルを読み込む
  ;@include &quot;path&quot;  読み込み中のファイルからの相対パスでキーワードファイルを読み込む
  ;*+               conditionに関わらず以降を有効にする
  ;*-               conditionに関わらず以降を無効にする
                    キーワードが定義済みの場合は定義されたまま
  ;*--              conditionに関わらず以降を削除する
  ;*+item           itemがconditionに一致した場合に以降を有効にする
  ;*-item           itemがconditionに一致した場合に以降を無効にする
                    キーワードが定義済みの場合は定義されたまま
  ;*--item          itemがconditionに一致した場合に以降を削除する
  ;*&amp;               以降はHTMLのタグ以外でも有効なキーワードとする
  ;*&lt;               以降はHTMLのタグでのみ有効なキーワードとする

備考：
  load-keyword-fileに指定したconditionはitemと比較を行います。
  $XYZZY/lisp/html-kwd.lを参照。
  xyzzy 0.2.2.238から他のキーワードファイルの読み込み (;@include) と
  キーワードの削除 (;*--) が可能になりました。
  属性の指定はファイルローカルです。;@includeによって読み込んだ他の
  ファイルには影響を与えません。
</description>
<seealso>キーワードファイルのカスタマイズ</seealso>
<link></link>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>キーワードファイルのカスタマイズ</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
キーワードファイルをカスタマイズするには以下の方法を推奨します。

  1. *keyword-load-path*にカスタマイズしたキーワードファイルを
     置く場所を指定する

     ;; 例) $XYZZY/keyword に置く場合
     (pushnew (merge-pathnames "keyword" (si:system-root))
              *keyword-load-path* :test #'string=)

  2. 上記場所にカスタマイズしたいキーワードファイルと
     同名のファイルを作成
  3. 先頭に ;@include &lt;カスタマイズしたいファイル&gt; を追加
  4. ;*-- は ;*+ などを使ってキーワードを追加・削除・色の変更

例：
  ;;;; C# のキーワードファイルのカスタマイズ
  ;;
  :: #reigon と #endregion はキーワード番号0の色を利用
  ;; LINQ のクエリ式のキーワードを削除
  ;; http://msdn.microsoft.com/en-us/library/bb310804.aspx

  ;; etc/C# の読み込み
  ;@include &lt;C#&gt;

  ;; 色の変更
  ;*0
  #region
  #endregion

  ;; キーワードの削除
  ;*--
  from
  where
  select
  group
  into
  orderby
  join
  let
  in
  on
  equals
  by
  ascending
  descending

備考：
  このカスタマイズ方法が使えるのはxyzzy 0.2.2.238以降です。
</description>
<seealso>キーワードファイルの書き方</seealso>
<link></link>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>キー表現使用可能文字</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
#\aや#\C-bのように文字として表現します。ただし、\"'(),;`| の9文字は、
lispの構文上の特別な意味があるので、それを抑制するために'\'を前置します。

  #\a           ; a
  #\;           ; ;
  #\C-b         ; Ctrl+b
  #\C-\;        ; Ctrl+;
  #\M-\;        ; Alt+;
  #\C-M-\;      ; Ctrl+Alt+;

Ctrl、Alt、Shiftの同時押しも表現できます。C-、M-、S-の順番は何でも良いです。

  #\C-          ; Ctrl同時押し
  #\S-          ; Shift同時押し
  #\C-S-        ; Ctrl+Shift同時押し
  #\M-          ; Alt同時押し
  #\M-C-        ; Alt+Ctrl同時押し
  #\M-S-        ; Alt+Shift同時押し
  #\M-C-S-      ; Alt+Ctrl+Shift同時押し


キーによっては同時押しできるキーに制限があります。
例えばS-TABは普通のやり方ではできません。どうしてもやりたければ、
set-extended-key-translate-table を参照して下さい。

  ┌─────────────┬─────────────┐
  │キー                      │同時押しできるキー        │
  │                          ├─┬─┬─┬─┬─┬─┬─┤
  │                          │M │C │M │S │C │M │M │
  │                          │  │  │C │  │S │S │C │
  │                          │  │  │  │  │  │  │S │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │ !"#$%&amp;'()*+,-./          │○│○│○│Ｘ│Ｘ│Ｘ│Ｘ│
  │0123456789:;&lt;=&gt;?          │  │  │  │  │  │  │  │
  │@ABCDEFGHIJKLMNO          │  │  │  │  │  │  │  │
  │PQRSTUVWXYZ[\]^_          │  │  │  │  │  │  │  │
  │`abcdefghijklmno          │  │  │  │  │  │  │  │
  │pqrstuvwxyz{|}~           │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │SPC       スペースキー    │○│○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │TAB       Tabキー         │○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  │LFD                       │  │  │  │  │  │  │  │
  │RET       Enterキー       │  │  │  │  │  │  │  │
  │ESC       Escキー         │  │  │  │  │  │  │  │
  │DEL                       │  │  │  │  │  │  │  │
  │NUL                       │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │PageUp    Page Upキー     │○│○│○│○│○│○│○│
  │PageDown  Page Downキー   │  │  │  │  │  │  │  │
  │End       Endキー         │  │  │  │  │  │  │  │
  │Home      Homeキー        │  │  │  │  │  │  │  │
  │Left      ←キー          │  │  │  │  │  │  │  │
  │Up        ↑キー          │  │  │  │  │  │  │  │
  │Right     →キー          │  │  │  │  │  │  │  │
  │Down      ↓キー          │  │  │  │  │  │  │  │
  │Pause     Pauseキー       │  │  │  │  │  │  │  │
  │Scroll    ScrollLockキー  │  │  │  │  │  │  │  │
  │Apps      Applicationキー │  │  │  │  │  │  │  │
  │Insert    Insertキー      │  │  │  │  │  │  │  │
  │Delete    Deleteキー      │  │  │  │  │  │  │  │
  │Help      どのキー?       │  │  │  │  │  │  │  │
  │F1〜F24   F1〜F24キー     │  │  │  │  │  │  │  │
  │LBtnDown  左ボタン押し    │  │  │  │  │  │  │  │
  │LBtnUp    左ボタン離し    │  │  │  │  │  │  │  │
  │LBtnMove  左ボタンドラッグ│  │  │  │  │  │  │  │
  │RBtnDown  右ボタン押し    │  │  │  │  │  │  │  │
  │RBtnUp    右ボタン離し    │  │  │  │  │  │  │  │
  │RBtnMove  右ボタンドラッグ│  │  │  │  │  │  │  │
  │MBtnDown  中ボタン押し    │  │  │  │  │  │  │  │
  │MBtnUp    中ボタン離し    │  │  │  │  │  │  │  │
  │MBtnMove  中ボタンドラッグ│  │  │  │  │  │  │  │
  │XBtn1Down                 │  │  │  │  │  │  │  │
  │XBtn1Up                   │  │  │  │  │  │  │  │
  │XBtn1Move                 │  │  │  │  │  │  │  │
  │XBtn2Down                 │  │  │  │  │  │  │  │
  │XBtn2Up                   │  │  │  │  │  │  │  │
  │XBtn2Move                 │  │  │  │  │  │  │  │
  │MouseMove                 │  │  │  │  │  │  │  │
  └─────────────┴─┴─┴─┴─┴─┴─┴─┘

例えば、#\RETと#\C-mは内部的には同じ文字と見なされます。このような文字は以下
のとおりです。

  (eq #\TAB #\C-i) =&gt; t
  (eq #\LFD #\C-j) =&gt; t
  (eq #\RET #\C-m) =&gt; t
  (eq #\ESC #\C-[) =&gt; t
  (eq #\DEL #\C-?) =&gt; t
  (eq #\NUL #\C-@) =&gt; t

xyzzy 0.2.2.236 からCommon Lispと同様の文字も利用可能です。
このような文字は以下のとおりです。

  (eq #\Backspace #\C-h) =&gt; t
  (eq #\Tab       #\TAB) =&gt; t
  (eq #\Newline   #\LFD) =&gt; t
  (eq #\Linefeed  #\LFD) =&gt; t
  (eq #\Page      #\C-l) =&gt; t
  (eq #\Return    #\RET) =&gt; t
  (eq #\Space     #\SPC) =&gt; t
  (eq #\Rubout    #\DEL) =&gt; t
</description>
<seealso>global-set-key</seealso>
<seealso>define-key</seealso>
<seealso>*kbd-translate-table*</seealso>
<link>http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_13-1-7.html</link>
<section>キーマップ</section>
<file></file>
</chapter>


<chapter>
<title>コマンドによりヒストリを変更するには？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
コマンド別にミニバッファのヒストリを管理する方法です。

  ;;; ヒストリのリスト
  (setq foo-history '("qux" "quux" "quuux"))
  
  ;;; 管理したいコマンド
  (defun foo ()
    (interactive)
    (list
     (let ((*minibuffer-default-history* foo-history)) ; ヒストリを設定する
       (prog1
         (completing-read
          "foo: "               ; プロンプト文字列
          '("foo" "bar" "baz")  ; 補完候補
          :must-match nil       ; 必ず補完候補にマッチしなきゃ駄目？
          :case-fold t)         ; 大文字小文字を区別する？
         ; 変更されたかもしれないから戻しておく
         (setq foo-history *minibuffer-default-history*)))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>チャンクの概要</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
xyzzyの外部と入出力するためのデータを格納するオブジェクトです。
チャンク自身は以下の要素から構成されます。

        ┌──────── 16byte ───────┐
        ┏━━━━┳━━━━┳━━━━┳━━━━┓
        ┃データ長┃データ型┃格納先  ┃−      ┃
        ┗━━━━┻━━━━┻━━━━┻━━━━┛
  データ長 : チャンクが管理するデータの長さです。
             make-chunkで指定します。
  データ型 : チャンクが管理するデータの型です。
  格納先   : チャンク自体には管理するデータを内包しません。
             格納先のアドレスだけを管理します。

以下は管理イメージです。

  ;;; 使用例
  (setq chunk (si:make-chunk 'string 8)) =&gt; #&lt;chunk 0x00081010&gt;
  (si:chunk-data chunk)                  =&gt; 0x00A73DC8
  (si:pack-string chunk 0 "HELLO")       =&gt; "HELLO"

      ┌アドレス┐  ┌データ─────────────┐
      ┏━━━━━┳━━━━━┯━━━━━┯━━━━━┓
      ┃0x00081010┃0x00000008│string    │0x00A73DC8┃
      ┠─────╂─────┴─────┴─────┨
      ┃0x00081018┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┠─────╂─┬─┬─┬─┬─┬─┬─┬─┬─┨
      ┃0x00A73DC8┃H │E │L │L │O │\0│  │  │  ┃
      ┠─────╂─┴─┴─┴─┴─┴─┴─┴─┴─┨
      ┃0x00A73DD0┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┗━━━━━┻━━━━━━━━━━━━━━━━━┛

チャンクから情報を取得する関数は以下のとおりです。

  si:address-of  : チャンク自身のアドレスを返します。
  si:chunk-size  : チャンクが管理するデータの長さを返します。
  si:chunk-type  : チャンクが管理するデータの型を返します。
  si:chunk-data  : チャンクが管理するデータの格納先のアドレスを返します。
  si:chunk-owner : データの格納先がチャンク自身が確保したものかどうかを返します。

チャンクを操作する関数は以下のとおりです。

  si:fill-chunk  : チャンクをfill？
  si:clear-chunk : チャンクをクリア？
  si:copy-chunk  : チャンクが管理するデータをコピーします。

チャンクの入出力をする関数は以下のとおりです。

  si:pack-int8          si:unpack-int8   :  8ビット符号付き整数用
  si:pack-uint8         si:unpack-uint8  :  8ビット符号無し整数用
  si:pack-int16         si:unpack-int16  : 16ビット符号付き整数用
  si:pack-uint16        si:unpack-uint16 : 16ビット符号無し整数用
  si:pack-int32         si:unpack-int32  : 32ビット符号付き整数用
  si:pack-uint32        si:unpack-uint32 : 32ビット符号無し整数用
  si:pack-float         si:unpack-float  : float用
  si:pack-double        si:unpack-double : double用
  si:pack-string        si:unpack-string : 文字列用
</description>
<seealso>si:make-chunk</seealso>
<link></link>
<section>チャンク</section>
<file></file>
</chapter>

<chapter>
<title>バッファの内部構造</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>

</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>パッケージの概要</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
パッケージには外部から参照されるシンボル用の空間と、内部のシンボル用の空
間があります。シンボルは最初は内部に登録されます。exportすると外部に移動
させられます。
     system        lisp        editor        user
   ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │s-exp │   │l-exp │   │e-exp │   │u-exp │ &lt;- 外部
   ├───┤   ├───┤   ├───┤   ├───┤
   │s-int │   │l-int │   │e-int │   │u-int │ &lt;- 内部
   └───┘   └───┘   └───┘   └───┘


通常は user で作業をしています。 user は lisp, editor を利用すると宣言し
ています。そのため、l-exp, e-exp, u-exp, u-int に登録されたシンボルをパ
ッケージの修飾子無しで参照できるようになっています（太枠の部分です）。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │s-exp │   ┃l-exp ┃   ┃e-exp ┃   ┃u-exp ┃ &lt;- 外部
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │s-int │   │l-int │   │e-int │   ┃u-int ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛


プログラムを書いて新しいシンボルが出てくると、u-int に登録されます。
(in-package "editor") を実行後にシンボルを書くと e-int に登録されます。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃      ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ ...  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │      │   │      │   │ bar  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
このあたりまでは分かりやすいと思うのですが、難しいのは「自分(editor)を
useしているパッケージ(user)に既にあるシンボル(foo)をexportしようとしてエ
ラーがでる」というトラブルです。


u-intとe-intのそれぞれにfooというシンボルを定義している状態を考えます。
この状態自体は問題ありませんが、この状態でeditor::fooをexportしようとす
るとエラーが発生します。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃  Ｘ  ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
user が参照可能な範囲からすると、u-intに既にあるシンボルと同じ名前のシン
ボルがe-expに入れられようとするため、「名前が衝突するためexportできませ
ん: editor::foo」と怒られます。

  (setq foo "user")
  =&gt; "user"
  (setq ed::foo "editor")
  =&gt; "editor"
  (export '(ed::foo) "ed")
  =&gt; 名前が衝突するためexportできません: editor::foo

これ以外にもこんな形でも起きます。lisp::fooとeditor::fooの間の問題のよう
ですが、実はuserがlispとeditorをuseしていることが原因です。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃ foo  ┃   ┃  Ｘ  ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃      ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>パッケージ</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
パッケージは簡単に言うと、いわゆる oblist とか obarray といったものが
いっぱいあって、リーダがシンボルを読んだときにどの obarray を使って
find-symbol や intern をするかを指定するものです。

さらに、一つのパッケージに 内部用と外部用の二つの obarray があり、通常
は内部用に intern されます。関数 export で、内部用から外部用に移動するこ
とができます。

内部用と外部用の違いは、パッケージを作るときに(作るときじゃなくてもい
いけど)他のパッケージを使用(use)すると宣言すると、ある名前を find-symbol
するときに、そのシンボルが指定されたパッケージに存在しない場合、そのパッ
ケージが使用しているパッケージの外部用にあるかを見にいくようになっています。

exportの仕組み：
  exportしても全部のパッケージから見えるわけじゃなくて、そのパッ
  ケージをuseしているパッケージから見えるようになるだけです。

  (package-use-list "user")
  =&gt; (#&lt;package: lisp&gt; #&lt;package: editor&gt;)

  (package-use-list "editor")
  =&gt; (#&lt;package: lisp&gt;)

  なので、editorパッケージから見えるのは、editorのシンボルとlispのexportさ
  れたシンボルだけです。
  ※「見える」というのはパッケージの修飾子なしで参照できるという意味合いです。
</description>
<seealso>どの関数の頭に何がつくのでしょうか？</seealso>
<seealso>export</seealso>
<seealso>use-package</seealso>
<seealso>パッケージの概要</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>ファイル操作の例</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
(defun find-modify-save-test (file)
  (interactive "f")
  (let (temp-buffer)
    (unwind-protect
        (progn
          ;; テンポラリのバッファを作って
          (setq temp-buffer (create-new-buffer "*foo*"))
          ;; カレントバッファにして
          (set-buffer temp-buffer)
          ;; ファイルを読み込む
          (insert-file-contents (merge-pathnames file *src-dir*))
          (goto-char (point-min))
          ;; ここでいろいろやる

          ;; ファイルに書く
          (write-file (merge-pathnames file *dst-dir*)))
      ;; バッファを作っていたら消す(kill-bufferはうるさいのでdelete-bufferで)
      (when temp-buffer
        (delete-buffer temp-buffer)))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>印刷時のヘッダやフッタに関する表記</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
印刷時のヘッダやフッタに関する表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
印刷時のヘッダやフッタに関する表記 
header and footer 1999/12/25　Written by Tetsuya Kamei [xyzzy:03752] 

  %f   ファイル名
  %F   ファイル名 (ディレクトリ付き)
  %b   バッファ名
  %p   ページ番号
  %P   総ページ数

  %Y   西暦 (YYYY)
  %y   西暦 (YY)
  %m   月   (1〜12)
  %0m  月   (01〜12)
  %*m  月   (January〜December)
  %:m  月   (Jan〜Dec)
  %d   日   (1〜31)
  %0d  日   (01〜31)
  %*w  曜日 (Sunday〜Saturday)
  %:w  曜日 (Sun〜Sat)
  %w   曜日 (日〜土)
  %h   時   (0〜23)
  %0h  時   (00〜23)
  %H   時   (0〜11)
  %0H  時   (00〜11)
  %:H  時   (1〜12)
  %0:H 時   (01〜12)
  %*H       (AM/PM)
  %*:H      (am/pm)
  %M   分   (0〜59)
  %0M  分   (00〜59)
  %s   秒   (0〜59)
  %0s  秒   (00〜59)

  %-   横線

  %l   以前を左詰め
  %r   以降を右詰め
       指定されない部分は中央揃え

  それ以外の文字はそのまま
  --------------------------------------------------------------------------------
  (デフォルト)
    [ヘッダ] %F%l%r%:w, %0d %:m %Y %0h:%0M:%0s
    [フッタ] - %p - 
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>各種ロード関係の関数の違い</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
load         インタプリタでloadします。

load-library *.lcがあればそれをロードします。
             *.lcがなければ*.lをロードします。

autoload     関数1つ単位で、呼ばれたときloadするようにできます。
             関数が呼ばれるまではloadされません。

require      あるライブラリをロードします。ただし、既に
             ロード済みならロードしません。

*modules*    この変数を見ると今どのモジュールがロード済か分かります。
             既にロード済だともうロードしません。
</description>
<seealso>load</seealso>
<seealso>load-library</seealso>
<seealso>autoload</seealso>
<seealso>require</seealso>
<seealso>*modules*</seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>各種言語キーマップ</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
プログラム言語毎（というか、モード毎）にキーマップを変更することができます。

  ;;; 言語用キーマップ一覧
  *basic-mode-map*              ; BASIC用
  *csharp-mode-map*             ; C#用
  *c-mode-map*                  ; C言語用
  *c++-mode-map*                ; C++用
  *css-mode-map*                ; CSS用
  *html-mode-map*               ; HTML用
  *idl-mode-map*                ; IDL用
  *java-mode-map*               ; java用
  *LaTeX-mode-map*              ; LaTeX用
  *lisp-mode-map*               ; lisp用
  *pascal-mode-map*             ; PASCAL用
  *perl-mode-map*               ; Perl用
  *sql-mode-map*                ; SQL用

  ;;; その他キーマップ一覧
  *box-drawings-mode-map*       ; 罫線描画モード用
  *buffer-menu-mode-map*        ; buffer-menu用
  *calc-mode-map*               ; calc用
  *calendar-mode-map*           ; calendar用
  *den8-view-mode-map*          ; 電信八号のメール表示用
  *den8-summary-mode-map*       ; 電信八号のメール一覧表示用
  *den8-draft-mode-map*         ; 電信八号の下書き用
  *diff-mode-map*               ; diff用
  *async-grep-mode-map*         ; 非同期grep用
  *lisp-interaction-mode-map*   ; *scratch*というかlisp-interaction-mode用
  *fundamental-mode-map*        ; モードが無いとき用
  *log-summary-mode-map*        ; niftyのログ一覧用
  *log-article-mode-map*        ; niftyのログ用
  *command-output-mode-map*     ; 外部コマンド実行時用
  *shell-mode-map*              ; shellモード用
  *tail-f-mode-map*             ; tail-f用
  *text-mode-map*               ; テキスト用
  *view-mode-map*               ; テキスト表示用

使用例：
  ;;; c++-modeでのキー割り当てを変える
  (define-key ed::*c++-mode-map* #\C-s 'foo)

  ;;; lisp-modeでのキー割り当てを変える
  (define-key ed::*lisp-mode-map*  #\TAB 'lisp-complete-symbol)

  ;;; Lispインタラクションモードでのキー割り当てを変える
  (define-key ed::*lisp-interaction-mode-map* #\TAB 'lisp-complete-symbol)
</description>
<seealso>define-key</seealso>
<section>キーマップ</section>
<file></file>
</chapter>

<chapter>
<title>起動時処理フロー</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
  起動時の処理フローです。 $XYZZY/xyzzy.exe を起動すると、最初は init.cc
  から $XYZZY/lisp/startup.l が呼び出されます。以降の主なフローは以下
  のとおりです。
  
  init.cc: 
    1. startupをload-library 
       startup.l: 
        1. loadupをload-library 
           loadup.l: 
            1. estartup を load-library 
             （estartup.l で、e:startup を定義） 
            2. historyをload-library 
             （history.l で、 load-history-file を定義） 
            3. app-menuをload-library 
             （app-menu.l で、 init-app-menus を定義） 
            4. siteinit を load-library 
    2. ダンプが未だならダンプ 
    3. e:startup を実行 
       estartup.l の e:startup: 
        1. フレームを初期化 
        2. *pre-startup-hook* を実行 
        3. .xyzzyを実行 
        4. ヒストリを初期化 
         （history.lのload-history-fileで、 *load-history-hook* を実行） 
        5. メニューを初期化 
         （app-menu.lのinit-app-menusで、 *init-app-menus-hook* を実行） 
        6. *scratch*を作成
        7.引数解析
          (process-command-line から、 *command-line-mailto-hook* とか
           *process-command-line-hook*を実行）
        8. *post-startup-hook*を実行 
  
まとめると、起動時にユーザが変更可能な部分は、以下の順番で実行さ
れます。

  1. $XYZZY/site-lisp/siteinit.l
  2. *pre-startup-hook*
  3. ~/.xyzzy
  4. *load-history-hook*
  5. *init-app-menus-hook*
  6. *command-line-mailto-hook* （-mailtoがある場合）
  7. *process-command-line-hook* （不明なオプションがある場合）
  8. *post-startup-hook*
</description>
<seealso>*command-line-mailto-hook*</seealso>
<seealso>*init-app-menus-hook*</seealso>
<seealso>*load-history-hook*</seealso>
<seealso>*post-startup-hook*</seealso>
<seealso>*pre-startup-hook*</seealso>
<seealso>*process-command-line-hook*</seealso>
<link></link>
<section>システム</section>
<file></file>
</chapter>

<chapter>
<title>型一覧</title>
<type>Misc</type>
<arguments></arguments>
<package></package>
<description>
型は綺麗に階層構造を成す訳ではないのですが、subtypepでロジックに組み込ま
れているところから、嘘にならない程度に階層化したものです。[]付きの物は二
重に出現しています。

  list                                  リスト
  ├null                                ヌル
  └cons                                コンス
  atom                                  アトム
  ├number                              数値
  │├real                              実数
  ││├rational                        有理数
  │││├ratio                         分数
  │││└integer                       整数
  │││  └bignum                      −
  ││└float                           浮動小数点数
  ││  ├short-float                   小精度浮動小数点数
  ││  ├single-float                  単精度浮動小数点数
  ││  ├double-float                  倍精度浮動小数点数
  ││  └long-float                    長精度浮動小数点数
  │└complex                           複素数
  ├symbol                              シンボル
  │├[null]                            −
  │└keyword                           キーワード
  ├character                           文字
  │├base-character                    −
  ││└standard-char                   標準文字
  │└extended-character                −
  ├stream                              ストリーム
  │├two-way-stream                    双方向ストリーム
  │├echo-stream                       −
  │├broadcast-stream                  −
  │├file-stream                       ファイルストリーム
  │├synonym-stream                    文字列ストリーム
  │├string-stream                     −
  │└concatenated-stream               −
  ├sequence                            シーケンス
  │├[list]                            −
  │└[vector]                          −
  └array                               配列
    ├simple-array                      単純配列
    │└simple-string                   単純文字列
    └vector                            ベクタ
      ├simple-vector                   単純ベクタ
      └string                          文字列
        └[simple-string]               −

使用例：
  ;;; listはsequenceで、sequenceはatomだけど、listはatomではない。
  (subtypep 'list 'sequence)    =&gt; t
  (subtypep 'sequence 'atom)    =&gt; t
  (subtypep 'list 'atom)        =&gt; nil

参考：
  typespec.l
</description>
<seealso>deftype</seealso>
<seealso>subtypep</seealso>
<seealso>type-of</seealso>
<seealso>typep</seealso>
<link></link>
<section>シンボル</section>
<file></file>
</chapter>

<chapter>
<title>行番号等のON/OFF</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
こんなに簡単にポップアップメニューから実行できます。

使用例：
  ;;; C-RBtnUpで独自のポップアップメニューにします。
  (global-set-key #\C-RBtnUp 'my-apps-popup)
  (defun my-apps-popup ()
    (interactive)
    (track-popup-menu  
     (define-popup-menu
              (:item nil "行番号(&amp;L)"
               'toggle-line-number)
              (:item nil "スクロールバー(&amp;B)"
               'toggle-vscroll-bar)
              (:item nil "モードライン(&amp;M)"
               'toggle-mode-line)
              (:item nil "ファンクションキー(&amp;F)"
               'toggle-function-bar)
              (:item nil "折り返し(&amp;T)"
               'toggle-fold-line)
              (:item nil "リードオンリー(&amp;R)"
               'toggle-read-only))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>正規表現の表記</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
正規表現の表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
正規表現
regular expression 1999/12/29　Written by Tetsuya Kamei [xyzzy:03768] 

  ^         行頭にマッチ
  $         行末にマッチ
  .         改行文字を除く任意の 1 文字にマッチ
  [...]     文字クラスのどれか 1 文字にマッチ
  [^...]    文字クラスの補集合のどれか 1 文字にマッチ
  *         直前の正規表現の 0 回以上の繰り返しにマッチ (={0,})
  +         直前の正規表現の 1 回以上の繰り返しにマッチ (={1,})
  ?         直前の正規表現の 0 回か 1 回の繰り返しにマッチ (={0,1})
  \{M,N\}   直前の正規表現の M 回以上 N 回以下の繰り返しにマッチ
  \{M,\}    直前の正規表現の M 回以上の繰り返しにマッチ
  \{,N\}    直前の正規表現の N 回以下の繰り返しにマッチ
  \{N\}     直前の正規表現の N 回の繰り返しにマッチ
  \( \)     グルーピング
  \|        選択
  \1 〜 \9  後方参照
  \&lt;        単語の開始にマッチ
  \&gt;        単語の終了にマッチ
  \b        単語の境界にマッチ
  \B        単語の境界以外にマッチ
  \w        英数字にマッチ
  \W        英数字以外にマッチ
  \sc       シンタックスが c の 1 文字にマッチ
  \Sc       シンタックスが c 以外の 1 文字にマッチ
  \`        バッファの先頭にマッチ
  \'        バッファの最後にマッチ
  \         メタキャラクタのエスケープ

  [たぶん xyzzy 0.2.1.186 から]
  *?        直前の正規表現の 0 回以上の最短の繰り返しにマッチ
  +?        直前の正規表現の 1 回以上の最短の繰り返しにマッチ
  ??        直前の正規表現の 0 回か 1 回の最短の繰り返しにマッチ

            (let ((str "aAaaa"))
              (string-match "Aa?" str)
              (format t "[Aa? ] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0))
              (string-match "Aa??" str)
              (format t "[Aa??] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0)))
            -&gt;[Aa? ] ... "Aa": 1-3
              [Aa??] ... "A": 1-2

  \{M,N\}?  直前の正規表現の M 回以上 N 回以下の最短の繰り返しにマッチ
  \{M,\}?   直前の正規表現の M 回以上の最短の繰り返しにマッチ
  \{,N\}?   直前の正規表現の N 回以下の最短の繰り返しにマッチ
  \(?:regexp\)
            部分正規表現のグルーピングを行うが，後方参照を行わない
            (すなわち\1，\2とかを使って参照できない，と)

  [さらに xyzzy 0.2.2.202 から]
  \_&lt;       シンボルの開始位置にマッチ 
  \_&gt;       シンボルの終了位置にマッチ 
  \_b       シンボルの境界にマッチ 
  \_B       シンボルの境界以外にマッチ 
  \_s       シンボル文字にマッチ 
  \_S       シンボル文字以外にマッチ 
</description>
<seealso>Emacs 互換ではない正規表現は結構あるのでしょうか？</seealso>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>1+</title>
<type>Function</type>
<arguments>1+ NUM</arguments>
<package>lisp</package>
<description>
NUMに1を足した数を返します。

使用例：  
  (1+ 1)
  =&gt; 2
</description>
<seealso>1-</seealso>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>1-</title>
<type>Function</type>
<arguments>1- NUM</arguments>
<package>lisp</package>
<description>
NUMから1を引いた数を返します。

使用例：  
  (1- 2)
  =&gt; 1
</description>
<seealso>1+</seealso>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>abbrev-mode</title>
<type>Function</type>
<arguments>abbrev-mode &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
abbrev-modeを開始します。

使用例：
  (abbrev-mode t)
</description>
<seealso>quietly-read-abbrev-file</seealso>
<section>モード</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>abbreviate-display-string</title>
<type>Function</type>
<arguments>abbreviate-display-string STRING LENGTH &amp;optional PATHNAMEP</arguments>
<package>editor</package>
<description>
文字列を表示幅に収まるように[...]で省略して返します。

  STRING    : 表示する文字列を指定します。
  LENGTH    : 表示幅を指定します。
  PATHNAMEP : 文字列がファイル名かどうかを指定します。
              ファイル名の場合には先頭の3文字(例："C:/"）だけ残して省略します。

使用例：
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 nil)
 =&gt; "c:/xyzzy.../builtin.l"
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 t)
 =&gt; "c:/.../lisp/builtin.l"
</description>
<seealso></seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>abs</title>
<type>Function</type>
<arguments>abs NUMBER</arguments>
<package>lisp</package>
<description>
絶対値を返します。

使用例：
  ;;; 絶対値を返す。
  (abs -3.0)
  =&gt; 3.0  
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acons</title>
<type>Function</type>
<arguments>acons KEY DATUM A-LIST</arguments>
<package>lisp</package>
<description>
(KEY . DATUM) を A-LIST に加えた連想リストを返します。

  (acons x y a) == (cons (cons x y) a)

使用例：
  (setq foo '((b . 2))) =&gt; ((b . 2))
  (acons 'a 1 foo)      =&gt; ((a . 1) (b . 2))
  foo                   =&gt; ((b . 2))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acos</title>
<type>Function</type>
<arguments>acos NUMBER</arguments>
<package>lisp</package>
<description>
逆余弦関数の値を返します。
</description>
<seealso>acosh</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acosh</title>
<type>Function</type>
<arguments>acosh Z</arguments>
<package>lisp</package>
<description>
逆双曲線余弦関数を計算します。
</description>
<seealso>acos</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>add-file-history-to-menu</title>
<type>Function</type>
<arguments>add-file-history-to-menu</arguments>
<package>editor</package>
<description>
ファイルメニューの履歴のところに履歴を記録する？
（詳細不明）
(add-file-history-to-menu)
</description>
<seealso>*minibuffer-file-name-history*</seealso>
<section>その他</section>
<file>app-menu.l</file>
</chapter>

<chapter>
<title>add-history</title>
<type>Function</type>
<arguments>add-history ITEM VAR</arguments>
<package>editor</package>
<description>
VAR に ITEM を LRU順で追加します。 *minibuffer-maximum-history-count* 
を超えるときは、最も使用されていないヒストリを削除します。

また、 *minibuffer-enable-add-to-menu* が non-nil のときに、
(get VAR 'add-lru-menu-function) に関数が設定されていれば、
その関数を実行します。例えば、 *minibuffer-file-name-history* には、 
add-file-history-to-menu が設定されており、開いたファイルをメニューの
「最近使ったファイル(F)」に登録しています。

使用例：
  (add-history file '*minibuffer-file-name-history*)
  (add-history cmd '*minibuffer-execute-history*)
</description>
<seealso>*minibuffer-maximum-history-count*</seealso>
<seealso>*minibuffer-enable-add-to-menu*</seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>add-hook</title>
<type>Function</type>
<arguments>add-hook HOOK FN &amp;optional APPEND</arguments>
<package>editor</package>
<description>
フック変数に関数を追加します。

  HOOK : フック変数のシンボルを指定します。
  FN   : 関数のシンボルを指定します。

フックとは特定の処理においてユーザが望む処理を追加するための仕組みです。
xyzzyには「ユーザが修正したいだろうなぁ」と思うところにフックが仕掛けら
れています。例えば「find-fileするときには何か関数を実行したい」と思った
ら、「find-fileを上書き」したり、「xxx-find-fileを作ったり」するのではな
く、その用途に使えるフック変数がないかどうかを確認しましょう。

下の例はfind-fileする時にfunc1とfunc2を呼び出して何らかの処理をする例です。

  【準備処理】
        ;;; find-fileで呼び出される*before-find-file-hook*に
        ;;; ユーザが作った関数func1とfunc2が呼び出されるように登録する。
        (add-hook '*before-find-file-hook* 'func1)
        (add-hook '*before-find-file-hook* 'func2)

  【find-file実行時】
        ;;; find-fileを実行すると、ファイルの読み込みの前で
        ;;; *before-find-file-hook*に登録されている関数が実行される。
        (find-file ...)
          └(run-hooks '*before-find-file-hook*)
              ├(func1)
              └(func2)

  【後片付け】
        ;;; find-fileで呼び出される*before-find-file-hook*から
        ;;; ユーザが作った関数func1とfunc2を取り除く
        (delete-hook '*before-find-file-hook* 'func1)
        (delete-hook '*before-find-file-hook* 'func2)

なお、フック変数は用途に応じて呼び出され方や戻す値の意味が異なります。注
意しましょう。

使用例：
  ;;; lispmode.l
  (add-hook '*query-kill-buffer-hook* 'kill-scratch-hook)
</description>
<seealso>delete-hook</seealso>
<seealso>run-hooks</seealso>
<section>モード</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>adjoin</title>
<type>Function</type>
<arguments>adjoin ITEM LIST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
ITEM が LIST の member でなければ先頭に追加した LIST を返す。 member なら LIST を
そのまま返します。

  (adjoin item list) == (if (member item list) list (cons item list))

  :key : :keyに fn が指定された場合，xyzzyでは
          (adjoin item list) == (if (member item list :key fn) list (cons item list))
         となりますが，CLTL2では次のように動作し，非互換です．
          (adjoin item list) == (if (member (funcall fn item) list :key fn) list (cons item list))

使用例：
  (adjoin 'a '(b c d))
  =&gt; (a b c d)
  (adjoin 'b '(a b c d))
  =&gt; (a b c d)
  (adjoin '(a) '((b) (c) (d)) :key #'car)
  =&gt; ((a) (b) (c) (d))
</description>
<seealso>pushnew</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-menu-item</title>
<type>Function</type>
<arguments>add-menu-item MENU TAG NAME &amp;optional COMMAND INIT</arguments>
<package>editor</package>
<description>
新たに作成したメニュー項目をメニューの末尾に追加します。

  MENU    : 追加先のメニューを指定します。
  TAG     : 識別用のタグを指定します。
  NAME    : メニューに表示される名前を指定します。
  COMMAND : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT    : メニューが開く直前に評価し返される値によってメニューの状態を
            設定します。任意のS式が指定できますが、あまり無茶なことはしな
            いでください。式の値として意味のある値には以下のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示。
        :undo         undo不可能であれば灰色表示。
        :redo         redo不可能であれば灰色表示。
        :selection    カレントバッファのテキストが未選択であるか矩形選択
                      であれば灰色表示。
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外
                      の選択であれば灰色表示。
        :clipboard    クリップボードが空であれば灰色表示。
        :check        チェック。
        :disable      灰色表示。
        その他        使用可能。
</description>
<seealso>insert-menu-item</seealso>
<seealso>get-menu</seealso>
<seealso>create-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-menu-separator</title>
<type>Function</type>
<arguments>add-menu-separator MENU &amp;optional TAG</arguments>
<package>editor</package>
<description>
セパレータをメニューの末尾に追加します。

  MENU : 追加先のメニューを指定します。
  TAG  : 識別用のタグを指定します。
</description>
<seealso>insert-menu-separator</seealso>
<seealso>define-menu</seealso>
<seealso>define-popup-menu</seealso>
<seealso>get-menu</seealso>
<seealso>get-menu-position</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-popup-menu</title>
<type>Function</type>
<arguments>add-popup-menu MENU POPUP-MENU NAME</arguments>
<package>editor</package>
<description>
ポップアップメニューをメニューの末尾に追加します。

  MENU       : 追加先のメニューを指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (add-popup-menu *app-menu* *app-popup-menu* "編集2(&amp;E)")
  =&gt; #&lt;menu 48701736&gt;
</description>
<seealso>insert-popup-menu</seealso>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>alpha-char-p</title>
<type>Function</type>
<arguments>alpha-char-p CHAR</arguments>
<package>lisp</package>
<description>
文字が英字[A-Za-z]かどうかを判定します。

  CHAR : 判定する文字
</description>
<seealso>both-case-p</seealso>
<seealso>alphanumericp</seealso>
<seealso>characterp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>alphanumericp</title>
<type>Function</type>
<arguments>alphanumericp CHAR</arguments>
<package>lisp</package>
<description>
文字が英数字[A-Za-z0-9]かどうかを判定します。

  CHAR : 判定する文字
</description>
<seealso>alpha-char-p</seealso>
<seealso>characterp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>and</title>
<type>Macro</type>
<arguments>and &amp;rest FORMS</arguments>
<package>lisp</package>
<description>
フォームがnon-nilの間だけ順番に評価します。
フォームが一つでもnilならば、そこで評価を中断してnilを返して終了します。
全てのフォームがnon-nilならば、最後に実行したフォームの値を返します。

  ;;; exp1 がnon-nilなら exp2を実行し、
  ;;; exp2 がnon-nilなら exp3を実行し、
  ;;; exp3 がnon-nilなら.......
  (and exp1 exp2 exp3 ...)

例えば、以下の様にチェックを順番に記述するような場合に向いていると思います。
チェックに失敗すれば、以降の処理は実行しません。

  (and (file-exist-p ...) ; 特定のファイルの存在チェック
       (find-file ...)    ; そのファイルを読み込みチェック
       (scan-buffer ...)  ; 正規表現で検索
       (match-string 2)   ; 検索結果のチェック
       ...)
</description>
<seealso>or</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>append-trail-slash</title>
<type>Function</type>
<arguments>append-trail-slash STRING</arguments>
<package>editor</package>
<description>
文字列の末尾に"/"がなければ"/"を追加します。

使用例：
  (append-trail-slash "ffjfj")
  =&gt; "ffjfj/"
  (append-trail-slash "ffjfj/")
  =&gt; "ffjfj/"
</description>
<seealso>remove-trail-slash</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>append</title>
<type>Function</type>
<arguments>append &amp;rest LISTS</arguments>
<package>lisp</package>
<description>
複数のリストを引数にとってそれらを結合したリストを返します。
引数は保存されます。

使用例：
  ;;; リストをくっつけてみる。
  (setq x '(a b c))
  (setq y '(d e f))
  (append x y)
  =&gt;(a b c d e f)
  x
  =&gt;(a b c)
  y
  =&gt;(d e f)
</description>
<seealso>nconc</seealso>
<seealso>concatenate</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>apply</title>
<type>Function</type>
<arguments>apply FUNCTION ARG &amp;rest MORE-ARGS</arguments>
<package>lisp</package>
<description>
引数を格納したリストを指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が必ず定まって
いる場合には、applyを使う必要は無くfuncallの方が良いと思います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                =&gt; a
  (apply 'car '((a b c)))       =&gt; a
  (apply #'car '((a b c)))      =&gt; a
</description>
<seealso>funcall</seealso>
<seealso>multiple-value-call</seealso>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>apps-popup</title>
<type>Function</type>
<arguments>apps-popup</arguments>
<package>editor</package>
<description>
ポップアップメニューを表示します。[Apps]

メニューは、*app-popup-menu* に定義されたものが使用されます。
</description>
<seealso>mouse-menu-popup</seealso>
<link></link>
<section>メニュー</section>
<file>mouse.l</file>
</chapter>

<chapter>
<title>apropos</title>
<type>Function</type>
<arguments>apropos STRING &amp;optional PRINT-KEY PRED</arguments>
<package>editor</package>
<description>
指定した正規表現に一致するシンボルの一覧を表示します。

  STRING    : 検索する文字列
  PRINT-KEY : バインドされているキーを表示するかどうか
        non-nil : 表示する
        nil     : 表示しない
  PRED      : ？？？
</description>
<seealso>*apropos-no-regexp*</seealso>
<seealso>command-apropos</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>archiver-dll-config-dialog</title>
<type>Function</type>
<arguments>archiver-dll-config-dialog DLL &amp;optional MODE</arguments>
<package>editor</package>
<description>
アーカイバの設定ダイアログを表示します。

  DLL  : 設定するアーカイバを指定します。
  MODE : （詳細不明）

使用例：
  (archiver-dll-config-dialog :unlha32)
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>archiver-dll-version</title>
<type>Function</type>
<arguments>archiver-dll-version DLL</arguments>
<package>editor</package>
<description>
アーカイバのバージョンを取得します。

  DLL  : アーカイバを指定します。

使用例：
  (archiver-dll-version :unrar32)
  =&gt; "0.09"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>aref</title>
<type>Accessor</type>
<arguments>aref ARRAY &amp;rest SUBSCRIPTS</arguments>
<package>lisp</package>
<description>
SUBSCRIPTS で特定される配列の要素にアクセスします。SUBSCRIPTS がなく配列が
ゼロ次元の場合は、配列のただひとつの要素にアクセスします。
具体的な使い方については、以下の例を参照してください。

使用例：
  ;;; 2x2の初期化された配列を作ります。値の取得・変更を行います。
  (setf foo (make-array '(2 2) :initial-contents '((1 2) (3 4))))
  =&gt;#2A((1 2) (3 4))
  (aref foo 1 1);配列fooの要素(1,1)の値を得る
  =&gt;4
  (setf (aref foo 1 1) 10);配列fooの要素(1,1)の値を10にする
  =&gt;10
  foo
  =&gt;#2A((1 2) (3 10))
</description>
<seealso>make-array</seealso>
<seealso>setf</seealso>
<seealso>svref</seealso>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>arrayp</title>
<type>Function</type>
<arguments>arrayp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が array なら t 、それ以外なら nil を返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ash</title>
<type>Function</type>
<arguments>ash INTEGER COUNT</arguments>
<package>lisp</package>
<description>
整数をロジカルにシフトします。

  INTEGER : シフトする数値
  COUNT   : ビット数分だけ正ならば左に、負ならば右にシフト
  
例：
  ;;; 4を左と右に3ビットずつシフトさせてみる。
  (ash 4 3)
  =&gt; 32
  (ash 4 -3)
  =&gt; 0
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>asin</title>
<type>Function</type>
<arguments>asin NUMBER</arguments>
<package>lisp</package>
<description>
逆正弦関数の値を返します。
</description>
<seealso>asinh</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>asinh</title>
<type>Function</type>
<arguments>asinh Z</arguments>
<package>lisp</package>
<description>
逆双曲線正弦関数を計算します。
</description>
<seealso>asin</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>assoc-if-not</title>
<type>Function</type>
<arguments>assoc-if-not PREDICATE A-LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で car 部が PREDICATE を満たさない最初のペアを返します。

使用例：
  (assoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (a . b)
</description>
<seealso>assoc</seealso>
<seealso>assoc-if</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>assoc-if</title>
<type>Function</type>
<arguments>assoc-if PREDICATE A-LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で car 部が PREDICATE を満たす最初のペアを返します。

使用例：
  (assoc-if #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (1 . c)
</description>
<seealso>assoc</seealso>
<seealso>assoc-if-not</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>assoc</title>
<type>Function</type>
<arguments>assoc ITEM A-LIST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で car 部が ITEM との :test を満たす最初のペアを返します。

使用例：
  (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) 
  =&gt;  (r . x) 
  (assoc 'goo '((foo . bar) (zoo . goo)))
  =&gt; nil 
  (assoc '2 '((1 a b c) (2 b c d) (-7 x y z)))
  =&gt; (2 b c d)
</description>
<seealso>assoc-if</seealso>
<seealso>assoc-if-not</seealso>
<seealso>rassoc</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>atan</title>
<type>Function</type>
<arguments>atan Y &amp;optional X</arguments>
<package>lisp</package>
<description>
逆正接関数の値を返します。
</description>
<seealso>atanh</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>atanh</title>
<type>Function</type>
<arguments>atanh Z</arguments>
<package>lisp</package>
<description>
逆双曲線正接関数を計算します。
</description>
<seealso>atan</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>atom</title>
<type>Function</type>
<arguments>atom OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsでなければt、それ以外ならnilを返します。

  (atom x) == (typep x 'atom) == (not (typep x 'cons))

注意：(atom '()) は '() == nilなのでt
</description>
<seealso>consp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>auto-fill-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
入力の結果、fill-columnを越えたらdo-auto-fillから実行されます。
</description>
<seealso>*auto-fill-hook</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>auto-save</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
自動保存を行うかを制御するためのフラグです。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。

  t     自動保存する
  nil   自動保存しない

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  =&gt; t  
  (setq auto-save nil)
  =&gt; nil
</description>
<seealso>setup-temp-buffer</seealso>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>autoload-function-p</title>
<type>Function</type>
<arguments>autoload-function-p DEF</arguments>
<package>lisp</package>
<description>
指定された関数がautoloadされたか否かを返します。
  nil 指定された関数がautoload済み
      もしくはautoloadしない関数の場合
  t   指定された関数がautoload前の場合

使用例：
  (export 'lisp-info-F1)
  (autoload 'lisp-info-F1 "info-modoki" t)
  (autoload-function-p 'lisp-info-F1)
  =&gt; t
  (lisp-info-F1)
  (autoload-function-p 'lisp-info-F1)
  =&gt; nil
</description>
<seealso>autoload</seealso>
<link></link>
<section>関数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>autoload</title>
<type>Function</type>
<arguments>autoload FN FILE &amp;optional COMMANDP MACROP</arguments>
<package>lisp</package>
<description>
関数が呼び出された時点でファイルをロードするよう宣言します。

  FN       : 関数シンボルを指定します。
  FILE     : ロードするファイルを指定します。
  COMMANDP : 実行するときに interactive に実行するかどうかを指定します。
  MACROP   : マクロかどうかを指定します。

FN が既に関数として定義されている場合はなにもしません。
定義されていない場合は新たに関数を作って FN の一時的な定義とします。この
関数は初めて FN が呼ばれたときに実行され、指定されたファイル FILE から本
来呼び出されるべき FN の定義をロードします。もし FILE 中に FN の定義が存
在しなければエラーとなります。

関数を呼び出す側からは、元々そのファイルがロードされていたかのように実行
を続けます。めったに使わない関数を autoload で宣言しておくとメモリ消費
量を節約できます。また、起動時にファイルをロードしないので起動が速くなり
ます。

使用例：
  ;;; defs.lより
  (autoload 'search-dialog "dialogs" t)
  (autoload 'replace-dialog "dialogs" t)
  (autoload 'count-matches-dialog "dialogs" t)
  (autoload 'goto-line-dialog "dialogs" t)
  (autoload 'open-file-dialog "dialogs" t)
</description>
<seealso>mc-autoload</seealso>
<seealso>autoload-function-p</seealso>
<seealso>各種ロード関係の関数の違い</seealso>
<section>関数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>back-to-indentation</title>
<type>Function</type>
<arguments>back-to-indentation</arguments>
<package>editor</package>
<description>
カーソルをインデントの末尾（行の最初の空白でない文字）へ移動します。
[ESC m]
</description>
<seealso>beginning-of-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-char</title>
<type>Function</type>
<arguments>backward-char &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
指定された文字数だけ後方に移動します。行頭ならば前行の終端に位置します。
[C-b], [Left]

互換性：
   Emacsではバッファの先頭ではエラーが発生します。xyzzyではエラーは発生
  しません。その代わり、動けたときは t、動けなければ nil を返します。
</description>
<seealso>forward-char</seealso>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-kill-paragraph</title>
<type>Function</type>
<arguments>backward-kill-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
現在のパラグラフの先頭までkillします。
</description>
<seealso>kill-paragraph</seealso>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>backward-kill-word</title>
<type>Function</type>
<arguments>backward-kill-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から後方の単語の先頭までを切り取り、キルリングに追加します。
[ESC C-h]
カーソルが単語の途中にある場合は、カーソル位置からその単語の先頭までが、
対象となります。
</description>
<seealso>kill-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-paragraph</title>
<type>Function</type>
<arguments>backward-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを段落の先頭に移動します。[ESC {]
</description>
<seealso>forward-paragraph</seealso>
<link></link>
<section>ポジション</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>backward-sexp</title>
<type>Function</type>
<arguments>backward-sexp &amp;optional (ARG 1) NOERROR</arguments>
<package>editor</package>
<description>
lisp-modeでS式を1つ戻します。[ESC C-b]

使用例：
  (backward-sexp)
</description>
<seealso>forward-sexp</seealso>
<seealso>down-list</seealso>
<section>バッファ</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>backward-word</title>
<type>Function</type>
<arguments>backward-word &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
カーソルを後方の単語に移動します。[ESC b]
</description>
<seealso>forward-word</seealso>
<seealso>backward-char</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>base64-decode-region-to-file</title>
<type>Function</type>
<arguments>base64-decode-region-to-file FILENAME FROM TO</arguments>
<package>editor</package>
<description>
リージョンをBase64デコードしてファイルに保存します。
</description>
<seealso>si:base64-decode</seealso>
<seealso>base64-decode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>base64-decode-region</title>
<type>Function</type>
<arguments>base64-decode-region FROM TO</arguments>
<package>editor</package>
<description>
リージョンをBase64デコードします。
</description>
<seealso>si:base64-encode</seealso>
<seealso>base64-decode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>beginning-of-buffer</title>
<type>Function</type>
<arguments>beginning-of-buffer</arguments>
<package>editor</package>
<description>
カーソルをバッファの先頭に移動します。[ESC &lt;]
元あったカーソル位置にはマークを設定します。

マークを変更しないためには
(goto-char (point-min))を使います。
</description>
<seealso>end-of-buffer</seealso>
<seealso>set-mark-command</seealso>
<seealso>selection-beginning-of-buffer</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>beginning-of-defun</title>
<type>Function</type>
<arguments>beginning-of-defun &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを関数定義の先頭に移動します。[ESC C-a]
</description>
<seealso>end-of-defun</seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>beginning-of-line</title>
<type>Function</type>
<arguments>beginning-of-line</arguments>
<package>editor</package>
<description>
行頭に移動します。goto-bolのinteractive版です。[C-a], [C-Left]
</description>
<seealso>end-of-line</seealso>
<seealso>back-to-indentation</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>block</title>
<type>Special Form</type>
<arguments>block NAME {FORM}*</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最後のフォームの結果を返します。 
ほとんどprognですがreturn-fromやreturnで戻り値が指定できるところが違います。
returnやreturn-fromにぶつかったときには残りの式は評価しません。
</description>
<seealso>return-from</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bobp</title>
<type>Function</type>
<arguments>bobp</arguments>
<package>editor</package>
<description>
ポイントがバッファの先頭にあるか否かを返します。
  t    ポイントがバッファの先頭にある。
  nil  ポイントがバッファの先頭にはない。
</description>
<seealso>eobp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bolp</title>
<type>Function</type>
<arguments>bolp</arguments>
<package>editor</package>
<description>
カーソルが行頭にあればt、そうでなければnilを返します。
</description>
<seealso>eolp</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>both-case-p</title>
<type>Function</type>
<arguments>both-case-p CHAR</arguments>
<package>lisp</package>
<description>
CHAR が大文字小文字のある文字なら t 、そうでなければ nil を返します。

使用例：  
  (both-case-p #\a)
  =&gt; t
  (both-case-p #\A)
  =&gt; t
  (both-case-p #\RET)
  =&gt; nil
</description>
<seealso>lower-case-p</seealso>
<seealso>upper-case-p</seealso>
<seealso>alpha-char-p</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>boundp</title>
<type>Function</type>
<arguments>boundp SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルに値が設定されているかどうかを返します。

使用例：
  (boundp 'test)          =&gt; nil
  (defvar test "string")  =&gt; test
  (boundp 'test)          =&gt; t
</description>
<seealso>fboundp</seealso>
<seealso>macro-function</seealso>
<seealso>makunbound</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>broadcast-stream-streams</title>
<type>Function</type>
<arguments>broadcast-stream-streams BROADCAST-STREAM</arguments>
<package>lisp</package>
<description>
make-broadcast-streamで作られたBROADCAST-STREAMの出力先のストリームのリ
ストを返します。

使用例：
  ;;; hogeの出力先をリストで得る。
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (broadcast-stream-streams hoge))))
  =&gt; (#&lt;file-output stream: C:/applications/xyzzy/foo.txt&gt;
      #&lt;file-output stream: C:/applications/xyzzy/bar.txt&gt;)
</description>
<seealso>make-broadcast-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>BS と C-h に別々の機能を割り当てるには？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
| (global-set-key #\C-h 'replace-dialog) という設定を行うと、
| BS Key を押下した場合も、ダイアログが出てきます。

伝統的な仕様ですが、

  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)

このようにすれば逃げられなくもないです。
</description>
<seealso>global-set-key</seealso>
<section>キーマップ</section>
<file></file>
</chapter>

<chapter>
<title>buffer-can-redo-p</title>
<type>Function</type>
<arguments>buffer-can-redo-p BUFFER</arguments>
<package>editor</package>
<description>
バッファがredo可能な状態ならt、そうでなければnilを返します。
</description>
<seealso>redo</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-can-undo-p</title>
<type>Function</type>
<arguments>buffer-can-undo-p BUFFER</arguments>
<package>editor</package>
<description>
bufferがundo可能ならt、そうでなければnilを返します。
</description>
<seealso>undo</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-fileio-encoding</title>
<type>Function</type>
<arguments>buffer-fileio-encoding &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの文字エンコーディングを返します。変更する場合には、
set-buffer-fileio-encodingを使用します。

使用例：
  (buffer-fileio-encoding)
  =&gt; #.(make-iso2022-encoding "jis" ... )

参照：
  kanji.l
</description>
<seealso>set-buffer-fileio-encoding</seealso>
<seealso>*default-fileio-encoding*</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-fold-width</title>
<type>Function</type>
<arguments>buffer-fold-width &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
折り返しの状態を返します。

  BUFFER : 状態を取得するバッファ

戻り値は以下のとおりです。

  t    ウィンドウ幅で折り返す
  nil  折り返しをしない
  数値 その幅で折り返しをします。

多値で返ってきている t の意味は不明です。
</description>
<seealso>default-fold-width</seealso>
<seealso>set-buffer-fold-width</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-lines</title>
<type>Function</type>
<arguments>buffer-lines &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの物理行数を返します。

使用例：  
  (buffer-lines)
  =&gt; 5014
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-list</title>
<type>Function</type>
<arguments>buffer-list &amp;key :buffer-bar-order</arguments>
<package>editor</package>
<description>
全バッファをリストで返します。

使用例:
  (buffer-list)
  =&gt;(#&lt;buffer:  *Minibuf0*&gt; #&lt;buffer: *grep*&gt; #&lt;buffer: *scratch*&gt; #&lt;buffer: *untitled*&gt; #&lt;buffer: addref.xml&gt; #&lt;buffer: reference.xml&gt;)
  
  (buffer-list :buffer-bar-order t)
  =&gt;(#&lt;buffer: *scratch*&gt; #&lt;buffer: reference.xml&gt; #&lt;buffer: *untitled*&gt; #&lt;buffer: addref.xml&gt; #&lt;buffer: *grep*&gt; #&lt;buffer:  *Minibuf0*&gt;)
  
  ;;ミニバッファの名前はスペースで始まる点に注意
  (mapcar #'buffer-name (buffer-list))
  =&gt;(" *Minibuf0*" "*grep*" "*scratch*" "*untitled*" "addref.xml" "reference.xml")
</description>
<seealso>enum-buffers</seealso>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-local-value</title>
<type>Function</type>
<arguments>buffer-local-value BUFFER SYMBOL</arguments>
<package>editor</package>
<description>
指定されたバッファのローカル変数の値を返します。

  BUFFER : ローカルな値を取得したいバッファ
  SYMBOL : ローカル変数

使用例：
  (buffer-local-value (selected-buffer) 'mode-name)
  =&gt; "xmldoc"
</description>
<seealso>symbol-value</seealso>
<seealso>make-local-variable</seealso>
<seealso>defvar-local</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-menu</title>
<type>Function</type>
<arguments>buffer-menu</arguments>
<package>editor</package>
<description>
バッファ一覧を表示します。
一覧の中ではバッファの選択、削除などができます。
</description>
<section>バッファ</section>
<file>buf-menu.l</file>
</chapter>

<chapter>
<title>buffer-mode</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントバッファのモードを格納しています。

使用例：
  ;;; list-interaction-modeの場合
  buffer-mode
  =&gt; lisp-interaction-mode
</description>
<seealso>mode-name</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>buffer-modified-count</title>
<type>Function</type>
<arguments>buffer-modified-count &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
（バッファが修正されたカウント数？）
</description>
<seealso>buffer-modified-p</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-modified-p</title>
<type>Function</type>
<arguments>buffer-modified-p &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファ BUFFER が変更を加えられているかどうかを返します。
バッファが変更されていない時は nil を、変更されている時はバッファの編集
回数(buffer-modified-count の値)を返します。
BUFFER が指定されない、もしくは nil が指定された時はカレントバッファの結
果を返します。
</description>
<seealso>set-buffer-modified-p</seealso>
<seealso>buffer-modified-count</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-name</title>
<type>Function</type>
<arguments>buffer-name BUFFER</arguments>
<package>editor</package>
<description>
バッファの名前を返します。

  BUFFER : 名前を返すバッファを指定します。

使用例：
  ;;; カレントバッファの名前を返します。
  (buffer-name (selected-buffer))
  =&gt; "reference.xml"
</description>
<seealso>create-new-buffer</seealso>
<seealso>get-buffer-create</seealso>
<seealso>rename-buffer</seealso>
<seealso>find-name-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-process</title>
<type>Function</type>
<arguments>buffer-process BUFFER</arguments>
<package>editor</package>
<description>
バッファに結び付けられているプロセスを返します。
プロセスはmake-processで作成します。
</description>
<seealso>make-process</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-read-only</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファが読み取り専用かどうかを管理します。

  t     バッファは読み取り専用
  nil   バッファは読み書き可能
</description>
<seealso>toggle-read-only</seealso>
<seealso>setup-temp-buffer</seealso>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>buffer-selector</title>
<type>Function</type>
<arguments>buffer-selector</arguments>
<package>editor</package>
<description>
バッファ選択ウィンドウを表示します。
バッファ選択されればそのバッファを、そうでなければnilを返します。
</description>
<seealso>select-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-size</title>
<type>Function</type>
<arguments>buffer-size &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファのサイズを返します。2バイト文字があるので buffer-size の返す値と
ファイルサイズは一致しません。

使用例：
  (buffer-size)
  =&gt; 200170
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-buffer</title>
<type>Function</type>
<arguments>buffer-stream-buffer STREAM</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームが関連付けられているバッファを返します。

  STREAM : buffer-streamであるストリームを指定します。
</description>
<seealso>make-buffer-stream</seealso>
<seealso>buffer-stream-point</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>buffer-stream-p</title>
<type>Function</type>
<arguments>buffer-stream-p STREAM</arguments>
<package>editor</package>
<description>
ストリームがbuffer-streamかどうかを返します。

  STREAM : 判定するストリーム

  t   ストリームはbuffer-streamである。
  nil ストリームはbuffer-streamではない。
</description>
<seealso>make-buffer-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-point</title>
<type>Function</type>
<arguments>buffer-stream-point STREAM</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームの入出力のポイントを返します。

  STREAM : buffer-streamであるストリームを指定します。
</description>
<seealso>buffer-stream-set-point</seealso>
<seealso>buffer-stream-buffer</seealso>
<seealso>file-position</seealso>
<seealso>make-buffer-stream</seealso>
<seealso>read</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-set-point</title>
<type>Function</type>
<arguments>buffer-stream-set-point STREAM POINT</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームの入出力のポイントを指定します。

  STREAM : buffer-streamであるストリームを指定します。
  POINT  : buffer-stream上の入出力のポイントを指定します。

参考：
  misc.lの with-output-to-buffer とか with-input-from-buffer
</description>
<seealso>buffer-stream-point</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-substring</title>
<type>Function</type>
<arguments>buffer-substring FROM TO</arguments>
<package>editor</package>
<description>
バッファの指定された範囲の文字列を返します。
</description>
<seealso>substring</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bufferp</title>
<type>Function</type>
<arguments>bufferp OBJECT</arguments>
<package>editor</package>
<description>
OBJECTがバッファならばt、そうでないならnilを返します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-window</title>
<type>Function</type>
<arguments>delete-window</arguments>
<package>editor</package>
<description>
現在カーソルがあるウィンドウを削除します。 [C-x 0]
ミニバッファウィンドウは削除できません。
また、ミニバッファウィンドウ以外のウィンドウが現在のウィンドウのみの場合
は simple-error を発生します。

ウィンドウ削除後は、以下の条件のうち、最も優先度の高い条件を満たすミニ
バッファウィンドウ以外のウィンドウの領域を広げ、そのウィンドウを
set-window します。
  1. 削除ウィンドウの左辺と、右辺が一致したウィンドウ
  2. 削除ウィンドウの右辺と、左辺が一致したウィンドウ
  3. 削除ウィンドウの上辺と、底辺が一致したウィンドウ
  4. 削除ウィンドウの底辺と、上辺が一致したウィンドウ

戻り値：
  t     ウィンドウ削除成功
  nil   ウィンドウ削除失敗

補足：
  xyzzy 0.2.2.233 では (delete-buffer X) に対して (deleted-buffer-p X)
  が存在しますが、(delete-window X) に対して (deleted-window-p X) は存在
  しません。
  ;;; deleted-buffer-p を模した deleted-window-p の定義
  (in-package "editor")
  (export '(deleted-window-p))
  (defun deleted-window-p (window)
    (unless (windowp window)
      (error 'lisp::type-error :datum window :expected-type 'window))
    (handler-case
        (progn
          (window-buffer window)
          t)
      (program-error (c)
        nil)))
補足2：
  xyzzy 0.2.2.236 で deleted-window-p が追加されました。
</description>
<seealso>set-window</seealso>
<seealso>delete-other-windows</seealso>
<seealso>minibuffer-window-p</seealso>
<seealso>delete-buffer</seealso>
<seealso>deleted-buffer-p</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>deleted-window-p</title>
<type>Function</type>
<arguments>deleted-window-p WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウが削除されているかどうかを調べます。
WINDOWにはウィンドウ型のものしか指定できません。

  t   指定されたウィンドウは既に削除されています。
  nil 指定されたウィンドウは未だ削除されていません。

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>delete-window</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bury-buffer</title>
<type>Function</type>
<arguments>bury-buffer &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
other-bufferの候補の最後にします。
</description>
<seealso>other-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>butlast</title>
<type>Function</type>
<arguments>butlast LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの最後のN要素分を除いたリストを返します。
引数 LIST は保存されます。

使用例：
  ;;; 最後の要素を取り除く。
  (butlast '(1 2 3))
  =&gt; (1 2) 
  ;;; 最後の2要素を取り除く。
  (butlast '(1 2 3) 2)
  =&gt; (1) 
</description>
<seealso>nbutlast</seealso>
<seealso>last</seealso>
<seealso>subseq</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>C-z でアイコン化させるには？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
(require "wip/winapi")
(c:define-dll-entry winapi:BOOL ShowWindow (winapi:HWND c:int) "user32")

(global-set-key #\C-z #'(lambda () (interactive)
                          (ShowWindow (get-window-handle) 6)))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>caaaar</title>
<type>Function</type>
<arguments>caaaar X</arguments>
<package>lisp</package>
<description>
caaaar を返します。

  (caaaar X) = (car (car (car (car X))))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaadr</title>
<type>Function</type>
<arguments>caaadr X</arguments>
<package>lisp</package>
<description>
caaadr を返します。

  (caaadr X) = (car (car (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaar</title>
<type>Function</type>
<arguments>caaar X</arguments>
<package>lisp</package>
<description>
caaar を返します。

  (caaar X) = (car (car (car X)))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caadar</title>
<type>Function</type>
<arguments>caadar X</arguments>
<package>lisp</package>
<description>
caadar を返します。

  (caadar X) = (car (car (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaddr</title>
<type>Function</type>
<arguments>caaddr X</arguments>
<package>lisp</package>
<description>
caaddr を返します。

  (caaddr X) = (car (car (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caadr</title>
<type>Function</type>
<arguments>caadr X</arguments>
<package>lisp</package>
<description>
caadr を返します。

  (caadr X) = (car (car (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caar</title>
<type>Function</type>
<arguments>caar X</arguments>
<package>lisp</package>
<description>
caar を返します。

  (caar X) = (car (car X))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadaar</title>
<type>Function</type>
<arguments>cadaar X</arguments>
<package>lisp</package>
<description>
cadaar を返します。

  (cadaar X) = (car (cdr (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadadr</title>
<type>Function</type>
<arguments>cadadr X</arguments>
<package>lisp</package>
<description>
cadadr を返します。

  (cadadr X) = (car (cdr (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadar</title>
<type>Function</type>
<arguments>cadar X</arguments>
<package>lisp</package>
<description>
cadar を返します。

  (cadar X) = (car (cdr (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caddar</title>
<type>Function</type>
<arguments>caddar X</arguments>
<package>lisp</package>
<description>
caddar を返します。

  (caddar X) = (car (cdr (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadddr</title>
<type>Function</type>
<arguments>cadddr X</arguments>
<package>lisp</package>
<description>
cadddr を返します。

  (cadddr X) = (car (cdr (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<seealso>fourth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caddr</title>
<type>Function</type>
<arguments>caddr X</arguments>
<package>lisp</package>
<description>
caddr を返します。

  (caddr X) = (car (cdr (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<seealso>third</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadr</title>
<type>Function</type>
<arguments>cadr X</arguments>
<package>lisp</package>
<description>
cadr を返します。

  (cadr X) = (car (cdr X))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<seealso>second</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>calendar</title>
<type>Function</type>
<arguments>calendar &amp;optional YEAR</arguments>
<package>editor</package>
<description>
YEARにより指定された年のカレンダーを表示します。当日には下線が、
祝祭日には色が付いています。マウスをこれらの上に移動すると、休日
の内容がポップアップ表示されます。
</description>
<seealso></seealso>
<link></link>
<section>日付・時間</section>
<file>calendar.l</file>
</chapter>

<chapter>
<title>call-interactively</title>
<type>Function</type>
<arguments>call-interactively COMMAND &amp;optional HOOK</arguments>
<package>editor</package>
<description>
指定された関数をinteractiveに呼び出したかのごとく実行します。

  COMMAND : interactiveに呼び出す関数を指定します。
            (interactive ...)として宣言された関数でなければなりません。

使用例：
  ;;; find-fileを無引数で呼び出してもエラーになる。
  (find-file)
  =&gt; 引数が少なすぎます: (find-file)

  ;;; interactiveに呼び出すと大丈夫
  (call-interactively 'find-file)
  =&gt; Find file: C:/applications/xyzzy/
</description>
<seealso>command-execute</seealso>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>call-last-kbd-macro</title>
<type>Function</type>
<arguments>call-last-kbd-macro &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
start-kbd-macro/end-kbd-macroで登録したキーボードマクロを実行します。
[C-x e]
[ツール(T)]-[キーボードマクロおまけ(O)]-[保存]したキーボードマクロは、
[ツール(T)]-[キーボードマクロおまけ(O)]-[読み込み]で後から選択することが可能です。
</description>
<seealso>command-execute</seealso>
<link></link>
<section>マクロ</section>
<file>kbdmacro.l</file>
</chapter>

<chapter>
<title>call-process</title>
<type>Function</type>
<arguments>call-process COMMAND-LINE &amp;key :environ :no-std-handles :input :output :error :exec-directory :show :wait</arguments>
<package>editor</package>
<description>
外部プログラムを実行します。完全にxyzzyの外部でプログラムを実行します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :environ        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :no-std-handles : t の場合， :input :output :error の指定を無視します．
  :input          : 標準入力を使用する外部プログラムであれば入力ファイル名
                    を指定します。
  :output         : 標準出力を使用する外部プログラムであれば出力ファイル名
                    を指定します。
  :error          : 標準エラー出力を使用する外部プログラムであれば出力ファ
                    イル名を指定します．指定しないときは，標準出力に出力し
                    ます．
  :exec-directory : 実行するディレクトリを指定します。
  :show           : 外部プログラムの実行時の表示を指定します。
                    :show      通常のウィンドウ
                    :no-active 非アクティブ
                    :minimize  最小化
                    :maximize  最大化
                    :hide      非表示
                    上記以外   通常のウィンドウ
  :wait           : 外部プログラムが終了するのを待ち合わせます。

実行したプロセスを取得したいときは make-process を使います．

使用例：
  ;;; notepad.exeの終了を待ち合わせてみる。
  (call-process "notepad" :wait t)
</description>
<seealso>execute-shell-command</seealso>
<seealso>make-process</seealso>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>capitalize-region</title>
<type>Function</type>
<arguments>capitalize-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語をcapitalizeします。
つまり、単語の先頭を大文字に、それ以外を小文字にします。
</description>
<seealso>downcase-region</seealso>
<seealso>upcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>capitalize-word</title>
<type>Function</type>
<arguments>capitalize-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の単語の先頭の文字を大文字に、それ以外の文字を小文字に変換します。
[ESC c]
カーソルが単語の途中にある場合は、カーソル位置の文字を大文字に、それ以
降の文字を小文字に変換します。
</description>
<seealso>upcase-word</seealso>
<seealso>downcase-word</seealso>
<seealso>capitalize-region</seealso>
<seealso>capitalize-selection</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>car</title>
<type>Function</type>
<arguments>car LIST</arguments>
<package>lisp</package>
<description>
リストの最初の要素を返します。

コンスセル LIST の最初のポインタを返します。 LIST が nil の場合 car は 
nil を返すよう、定義されています。引数がリストでない場合、エラーになります
引数がリスト以外でもエラーになって欲しくない場合には、safe-car を使用します。

使用例：
  (car '(a b c))
  =&gt; a
  (car '())
  =&gt; nil
  (car "string")
  =&gt; 不正なデータ型です: "string": cons
</description>
<seealso>first</seealso>
<seealso>safe-car</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>case</title>
<type>Macro</type>
<arguments>case KEYFORM &amp;rest FORMS</arguments>
<package>lisp</package>
<description>
C言語のswitch文みたいなのです。

(case &lt;キー&gt;
  (&lt;リスト1&gt; &lt;式&gt;〜&lt;式&gt;)
  (&lt;リスト2&gt; &lt;式&gt;〜&lt;式&gt;)
       ...
  (&lt;リストn&gt; &lt;式&gt;〜&lt;式&gt;))

まず&lt;キー&gt;を評価し，それが&lt;リスト&gt;のどれかの要素と一致すれば，
その&lt;リスト&gt;に続く式を順に評価して，最後の式の値をcaseの値として返
す。どの&lt;リスト&gt;のどの要素にも一致しなければcaseの値はnilである。
ただし例外として，最後のリスト(&lt;リストn&gt;)がtであれば，「どれにも一
致しなければ」を意味する。

&lt;リスト1&gt;〜&lt;リストn&gt;までは，それぞれデータのリストで，これら
は評価されない。すなわち値がリストになる式ではなく，リストそのものがここ
に入る。要素が一つだけの場合は，リストの代わりに要素がここにきてもいい。

使用例：
  ;;; 4を入力して場合分けさせる
  (setq x 4)
  =&gt; 4
  (case x
    (1 'one)
    (2 'two)
    (3 'three)
    ((4 5) 'four_or_five)
    (t 'large))
  =&gt; four_or_five
</description>
<seealso></seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>catch</title>
<type>Special Form</type>
<arguments>catch TAG {FORM}*</arguments>
<package>lisp</package>
<description>
throwを投げるためのラベルを設定します。
C++のtryに相当します。

  C++  : try    throw
  Lisp : catch  throw

参考：
  エラー処理関連
</description>
<seealso>throw</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cdaaar</title>
<type>Function</type>
<arguments>cdaaar X</arguments>
<package>lisp</package>
<description>
cdaaar を返します。

  (cdaaar X) = (cdr (car (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaadr</title>
<type>Function</type>
<arguments>cdaadr X</arguments>
<package>lisp</package>
<description>
cdaadr を返します。

  (cdaadr X) = (cdr (car (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaar</title>
<type>Function</type>
<arguments>cdaar X</arguments>
<package>lisp</package>
<description>
cdaar を返します。

  (cdaar X) = (cdr (car (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdadar</title>
<type>Function</type>
<arguments>cdadar X</arguments>
<package>lisp</package>
<description>
cdadar を返します。

  (cdadar X) = (cdr (car (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaddr</title>
<type>Function</type>
<arguments>cdaddr X</arguments>
<package>lisp</package>
<description>
cdaddr を返します。

  (cdaddr X) = (cdr (car (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdadr</title>
<type>Function</type>
<arguments>cdadr X</arguments>
<package>lisp</package>
<description>
cdadr を返します。

  (cdadr X) = (cdr (car (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdar</title>
<type>Function</type>
<arguments>cdar X</arguments>
<package>lisp</package>
<description>
cdar を返します。

  (cdar X) = (cdr (car X))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddaar</title>
<type>Function</type>
<arguments>cddaar X</arguments>
<package>lisp</package>
<description>
cddaar を返します。

  (cddaar X) = (cdr (cdr (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddadr</title>
<type>Function</type>
<arguments>cddadr X</arguments>
<package>lisp</package>
<description>
cddadr を返します。

  (cddadr X) = (cdr (cdr (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddar</title>
<type>Function</type>
<arguments>cddar X</arguments>
<package>lisp</package>
<description>
cddar を返します。

  (cddar X) = (cdr (cdr (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdddar</title>
<type>Function</type>
<arguments>cdddar X</arguments>
<package>lisp</package>
<description>
cdddar を返します。

  (cdddar X) = (cdr (cdr (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddddr</title>
<type>Function</type>
<arguments>cddddr X</arguments>
<package>lisp</package>
<description>
cddddr を返します。

  (cddddr X) = (cdr (cdr (cdr (cdr X))))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdddr</title>
<type>Function</type>
<arguments>cdddr X</arguments>
<package>lisp</package>
<description>
cdddr を返します。

  (cdddr X) = (cdr (cdr (cdr X)))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddr</title>
<type>Function</type>
<arguments>cddr X</arguments>
<package>lisp</package>
<description>
cddr を返します。

  (cddr X) = (cdr (cdr X))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdr</title>
<type>Function</type>
<arguments>cdr LIST</arguments>
<package>lisp</package>
<description>
リストの二番目以降をリストで返します。

コンスセル LIST の 2 番目のポインタを返します。 LIST が nil の場合 cdr 
は nil を返すよう、定義されています。引数がリストでない場合、エラーにな
ります。引数がリスト以外でもエラーになって欲しくない場合には、safe-cdrを
使用します。

使用例：
  (cdr '(a b c))
  =&gt; (b c)
  (cdr '())
  =&gt; nil
  (cdr "string")
  =&gt; 不正なデータ型です: "string": cons
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ceiling</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを正の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBER以上の最小の整数になります。

使用例：  
  (ceiling 2.2)
  =&gt; 3
  (ceiling 2.8)
  =&gt; 3
  (ceiling -2.2)
  =&gt; -2  
  (multiple-value-list (ceiling 2.2))
  =&gt; (3 -0.8)
</description>
<seealso>floor</seealso>
<seealso>truncate</seealso>
<seealso>round</seealso>
<seealso>fceiling</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-code</title>
<type>Function</type>
<arguments>char-code CHAR</arguments>
<package>lisp</package>
<description>
CHAR の文字コードを返します。
文字コードとキャラクタの間の相互変換には、code-charを使います。

使用例：
  (char-code #\a)
  =&gt; 97
  (code-char (char-code #\a))
  =&gt; #\a
</description>
<seealso>code-char</seealso>
<seealso>char-unicode</seealso>
<seealso>unicode-char</seealso>
<seealso>iso-code-char</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-downcase</title>
<type>Function</type>
<arguments>char-downcase CHAR</arguments>
<package>lisp</package>
<description>
CHARを小文字にして返します。

使用例：  
  (char-downcase #\A)
  =&gt; #\a
</description>
<seealso>char-upcase</seealso>
<seealso>lower-case-p</seealso>
<seealso>string-downcase</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-equal</title>
<type>Function</type>
<arguments>char-equal CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数がすべて大文字小文字関係なく等しければt、そうでなければnilを返します。

使用例：  
  (char-equal #\A #\a)
  =&gt; t
</description>
<seealso>equalp</seealso>
<seealso>char=</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-greaterp</title>
<type>Function</type>
<arguments>char-greaterp CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく降順ならt、そうでなければnilを返します。

使用例：
  (char-greaterp #\c #\b #\a)
  =&gt; t
  (char-greaterp #\c #\b #\b)
  =&gt; nil
  (char-greaterp #\b #\A)
  =&gt; t
  (char-greaterp #\B #\a)
  =&gt; t
</description>
<seealso>char&gt;</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-lessp</title>
<type>Function</type>
<arguments>char-lessp CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく昇順ならt、そうでなければnilを返します。

使用例：  
  (char-lessp #\a #\b #\c)
  =&gt; t
  (char-lessp #\a #\b #\b)
  =&gt; nil
  (char-lessp #\A #\b)
  =&gt; t
  (char-lessp #\a #\B)
  =&gt; t
</description>
<seealso>char&lt;</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-name</title>
<type>Function</type>
<arguments>char-name C</arguments>
<package>editor</package>
<description>
文字の英字名称を返します。
この英字名称はどこで定義されたものなのでしょうか？

使用例：
  ;;; いろいろと英字名称を見てみる。
  (char-name #\x00)     =&gt; "null"
  (char-name #\x0a)     =&gt; "line_feed"
  (char-name #\x0d)     =&gt; "carriage_return"
  (char-name #\a)       =&gt; "latin_small_letter_a"
  (char-name #\が)      =&gt; "hiragana_letter_ga"
  (char-name #\ヲ)      =&gt; "katakana_letter_wo"
  (char-name #\漢)      =&gt; nil 
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>char-not-equal</title>
<type>Function</type>
<arguments>char-not-equal CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数がすべて大文字小文字関係なく等しくなければt、そうでなければnilを返します。

使用例：
  (char-not-equal #\a #\b #\c)
  =&gt; t
  (char-not-equal #\a #\A)
  =&gt; nil
</description>
<seealso>char/=</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-not-greaterp</title>
<type>Function</type>
<arguments>char-not-greaterp CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく昇順か等しければt、そうでなければnil
を返します。

使用例：  
  (char-not-greaterp #\a #\B #\c)
  =&gt; t
</description>
<seealso>char&lt;=</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-not-lessp</title>
<type>Function</type>
<arguments>char-not-lessp CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく降順か等しければt、そうでなければnil
を返します。

使用例：  
  (char-not-lessp #\c #\B #\a)
  =&gt; t
</description>
<seealso>char&gt;=</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-unicode</title>
<type>Function</type>
<arguments>char-unicode CHAR</arguments>
<package>editor</package>
<description>
文字のUNICODEのコード値を返します。

使用例：
  ;;; UNICODEのコード値を取得してみる。
  (char-unicode #\x00)  =&gt; 0
  (char-unicode #\a)    =&gt; 97
  (char-unicode #\漢)   =&gt; 28450
</description>
<seealso>unicode-char</seealso>
<seealso>char-code</seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-upcase</title>
<type>Function</type>
<arguments>char-upcase CHAR</arguments>
<package>lisp</package>
<description>
CHARを大文字にして返します。

使用例：  
  (char-upcase #\x)
  =&gt; #\X
</description>
<seealso>char-downcase</seealso>
<seealso>upper-case-p</seealso>
<seealso>string-upcase</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char/=</title>
<type>Function</type>
<arguments>char/= CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て等しくなければt、そうでなければnilを返します。

使用例：  
  (char/= #\a #\b #\c)
  =&gt; t
  (char/= #\a #\b #\a)
  =&gt; nil
  (char/= #\a #\A)
  =&gt; t
</description>
<seealso>char-not-equal</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&lt;=</title>
<type>Function</type>
<arguments>char&lt;= CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
隣り合った引数の関係がすべて昇順か等しければt、そうでなければnilを返します。

使用例：  
  (char&lt;= #\a #\b #\b #\c)
  =&gt; t
  (char&lt;= #\a #\b #\c #\b)
  =&gt; nil
</description>
<seealso>char-not-greaterp</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&lt;</title>
<type>Function</type>
<arguments>char&lt; CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て昇順ならt、そうでなければnilを返します。

使用例：  
  (char&lt; #\a #\b #\c)
  =&gt; t
  (char&lt; #\a #\b #\b)
  =&gt; nil
  (char&lt; #\A #\b)
  =&gt; t
  (char&lt; #\a #\B)
  =&gt; nil
</description>
<seealso>char-lessp</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char=</title>
<type>Function</type>
<arguments>char= CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字がすべて等しければt、そうでなければnilを返します。

使用例：  
  (char= #\a #\a #\a)
  =&gt; t
  (char= #\a #\d)
  =&gt; nil
  (char= #\a #\A)
  =&gt; nil

参考：
  case-sensitive        case-insensitive
  ----                  ----
  char=                 char-equal
  char/=                char-not-equal
  char&lt;                 char-lessp
  char&gt;                 char-greaterp
  char&lt;=                char-not-greaterp
  char&gt;=                char-not-lessp
</description>
<seealso>eql</seealso>
<seealso>equal</seealso>
<seealso>char-equal</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&gt;=</title>
<type>Function</type>
<arguments>char&gt;= CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
隣り合った引数の関係がすべて降順か等しければt、そうでなければnilを返します。

使用例：  
  (char&gt;= #\c #\b #\b #\a)
  =&gt; t
  (char&gt;= #\c #\b #\d)
  =&gt; nil
</description>
<seealso>char-not-lessp</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&gt;</title>
<type>Function</type>
<arguments>char&gt; CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て降順ならt、そうでなければnilを返します。

使用例：  
  (char&gt; #\c #\b #\a)
  =&gt; t
  (char&gt; #\c #\b #\d)
  =&gt; nil
  (char&gt; #\b #\A)
  =&gt; t
  (char&gt; #\a #\B)
  =&gt; t
</description>
<seealso>char-greaterp</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char</title>
<type>Function</type>
<arguments>char STRING INDEX</arguments>
<package>lisp</package>
<description>
STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; 先頭から最後まで取得する。
  (char "foo" -1) =&gt; 範囲外の値です: -1
  (char "foo" 0)  =&gt; #\f
  (char "foo" 1)  =&gt; #\o
  (char "foo" 2)  =&gt; #\o
  (char "foo" 3)  =&gt; 範囲外の値です: 3
</description>
<seealso>schar</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>character</title>
<type>Function</type>
<arguments>character OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTを可能ならばcharacterに変換して返します。

  (character 'x) == (coerce 'x 'character)

使用例：
  (character 'x)        =&gt; #\x
  (character "A")       =&gt; #\A
  (character "1")       =&gt; #\1
  (character "10")      =&gt; 文字への変換はサポートされていません: "10"
</description>
<seealso>coerce</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>characterp</title>
<type>Function</type>
<arguments>characterp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が character なら t 、それ以外なら nil を返します。
</description>
<seealso>alpha-char-p</seealso>
<seealso>alphanumericp</seealso>
<seealso>digit-char-p</seealso>
<seealso>kana-char-p</seealso>
<seealso>kanji-char-p</seealso>
<seealso>standard-char-p</seealso>
<seealso>extended-alphabet-char-p</seealso>
<seealso>word-char-p</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>check-type</title>
<type>Macro</type>
<arguments>check-type PLACE TYPESPEC &amp;optional STRING</arguments>
<package>lisp</package>
<description>
（詳細不明）

使用例：
  ;;; nの型チェックをしてみる。
  (check-type n integer)
</description>
<seealso></seealso>
<section>データ型</section>
<file>condition.l</file>
</chapter>

<chapter>
<title>check-valid-pathname</title>
<type>Function</type>
<arguments>check-valid-pathname PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：
  ;;; 存在するC:/xyzzy/と存在しないC:/xyzzzy/を比べてみる。
  (check-valid-pathname "C:/xyzzy/")
  =&gt; t
  (check-valid-pathname "C:/xyzzzy/")
  =&gt; nil
</description>
<seealso>file-exist-p</seealso>
<seealso>valid-path-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cis</title>
<type>Function</type>
<arguments>cis Z</arguments>
<package>lisp</package>
<description>
偏角が Z で絶対値が 1 の複素数を返します。

  (cis Z) == (complex (cos Z) (sin Z))
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>clear-all-text-attributes</title>
<type>Function</type>
<arguments>clear-all-text-attributes</arguments>
<package>editor</package>
<description>
set-text-attribute で設定した属性を全部消します
</description>
<seealso>delete-text-attributes</seealso>
<seealso>delete-text-attribute-point</seealso>
<seealso>set-text-attribute</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-input</title>
<type>Function</type>
<arguments>clear-input &amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力ストリームにバッファリングされている入力をクリアします。
</description>
<section>入出力</section>
<seealso>open</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-reverse-region</title>
<type>Function</type>
<arguments>clear-reverse-region</arguments>
<package>editor</package>
<description>
reverse-regionで反転表示した部分を元に戻します。
</description>
<seealso>reverse-region</seealso>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-undo-boundary</title>
<type>Function</type>
<arguments>clear-undo-boundary &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
UNDO情報から直近の境界を削除します。

使用例：
  (defun self-insert-space (&amp;optional (arg 1))
    (interactive "*")
    (when (eq *last-command* 'self-insert-space)
      (clear-undo-boundary))
    (self-insert-command arg))
  (define-key ed::*lisp-mode-map* #\SPC 'self-insert-space)
</description>
<seealso>undo</seealso>
<seealso>undo-boundary</seealso>
<seealso>kept-undo-information</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>close</title>
<type>Function</type>
<arguments>close STREAM &amp;key :abort</arguments>
<package>lisp</package>
<description>
指定されたストリームをクローズします。

  STREAM : クローズするストリームを指定します。
  :abort : 異常終了時に指定します。
        t       ストリームに対する副作用を取り消そうとします。
        nil     ストリーム普通に終了します。
</description>
<section>入出力</section>
<seealso>open</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clrhash</title>
<type>Function</type>
<arguments>clrhash HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの全要素を削除します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>code-char</title>
<type>Function</type>
<arguments>code-char CODE</arguments>
<package>lisp</package>
<description>
文字コードがCODEの文字を返します。
キャラクタと文字コードとの間の相互変換には、 char-code を使います。

使用例：  
  (code-char 110)
  =&gt; #\n
</description>
<seealso>char-code</seealso>
<seealso>unicode-char</seealso>
<seealso>iso-char-code</seealso>
<seealso>char-unicode</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>command-apropos</title>
<type>Function</type>
<arguments>command-apropos STRING</arguments>
<package>editor</package>
<description>
指定した正規表現に一致する interactive 宣言されている関数の一覧を表示し
ます。バインドされたキーがあれば、同時に表示します。
</description>
<seealso>apropos</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>command-execute</title>
<type>Function</type>
<arguments>command-execute COMMAND &amp;optional HOOK</arguments>
<package>editor</package>
<description>
エディタのコマンドを実行します。
 
  COMMAND  : 文字列の場合，COMMAND をキーボードマクロとして実行します。
             シンボルの場合，COMMAND を interactive に実行します。
  HOOK     : COMMANDがシンボルの場合のみ使われます。
             HOOK には，2引数関数を指定し，第1引数はシンボル名，
             第2引数にはプレフィックスアーギュメントがある場合は 
             (list *prefix-value*) が，ない時は nil が入ります。
             コマンドを実行後，HOOKが実行されます。
             これ以上の詳細は不明です。

使用例：
  ;;; (command-execute "^X^F")と書いてfind-fileを実行してみます。
  (command-execute "^X^F")
 
  ;;; interactiveなコマンドを実行してみます。
  (command-execute 'next-line)

  ;;; interactiveでないコマンドを実行してみます。
  (command-execute 'goto-bol)
  =&gt;不正なコマンドです: goto-bol

  ;;; HOOKを使ってみます。 
  (command-execute 'next-line #'(lambda (x y) (msgbox "~w\n~w" x y)))

  ;;; 各自，C-j や C-u C-j で上記のコマンドを実行してみください。
</description>
<seealso>call-interactively</seealso>
<seealso>interactive</seealso>
<seealso>execute-extended-command</seealso>
<seealso>call-last-kbd-macro</seealso>
<seealso>*prefix-args*</seealso>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>commandp</title>
<type>Function</type>
<arguments>commandp OBJECT</arguments>
<package>editor</package>
<description>
関数が interactive 宣言されていれば tを返し、そうでなければnilを返します。
</description>
<seealso>interactive</seealso>
<seealso>interactive-p</seealso>
<section>関数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compile-regexp-keyword-list</title>
<type>Function</type>
<arguments>compile-regexp-keyword-list LIST</arguments>
<package>editor</package>
<description>
regexp-keyword-list用に正規表現のコンパイルを行います。
指定するLISTの形式はregexp-keyword-listを参照して下さい。
</description>
<seealso>regexp-keyword-list</seealso>
<link></link>
<section>検索・正規表現</section>
<file>re-kwd.l</file>
</chapter>

<chapter>
<title>compile-regexp すると一応高速化されるんでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
遅くはならないはずです(^^; ま、せいぜいこの程度ですが。

  (let ((tick (get-internal-real-time)))
    (dotimes (x 100000)
      (string-match "a" "a"))
    (- (get-internal-real-time) tick))
  =&gt; 3484
  
  (let ((tick (get-internal-real-time))
        (regexp (compile-regexp "a")))
    (dotimes (x 100000)
      (string-match regexp "a"))
    (- (get-internal-real-time) tick))
  =&gt; 2984
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>compile-regexp</title>
<type>Function</type>
<arguments>compile-regexp REGEXP &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
正規表現をコンパイルします。
随時正規表現の解析を行わない分、多少検索が早くなるようです。
第二引数にnil以外を指定すると(普通はtを指定します)大文字小文字を区別しません。

  REGEXP     : コンパイルする正規表現
  :case-fold : 大文字小文字を区別するか？
        t       大文字小文字は区別しない。
        nil     大文字小文字をする。

scan-bufferの引数にコンパイルされた正規表現を渡した場合には、
compile-regexpでの指定が有効になり,scan-bufferの引数にある:case-foldは無
視されます。

使用例：
  ;;; "単語.単語:"という正規表現をコンパイルしてみる。
  ;;; 真ん中の'.'は正規表現として扱って欲しくないので、regexp-quoteする。
  (compile-regexp (concat "\\w+" (regexp-quote ".") "\\w+:"))
  =&gt; #&lt;compiled regular expression: \w+\.\w+:&gt;
</description>
<seealso>compiled-regexp-source</seealso>
<seealso>compiled-regexp-case-fold-p</seealso>
<seealso>regexpp</seealso>
<seealso>compile-regexp すると一応高速化されるんでしょうか？</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-function-p</title>
<type>Function</type>
<arguments>compiled-function-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがcompiled code objectならt、それ以外ならnilを返します。

使用例：
  ;;; carの型を調べてみる。
  (type-of #'car)
  =&gt; compiled-function
  (compiled-function-p #'car)
  =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-regexp-case-fold-p</title>
<type>Function</type>
<arguments>compiled-regexp-case-fold-p REGEXP</arguments>
<package>editor</package>
<description>
コンパイル済みの正規表現が、大文字小文字を区別するようになってい
るかどうかを判定します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  =&gt; #&lt;compiled regular expression: a+bc*d&gt;
  (compiled-regexp-case-fold-p a)
  =&gt; t
</description>
<seealso>compile-regexp</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-regexp-source</title>
<type>Function</type>
<arguments>compiled-regexp-source REGEXP</arguments>
<package>editor</package>
<description>
コンパイル済みの正規表現から元の正規表現を抽出します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  =&gt; #&lt;compiled regular expression: a+bc*d&gt;
  (compiled-regexp-source a)
  =&gt; "a+bc*d"
</description>
<seealso>compile-regexp</seealso>
<seealso>compiled-regexp-case-fold-p</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>completing-read</title>
<type>Function</type>
<arguments>completing-read PROMPT COMPLETIONS &amp;key :case-fold :default :history :must-match</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーの入力を読み取ります。

  PROMPT      : 表示するプロンプト
  COMPLETIONS : 補完入力のためのリスト
  :case-fold  : non nilなら大文字小文字を区別しない
  :default    : 初期値の指定
  :history    : 履歴情報
                minibuffer-history-variableプロパティを持つシンボルを指定します
  :must-match : non nilならCOMPLETIONS以外受け付けない
</description>
<seealso>read-string</seealso>
<seealso>interactive</seealso>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>complex</title>
<type>Function</type>
<arguments>complex REALPART &amp;optional IMAGPART</arguments>
<package>lisp</package>
<description>
指定された実数部(REALPART)と虚数部(IMAGPART)で複素数を表現します。

使用例：
  (setq a (complex 0 1))
  =&gt;#C(0 1)

  (* a a)
  =&gt;-1
</description>
<seealso>imagpart</seealso>
<seealso>realpart</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>complexp</title>
<type>Function</type>
<arguments>complexp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が complex number なら t 、それ以外なら nil を返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>concat</title>
<type>Function</type>
<arguments>concat &amp;rest SEQ</arguments>
<package>editor</package>
<description>
指定された文字列を連結します。

使用例：
  ;;; concatを使ってみる。
  (setq foo "It's ")            =&gt; "It's "
  (setq bar "show time!!!")     =&gt; "show time!!!"
  (concat foo bar)              =&gt; "It's show time!!!"
  (concat "It's " "show " "time!!!")
  =&gt;"It's show time!!!"
</description>
<seealso>concatenate</seealso>
<section>文字列</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>concatenate</title>
<type>Function</type>
<arguments>concatenate RESULT-TYPE &amp;rest SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCES を結合して RESULT-TYPE のシーケンスを新しく作り、返します。

RESULT-TYPE には make-sequence と同様のものが使用できます。
RESULT-TYPE の値によって、大まかには以下の関数と同じ挙動をします。
  'list   &lt;--&gt; append
  'string &lt;--&gt; concat
  'vector &lt;--&gt; vconcat

なお SEQUENCES と RESULT-TYPE の型は必ずしも一致しなくてもかまいません。
</description>
<seealso>make-sequence</seealso>
<seealso>append</seealso>
<seealso>concat</seealso>
<seealso>vconcat</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>concatenated-stream-streams</title>
<type>Function</type>
<arguments>concatenated-stream-streams CONCATENATED-STREAM</arguments>
<package>lisp</package>
<description>
make-concatenated-streamで作られたCONCATENATED-STREAMの入力元のストリームのリ
ストを返します。

使用例：
  ;;; hogeの入力元をリストで得る。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (concatenated-stream-streams hoge))))
  =&gt; (#&lt;string-input stream 48042632&gt;
      #&lt;string-input stream 48042544&gt;)
</description>
<seealso>make-concatenated-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cond</title>
<type>Macro</type>
<arguments>cond &amp;rest FORMS</arguments>
<package>lisp</package>
<description>
C 言語などの if ... else if ... のようなものです。

構文は以下のようになっています。

(cond (&lt;テスト1&gt; &lt;式&gt;〜&lt;式&gt;)
      (&lt;テスト2&gt; &lt;式&gt;〜&lt;式&gt;)
        ...
      (&lt;テストn&gt; &lt;式&gt;〜&lt;式&gt;))

テストが真になる最初の節の式を評価します。
上の式は次と等価です。

(if &lt;テスト1&gt;
     (progn &lt;式&gt;〜&lt;式&gt;)
   (if &lt;テスト2&gt;
        (progn &lt;式&gt;〜&lt;式&gt;)
      ...
      (if &lt;テストn&gt;
           (progn &lt;式&gt;〜&lt;式&gt;)
         nil)))

テストに t を指定するとデフォルトで実行される節を指定できます。

また特別な場合として、テストの後ろの式がない場合にはテストの結果が戻り値
となります。
</description>
<seealso>if</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>conjugate</title>
<type>Function</type>
<arguments>conjugate NUMBER</arguments>
<package>lisp</package>
<description>
共役複素数を返します。
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>connect</title>
<type>Function</type>
<arguments>connect HOSTNAME SERVICE &amp;key :encoding</arguments>
<package>editor</package>
<description>
ホストのポートとのTCP接続を開きます。
成功すれば接続へのストリームを返します。

参考：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (with-open-stream (stream (connect "www.yahoo.co.jp" 80))
    (format stream "GET / HTTP/1.0\n\n")
    (while (setq in (read-line stream nil))
      (insert in "\n")))
</description>
<seealso>open-network-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cons</title>
<type>Function</type>
<arguments>cons X Y</arguments>
<package>lisp</package>
<description>
新しいリストを返します。

主に、新しくリストを作る際に用いる関数です。これは X を car、 
Y を cdr として、コンスセルを新しく作り、この新しいコンスセルへの
ポインタを返します。 (通常はリストですが) Y が特定のあるタイプでな
くてはならないという制限はありません。

使用例：
  (cons 1 '(2))
  =&gt; (1 2)
  (cons 1 '())
  =&gt; (1)
  (cons 1 2)
  =&gt; (1 . 2)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>consp</title>
<type>Function</type>
<arguments>consp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsならt、それ以外ならnilを返します。

  (consp x) == (typep x 'cons) == (not (typep x 'atom))

注意： (consp '()) は '() == nilなのでnil。
</description>
<seealso>atom</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>constantp</title>
<type>Function</type>
<arguments>constantp OBJECT</arguments>
<package>lisp</package>
<description>
オブジェクトがconstantかどうかを返します。

  t     オブジェクトはconstant
  nil   オブジェクトはconstantでない

使用例：
  ;;; defvar/defconstantの違い
  (defvar foo 2)
  =&gt; foo
  (defconstant bar 3)
  =&gt; bar
  (constantp 'foo)
  =&gt; nil
  (constantp 'bar)
  =&gt; t
</description>
<seealso>defconstant</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>continue-popup</title>
<type>Function</type>
<arguments>continue-popup</arguments>
<package>editor</package>
<description>
popup-stringで前回表示した内容を再度表示します。
</description>
<seealso>popup-string</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-alist</title>
<type>Function</type>
<arguments>copy-alist LIST</arguments>
<package>lisp</package>
<description>
連想リストのコピーを返します。例えばこんな連想リストをコピーした場合に、
オリジナルと同じものを指している部分に下線を引いています。copy-listでは
最上位の要素そのものがオリジナルと共有しているのに対し、copy-alistは第二
階層の要素を共有しています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
copy-alist：
  '(((1 2) . #\a) ((3 4) . #\b))
     ~~~~~   ~~~   ~~~~~   ~~~

GNU Emacs Lisp Reference Manualによると、コピー元の連想リストとは独立し
て連想リストの修正を行えるようにするためとか。下の例でも示しているとおり、
copy-listでは元のリストまで変わってしまいます。

使用例：
  ;;; copy-listとcopy-alistの違いを見てみる。
  (setq a '((1 . #\a) (2 . #\b)))       =&gt; ((1 . #\a) (2 . #\b))
  (setq b (copy-list a))                =&gt; ((1 . #\a) (2 . #\b))
  (setq c (copy-alist a))               =&gt; ((1 . #\a) (2 . #\b))
  (rplacd (assoc 2 a) #\c)              =&gt; (2 . #\c)
  a                                     =&gt; ((1 . #\a) (2 . #\c))
  b                                     =&gt; ((1 . #\a) (2 . #\c))
  c                                     =&gt; ((1 . #\a) (2 . #\b))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-file</title>
<type>Function</type>
<arguments>copy-file FILE NEW-FILE &amp;key :if-exists :copy-attributes :if-access-denied</arguments>
<package>lisp</package>
<description>
ファイルをコピーします。

  FILE             : コピー元のファイル名を指定します。
  NEW-FILE         : コピー先のファイル名を指定します。
  :copy-attributes : コピーするときの属性を指定します。
                     指定できる属性はget-file-infoを参照して下さい。
  :if-exists       : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      上書きします。
        :newer          新しければ上書きします。
  :if-access-denied : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的にファイルのコピーを試みます。

使用例：
  ;;; ローカルのautoexec.batを マシン名 VENUSの /work/autoexec.batにコピーする。
  (copy-file "c:/autoexec.bat" "//VENUS/work/autoexec.bat"
             :if-exists :overwrite)
</description>
<seealso>rename-file</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-keymap</title>
<type>Function</type>
<arguments>copy-keymap MAP</arguments>
<package>editor</package>
<description>
キーマップのコピーを返します。

使用例：
  ;;; gresreg.lより
  ;;; query-replaceのキーマップをコピーして
  ;;; query-gresregのキーマップを作って、ちょっと修正する。
  (unless *query-gresreg-map*
    (setq *query-gresreg-map* (copy-keymap *query-replace-map*))
    (define-key *query-gresreg-map* #\C-g '(throw . quit)))
</description>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>copy-list</title>
<type>Function</type>
<arguments>copy-list LIST</arguments>
<package>lisp</package>
<description>
リストのコピーを返します。
コピーとオリジナルはequalですが、eqではありません。コピーとオリジナルは
同じ構造を持っており、一番上位のリストの要素は同じものを共有しています。
一方を変えると他方も変わります。オリジナルと同じものを指している部分に下
線を引いています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
使用例：
  ;;; [A] eqではないことを示してみます。
  (setq a '((1 2 3) (4 5 6)))   =&gt; ((1 2 3) (4 5 6))
  (setq b (copy-list a))        =&gt; ((1 2 3) (4 5 6))
  (eq a b)                      =&gt; nil
  (equal a b)                   =&gt; t
  ;;; [B] car同士はeqです。
  (eq (car a) (car b))          =&gt; t
  ;;; [C] caarを変えると変わるけど、carを変えても変わらない。
  (progn (setf (caar a) 7) a)   =&gt; ((7 2 3) (4 5 6))
  b                             =&gt; ((7 2 3) (4 5 6))
  (progn (setf (car a) 8) a)    =&gt; (8 (4 5 6))
  b                             =&gt; ((7 2 3) (4 5 6))
</description>
<seealso>copy-tree</seealso>
<seealso>copy-seq</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-menu-items</title>
<type>Function</type>
<arguments>copy-menu-items OLD-MENU NEW-MENU</arguments>
<package>editor</package>
<description>
old-menuの構造をnew-menuにトップレベルでコピーします。

亀井さん談：
  ちなみにバグってます。old-menuとnew-menuが同じ場合のことを何も考えていません。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-rectangle-selection-to-clipboard</title>
<type>Function</type>
<arguments>copy-rectangle-selection-to-clipboard</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をクリップボードにコピーします。
</description>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<seealso>copy-rectangle-selection</seealso>
<seealso>copy-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-rectangle-selection</title>
<type>Function</type>
<arguments>copy-rectangle-selection</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をコピーします。yankには
yank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
コピーした内容は*kill-ring*ともクリップボードとも違う領域に格納されてい
るようです。
</description>
<seealso>kill-rectangle-selection</seealso>
<seealso>copy-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-rectangle</title>
<type>Function</type>
<arguments>copy-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1とP2で指定される矩形領域をコピーします。コピーした矩形領域のyankには、
yank-rectangleを使います。
</description>
<seealso>kill-rectangle</seealso>
<seealso>copy-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>copy-region-as-kill</title>
<type>Function</type>
<arguments>copy-region-as-kill FROM TO</arguments>
<package>editor</package>
<description>
リージョンをコピーして、キルリングに追加します。[ESC w]
</description>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>copy-region-to-clipboard</title>
<type>Function</type>
<arguments>copy-region-to-clipboard FROM TO</arguments>
<package>editor</package>
<description>
指定されたリージョンをクリップボードにコピーします。

  FROM : リージョンの開始位置を指定します。
  TO   : リージョンの終了位置を指定します。
</description>
<seealso>copy-to-clipboard</seealso>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>copy-selection-to-clipboard</title>
<type>Function</type>
<arguments>copy-selection-to-clipboard</arguments>
<package>editor</package>
<description>
選択範囲をクリップボードに転送します。[C-Insert]

使用例：
  ;;; 1. いったんJISに変換して保存
  ;;; 2. [ファイル]-[開く]で文字エンコーディングを[シフトJIS]にして開く
  ;;;    （またはメモ帳などで開く？）
  ;;; 3. 選択してコピー
  (defun tojiscopy ()
    (interactive)
    (let ((ocode *kanji-expected-code*)
          (tempfile (concat (default-directory) "tempfile.txt")))
      (save-excursion
        (set-buffer-kanji-fileio-code 1)
        (write-region (point-min) (point-max) tempfile nil)
        (switch-to-buffer "*JIS*"))
      (pop-to-buffer "*JIS*")
      (setq *kanji-expected-code* 0)
      (find-file tempfile)
      (setq *kanji-expected-code* ocode)
      (selection-whole-buffer)
      (copy-selection-to-clipboard)))
</description>
<seealso>copy-to-clipboard</seealso>
<seealso></seealso>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-selection</title>
<type>Function</type>
<arguments>copy-selection</arguments>
<package>editor</package>
<description>
選択された領域をコピーして、*selection-ring*の先頭に追加します。 [F8]
追加した内容はyank-selectionで貼り付けられます。
</description>
<seealso>yank-selection</seealso>
<seealso>kill-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-seq</title>
<type>Function</type>
<arguments>copy-seq SEQUENCE</arguments>
<package>lisp</package>
<description>
SEQUENCEのコピーを作成して返します。元のSEQUENCEとはequalpだがeqではありません。

  (copy-seq x) == (subseq x 0)
</description>
<seealso>copy-list</seealso>
<seealso>copy-string</seealso>
<seealso>make-vector</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-string</title>
<type>Function</type>
<arguments>copy-string STRING</arguments>
<package>lisp</package>
<description>
STRINGのコピーを返します。

使用例：
  ;;; 単にsetqしただけでは同じオブジェクトになっている。
  (setq foo "abc")              =&gt; "abc"
  (setq bar foo)                =&gt; "abc"
  (eq foo bar)                  =&gt; t

  ;;; コピーすると別のオブジェクトになる。
  (setq bar (copy-string foo))  =&gt; "abc"
  (eq foo bar)                  =&gt; nil
</description>
<seealso>substring</seealso>
<seealso>copy-seq</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-symbol</title>
<type>Function</type>
<arguments>copy-symbol SYMBOL &amp;optional COPY-PROPS</arguments>
<package>lisp</package>
<description>
同じ名前を持つuninternedなSYMBOLのコピーを返します。
COPY-PROPSがnon-nilなら、初期定義値、プロパティリストもコピーされます。
</description>
<seealso>uninterned</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-syntax-table</title>
<type>Function</type>
<arguments>copy-syntax-table FROM-SYNTAX-TABLE TO-SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
FROM-SYNTAX-TABLE を TO-SYNTAX-TABLE へコピーします。
</description>
<seealso>make-syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-to-clipboard</title>
<type>Function</type>
<arguments>copy-to-clipboard STRING</arguments>
<package>editor</package>
<description>
指定された文字列をクリップボードにコピーします。

  STRING : クリップボードにコピーする文字列を指定します。
</description>
<seealso>get-clipboard-data</seealso>
<seealso>copy-region-to-clipboard</seealso>
<seealso>copy-selection-to-clipboard</seealso>
<seealso>copy-rectangle-selection-to-clipboard</seealso>
<seealso>kill-region-to-clipboard</seealso>
<seealso>kill-selection-to-clipboard</seealso>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<seealso>yank-to-clipboard</seealso>
<seealso>paste-from-clipboard</seealso>
<seealso>paste-rectangle-from-clipboard</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cos</title>
<type>Function</type>
<arguments>cos RADIANS</arguments>
<package>lisp</package>
<description>
余弦関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count-buffers</title>
<type>Function</type>
<arguments>count-buffers &amp;optional ALL</arguments>
<package>editor</package>
<description>
全バッファの数を返します。

  ALL : " *Completion*"や" *Minibuf0*"等の先頭が空白のバッファも数えるか？
        t       先頭が空白のバッファも数える。
        nil     先頭が空白のバッファは数えない。

使用例：
  ;;; バッファの数を数えてみる。
  (count-buffers)
  =&gt; 20
  (count-buffers t)
  =&gt; 23
</description>
<seealso>count-modified-buffers</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count-if-not</title>
<type>Function</type>
<arguments>count-if-not TEST SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
TESTを満足しないSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置
</description>
<seealso>count</seealso>
<seealso>count-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>count-if</title>
<type>Function</type>
<arguments>count-if TEST SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
TESTを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置
</description>
<seealso>count</seealso>
<seealso>count-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>count-windows</title>
<type>Function</type>
<arguments>count-windows &amp;optional MINIBUF</arguments>
<package>editor</package>
<description>
ウィンドウの数を返します。

  MINIBUF : フラグはミニバッファウィンドウを数えるかどうかです。
        t       ミニバッファを数える。
        nil     ミニバッファを数えない。
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>count-xyzzy-instance</title>
<type>Function</type>
<arguments>count-xyzzy-instance</arguments>
<package>editor</package>
<description>
現在起動中のxyzzyの数を返します。
</description>
<seealso></seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count</title>
<type>Function</type>
<arguments>count ITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :key</arguments>
<package>lisp</package>
<description>
ITEMとのテストを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  :from-end : 他の関数との互換性のために用意されたもので、結果に影響しません。
  :test     : テストを行う2項演算子
  :start    : テストする開始位置
  :end      : テストの終了位置
</description>
<seealso>count-if</seealso>
<seealso>count-if-not</seealso>
<seealso>si:*tree-count</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>create-archive</title>
<type>Function</type>
<arguments>create-archive ARCHIVE-FILE FILES BASE-DIRECTORY</arguments>
<package>editor</package>
<description>
アーカイブを作成します。

  ARCHIVE-FILE   : 作成/追加する書庫ファイル名を指定します。指定したファ
                   イルが存在すれば追加、なければ新規作成します。書庫フ
                   ァイルを作成するディレクトリを指定する場合は、フルパ
                   スで指定します。
  FILES          : アーカイブするファイルのリストを指定します。フルパス
                   で指定する必要があります。
  BASE-DIRECTORY : 基準となるディレクトリを指定します。

使用例：
  ;;; foo.lzh に c:/tmp/a.c, c:/tmp/b.c を追加します。
  (create-archive "foo.lzh"
                  '("c:/tmp/a.c" "c:/tmp/b.c")
                  "c:/tmp")
</description>
<seealso>extract-archive</seealso>
<seealso>delete-file-in-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-directory</title>
<type>Function</type>
<arguments>create-directory DIRNAME &amp;key :if-exists</arguments>
<package>lisp</package>
<description>
ディレクトリを作成します。

  DIRNAME    : 作成対象のディレクトリ
  :if-exists : ディレクトリが存在していたときの動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、t を返します。

戻り値は作成できたかどうかによります。

  t   ディレクトリの作成に成功
  nil ディレクトリの作成に失敗

使用例：
  (create-directory "C:/xyzzy/testdir")
  =&gt; t
</description>
<seealso>delete-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-file-buffer</title>
<type>Function</type>
<arguments>create-file-buffer FILENAME</arguments>
<package>editor</package>
<description>
ファイルを参照するバッファを作成して返します。
</description>
<seealso>get-file-buffer</seealso>
<seealso>create-new-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-menu</title>
<type>Function</type>
<arguments>create-menu &amp;optional TAG</arguments>
<package>editor</package>
<description>
新たに作成した空のメニューを返します。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、以下の関数で登録必要があります。
中身を動的に作る必要が無ければ、 define-menu を使用した方が良いです。

  add-menu-item         : 項目を追加します。
  add-menu-separator    : セパレータを追加します。
  add-popup-menu        : ポップアップメニューを追加します。
  insert-menu-item      : 項目を挿入します。
  insert-menu-separator : セパレータを挿入します。
  insert-popup-menu     : ポップアップメニューを挿入します。

作成したメニューは以下の関数で使います。

  set-menu       : 標準のメニューとして設定します。
  use-local-menu : バッファにローカルなメニューとして設定します。
</description>
<seealso>create-popup-menu</seealso>
<seealso>define-menu</seealso>
<seealso>set-menu</seealso>
<seealso>use-local-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-new-buffer</title>
<type>Function</type>
<arguments>create-new-buffer NAME</arguments>
<package>editor</package>
<description>
名前がNAMEのバッファを作成して返します。もしその名前のバッファが存在すれ
ば、name&lt;1&gt;, name&lt;2&gt;...と番号を付けた名前になります。

使用例：
  (create-new-buffer "test")
  =&gt; #&lt;buffer: test&gt;
  (create-new-buffer "test")
  =&gt; #&lt;buffer: test&lt;2&gt;&gt;
</description>
<seealso>create-file-buffer</seealso>
<seealso>get-buffer-create</seealso>
<seealso>*create-buffer-hook*</seealso>
<seealso>find-buffer</seealso>
<seealso>バッファの内部構造</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-popup-menu</title>
<type>Function</type>
<arguments>create-popup-menu &amp;optional TAG</arguments>
<package>editor</package>
<description>
新たに作成したポップアップメニューを返します。ポップアップメニューとして
使えることを除けば、create-menuで作成されたメニューを同じです。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、create-menuと同じように登録する必要があります。
中身を動的に作る必要が無ければ、define-popup-menuを使用した方が良いです。

作成したポップアップメニューは以下の関数で使います。

  insert-popup-menu  : 既存のメニューにポップアップメニューを追加します。
  track-popup-menu   : ポップアップメニューをその場で表示します。
</description>
<seealso>define-popup-menu</seealso>
<seealso>track-popup-menu</seealso>
<seealso>create-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-shortcut</title>
<type>Function</type>
<arguments>create-shortcut SRC DEST &amp;rest REST</arguments>
<package>editor</package>
<description>
ショートカットを作成します。

  SRC  : ショートカットが指すパスを指定します。
  DEST : ショートカットを作成するパスを指定します。
  REST : 作成するショートカットへのパラメータを与えることが出来ます。
     :description        ドラッグオーバの時やプロパティ表示時に見られる説明
     :arguments          コマンドライン引数
     :working-directory  作業ディレクトリ
     :show               ウィンドウの状態の指定
                            :show      標準のサイズで起動
                            :maximize  最大化状態で起動
                            :minimize  最小化状態で起動
     :appid              アプリケーションID
                         ショートカットのアプリケーションIDを指定します。
                         Windows 7以降ではアプリケーションIDを元に
                         タスクバー上でアイコンがグループ化されます。
                         Vista 以前ではこの引数は単純に無視されます。

使用例：
  ;;; スタートメニューにショートカットを作成する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :start-menu))
  =&gt; t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :start-menu)))
  =&gt; t

  ;;; 送るメニューにxyzzyを登録する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :send-to))
  =&gt; t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :send-to)))
  =&gt; t

  ;;; xyzzyと同じアプリケーションIDを指定してデスクトップにxyzzycliを登録する。
  ;;; このショートカットをタスクバーに登録することで、ジャンプリストが利用
  ;;; できるようになる。
  (create-shortcut (merge-pathnames "xyzzycli.exe" (si:system-root))
                   (get-special-folder-location :desktop)
                   :appid (si:*app-user-model-id))
  =&gt; t
  (delete-file (merge-pathnames "xyzzycli.exe.lnk" (get-special-folder-location :desktop)))
  =&gt; t

補足：
  :appid引数は xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>resolve-shortcut</seealso>
<seealso>si:*app-user-model-id</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>create-tab-bar</title>
<type>Function</type>
<arguments>create-tab-bar BAR CALLBACK</arguments>
<package>editor</package>
<description>
タブバーの識別子BARと、タブが選択されたとき実行するコールバック関数
CALLBACKを指定して、タブバーを作成します。CALLBACKは、各タブの作成時に設
定したシンボルが渡されます。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  =&gt; t  
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  =&gt; t
</description>
<seealso>tab-bar-add-item</seealso>
<seealso>tab-bar-list-items</seealso>
<seealso>tab-bar-modify-item</seealso>
<seealso>tab-bar-select-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-tool-bar</title>
<type>Function</type>
<arguments>create-tool-bar NAME BITMAP ITEMS</arguments>
<package>editor</package>
<description>
ツールバーNAMEを作成します。ツールバーに表示するビットマップファイルのフ
ルパスBITMAPと、ツールバーの項目ITEMSを指定します。ITEMSは以下の形式で記
述します。項目の替わりに:sepを指定するとセパレータを表示できます。

形式：
  ((ツールチップ1 アイコンの番号1 実行する関数1 状態制御用1)
   (ツールチップ2 アイコンの番号2 実行する関数2 状態制御用2)
    ...
   (ツールチップN アイコンの番号N 実行する関数N 状態制御用N))

補足：
  アイコンの番号：
        16x16の領域をひとつのアイコンとみなして、ビットマップファイルの
        左から0ベースの番号で指定します。
  状態制御用：
        ボタンの状態が何に依存して変更するかを指定します。
        :modified              編集されていたら 
        :selection             行モード選択、文字モード選択をしていたら
        :modify-selection      編集可能なバッファで行モード選択
                               文字モード選択をしていたら
        :rectangle             矩形選択していたら
        :modify-rectangle      編集可能なバッファで矩形選択をしていたら
        :any-selection         選択していたら
        :modify-any-selection  編集可能なバッファで選択していたら
        :clipboard             編集可能なバッファでクリップボードに値が入っていたら
        :undo                  UNDOできる状態なら
        :redo                  リドゥできる状態なら
        関数 (function)        関数が返す値による
            :disable           ボタンを押せない状態 
            :check             ボタンを押してへこんだ状態 
            上記以外           普通の押せる状態 
        上記以外               指定しないとの同じで無条件に押せる状態 
        ※OHKUBO Hiroshiさんのサイトより
          http://ohkubo.s53.xrea.com/xyzzy/memo.html

使用例：
(create-tool-bar 'abc-tool-bar
 (merge-pathnames "toolbar.bmp" (etc-path))
 '(("line-number" 0 toggle-line-number)
   ("vscroll-bar" 1 toggle-vscroll-bar)
   ("mode-line" 2 toggle-mode-line)
   :sep
   ("function-bar" 3 toggle-function-bar)
   ("fold-line" 4 toggle-fold-line)
   ("read-only" 5 toggle-read-only)))
</description>
<seealso>define-command-bar</seealso>
<seealso>create-tab-bar</seealso>
<seealso></seealso>
<link>lisp/cmdbar.l</link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-column</title>
<type>Function</type>
<arguments>current-column</arguments>
<package>editor</package>
<description>
現在の桁位置を返します。
</description>
<seealso>current-virtual-column</seealso>
<seealso>goto-column</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-line-number</title>
<type>Function</type>
<arguments>current-line-number</arguments>
<package>editor</package>
<description>
現在の物理行の行番号を返します。
</description>
<seealso>current-virtual-line-number</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-menu</title>
<type>Function</type>
<arguments>current-menu &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
現在表示されているメニューを返します。use-local-menuを使用してい
るバッファは*app-menu*とは違うものが取得されます。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-virtual-column</title>
<type>Function</type>
<arguments>current-virtual-column</arguments>
<package>editor</package>
<description>
カーソル位置の表示桁を返します。
※実際の表示が表示行／物理行には依存しません。
(current-virtual-column)
</description>
<seealso>current-column</seealso>
<seealso>goto-virtual-column</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-virtual-line-number</title>
<type>Function</type>
<arguments>current-virtual-line-number</arguments>
<package>editor</package>
<description>
現在のポイントが表示行で何行目かを返します。
</description>
<seealso>current-line-number</seealso>
<seealso>goto-virtual-line</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-window-configuration</title>
<type>Function</type>
<arguments>current-window-configuration</arguments>
<package>editor</package>
<description>
現在のウィンドウの状態を返します。
ここでいうウィンドウの状態とは、画面の分割状態、表示されているバッファを
指します。ウィンドウの状態はset-window-configurationで設定することが出来
ます。

使用例：
  ;;; 画面の状態を元に戻す。
  (split-window)
  =&gt; t
  (setq winconf (current-window-configuration))
  =&gt; (window-configuration #&lt;window&gt; ......  
  (delete-other-windows)
  =&gt; t
  (set-window-configuration winconf)
</description>
<seealso>set-window-configuration</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cwd</title>
<type>Function</type>
<arguments>cwd</arguments>
<package>editor</package>
<description>
xyzzy.exeの作業ディレクトリを返します。プロパティの作業フォルダ(S)の
ディレクトリが返されるのだと思います。

使用例： 
  (cwd)
  =&gt;"D:/WINNT/"
</description>
<seealso>chdir</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>chdir</title>
<type>Function</type>
<arguments>chdir &amp;optional DIRNAME</arguments>
<package>editor</package>
<description>
xyzzy.exeの作業ディレクトリを移動します。
移動した場合は t を、移動しなかった場合は nil を返します。

  DIRNAME : 移動先のディレクトリを絶対パスまたは相対パスで指定します。
            省略時は user-homedir-pathname に移動します。

使用例： 
  (chdir (get-windows-directory))
  =&gt; t
  (chdir (get-windows-directory))
  =&gt; nil
  (chdir "system32")
  =&gt; t
  (chdir "..")
  =&gt; t
  (chdir "c:/dir/not/found")
  =&gt; c:/dir/not/found
  =&gt; 指定されたパスが見つかりません。 

補足：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>cwd</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dabbrev-popup</title>
<type>Function</type>
<arguments>dabbrev-popup</arguments>
<package>editor</package>
<description>
dabbrev-expandのポップアップリスト版です。[C-x \]
</description>
<seealso>dabbrev-expand</seealso>
<seealso>popup-list</seealso>
<link></link>
<section>テキスト</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>dde-execute</title>
<type>Function</type>
<arguments>dde-execute CHAN DATA</arguments>
<package>editor</package>
<description>
DDE EXECUTE を実行します。引数 CHAN は DDE チャンネル、DATA は相手にくら
わすコマンド文字列です。コマンドの内容は、相手のマニュアルに従ってくださ
い。dde-execute は t を返します。

  CHAN : チャンネルを指定します。
  DATA : データを指定します。

なお、DDE 関数では以下の例外が発生する可能性があります。必要であれば例外
を処理してください。

  dde-timeout        タイムアウトしました。
  dde-busy           DDE サーバが BUSY です。
  dde-low-memory     サーバ先行状態です
  dde-no-conv        DDE 対話が確立できません
  dde-not-processed  トランザクションの実行に失敗しました
  dde-server-died    サーバーが終了しました
  storage-error      メモリがありません
  dde-error          よくわかんないけど、とにかくエラーです
</description>
<seealso>dde-poke</seealso>
<seealso>dde-request</seealso>
<seealso>dde-terminate</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-initiate</title>
<type>Function</type>
<arguments>dde-initiate SERVICE TOPIC</arguments>
<package>editor</package>
<description>
DDE 対話を確立します。引数 SERVICE はサービス名、 TOPIC はトピックで、
それぞれ文字列型です。なにを指定するかは通信する相手のマニュアルを
参照してください。正常に終了した場合、DDE チャンネルを返します。
以降の通信ではこのDDE チャンネルを使用してください。
</description>
<seealso>dde-execute</seealso>
<seealso>dde-poke</seealso>
<seealso>dde-terminate</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-poke</title>
<type>Function</type>
<arguments>dde-poke CHAN ITEM DATA</arguments>
<package>editor</package>
<description>
DDE POKE を実行します。

  CHAN : チャンネルを指定します。
  ITEM : （詳細不明）
  DATA : データを文字列で指定します。

引数 CHAN は DDE チャンネル、DATA は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。dde-poke は t を返します。
</description>
<seealso>dde-execute</seealso>
<seealso>dde-request</seealso>
<seealso>dde-terminate</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-request</title>
<type>Function</type>
<arguments>dde-request CHAN DATA RESULT-TYPE</arguments>
<package>editor</package>
<description>
DDE REQUEST を実行します。

  CHAN        : チャンネルを指定します。
  DATA        : データを指定します。
  RESULT-TYPE : 戻り値の型を指定します。

引数 CHAN は DDE チャンネル、DATA は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。戻り値は DDE の相手が返したもの
を返しますが、RESULT-TYPE の指定によってデータの解釈を以下のようにおこな
います。

  :text   : 通常の文字列を返します。
  :binary : 漢字などを無視して返ってきたデータをそのまま文字列で返します。
  :int8
  :int16
  :int32  : データをそれぞれ 8, 16, 32 ビット整数の配列とみなして整数のリ
            ストで返します。配列の要素が 1 のときは整数値を返します。

戻り値型の指定は、もじらの DDE で遊ぼうと思って作っただけなので、通常は
指定しなくて構いません。
</description>
<seealso>dde-execute</seealso>
<seealso>dde-poke</seealso>
<seealso>dde-terminate</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-terminate</title>
<type>Function</type>
<arguments>dde-terminate CHAN</arguments>
<package>editor</package>
<description>
DDE 対話を終了します。引数 CHAN は DDE チャンネルです。正常に終了した場
合は t、すでに対話が終了していた場合は nil を返します。

  CHAN : チャンネルを指定します。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>decf</title>
<type>Macro</type>
<arguments>decf PLACE &amp;optional (DELTA 1)</arguments>
<package>lisp</package>
<description>
変数をデクリメントする

使用例：
  ;;; 変数xの値をデクリメントする。
  (setq x 1)    =&gt; 1
  (decf x)      =&gt; 0
  x             =&gt; 0
</description>
<seealso>incf</seealso>
<section>数値</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>declare</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
Common Lispの機能で、「変数を動的に bind しろ」と宣言する事です。
Emacs Lispではそもそも動的にしか bind できないので存在しません。

  (declare (special 変数名))

違いを図示します。

  ;;; 大域変数 x          ┏大域変数━━━━━━┓    Common Lisp/xyzzy lisp：
  (setq x 0)              ┃x │0             ←╂─┐大域変数のxを参照する。
                          ┠─┴────────┨  │(+ 0 12)となる
  ;;; 関数 bar            ┃                    ┃  │
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃  │    Emacs Lisp：
    (foo 12))             ┃┃x │34        ←╂╂─│─┐呼び出しスタックの
                          ┃┠─┴──────┨┃  │  │深いところのxを参照する。
  ;;; 関数 foo            ┃┃                ┃┃  │  │(+ 34 12)となる。
  (defun foo (y)          ┃┃┏(foo 12)━━┓┃┃  │  │
     (+ x y))    ... ※   ┃┃┃y │12      ┃┃┃  │  │
                          ┃┃┠─┴────┨┃┃  │  │
                          ┃┃┃(+ x y)   ─╂╂╂─┴─┘

とあったときに(bar 34)と呼び出すと、古いLispでは(Emacs Lispを含む）
※の時点で x = 34, y = 12と見えます。ところが、Common Lispやxyzzy lispでは
※の時点で x = 0,  y = 12と見えます。

昔Lispはインタープリタだったので、動的バインディングでもよかったんだけど、
コンパイラを作る時に、効率上なにかと問題があってCommon Lisp
では、静的バインディングに変更になりました。

でも、そうすると、古いコードを移植するのが大変になるので、

                          ┏大域変数━━━━━━┓    
                          ┃x │0               ┃
                          ┠─┴────────┨
  ;;; 関数 bar            ┃                    ┃    
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃    Common Lisp/xyzzy lisp：
    (declare (special x)) ┃┃x │34        ←╂╂─┐大域変数ではなく
    (foo 12))             ┃┠─┴──────┨┃  │スタック上のxを参照する。
                          ┃┃                ┃┃  │(+ 34 12)となる。
                          ┃┃┏(foo 12)━━┓┃┃  │
                          ┃┃┃y │12      ┃┃┃  │
                          ┃┃┠─┴────┨┃┃  │
                          ┃┃┃(+ x y)   ─╂╂╂─┘

と書いてやると古いLisp(Emacs Lisp)のように動くという訳。
</description>
<seealso>special</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>decode-escape-sequence</title>
<type>Function</type>
<arguments>decode-escape-sequence STRING REGEXPP</arguments>
<package>editor</package>
<description>
エスケープシーケンスをデコードします。

  STRING ：デコードするエスケープシーケンス
  REGEXPP：STRING が正規表現か否かを指定します。

使用できるエスケープシーケンスは以下の通りです。
  \t     タブ
  \n     改行
  \r     復帰
  \f     改頁
  \v     垂直タブ
  \xNN   2桁までの16進数
  \XNNNN 4桁までの16進数

使用例：
  ;;; [\thoge]という6文字をデコードして5文字にする。
  "\\thoge"
  =&gt; "\\thoge"
  (decode-escape-sequence "\\thoge" nil)
  =&gt; "  hoge"
  (length "\\thoge")
  =&gt; 6
  (length (decode-escape-sequence "\\thoge" nil))
  =&gt; 5
</description>
<link>[xyzzy:04201]</link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>decode-mime-header</title>
<type>Function</type>
<arguments>decode-mime-header</arguments>
<package>editor</package>
<description>
現在行から下にRFC822ヘッダを探してMIMEデコードします。
</description>
<seealso></seealso>
<section>その他</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>decode-universal-time</title>
<type>Function</type>
<arguments>decode-universal-time UNIVERSAL-TIME &amp;optional TIME-ZONE</arguments>
<package>lisp</package>
<description>
ユニバーサルタイム形式の時間から日時に変換します。

  UNIVERSAL-TIME : ユニバーサルタイム形式の時間を指定します。
  TIME-ZONE      : タイムゾーンを指定します。

変換された日時は多値で返されます。multiple-value-***系のマクロで受け取り
ましょう。日時からユニバーサルタイム形式の時間に変換するには、
encode-universal-timeを使用します。

使用例：
  ;;; .xyzzyの最終更新日(2003/3/30 9:34:25)を取得する。
  (multiple-value-list
   (decode-universal-time
    (file-write-time ".xyzzy")))
  =&gt; (25 34 9 30 3 2003 6 nil -9)

参照：
  timestmp.l
</description>
<seealso>format-date-string</seealso>
<seealso>encode-universal-time</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>default-directory</title>
<type>Function</type>
<arguments>default-directory &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが作業しているディレクトリを返します。

  BUFFER : バッファを指定します。
           指定がなければカレントバッファになります。

そのバッファでfind-file するときに最初に表示されるディレクトリのことです。
このディレクトリは M-x: cd や set-default-directoryで変更することができ
ます。

使用例：
  ;;; デフォルトディレクトリを移動してみる。
  (default-directory)
  =&gt; "C:/applications/xyzzy/site-lisp/"
  (cd "../..")
  =&gt; t
  (default-directory)
  =&gt; "C:/applications/"
</description>
<seealso>set-default-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>default-value</title>
<type>Function</type>
<arguments>default-value SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルのデフォルトの値を返します。
シンボルがバッファローカルでないならば、symbol-valueと同じ値を返します。
シンボルがバッファローカルの時にデフォルトの値を持たない場合には、エラー
になります。デフォルトの値はsetq-defaultで指定します。

使用例：
  ;;; シンボルがデフォルトの値を持たない場合
  (make-local-variable 'foo)    =&gt; t
  (setq foo 123)                =&gt; 123
  (default-value 'foo)          =&gt; 変数が定義されていません: foo

  ;;; バッファローカルなシンボルの場合
  (defvar-local bar 234)        =&gt; bar
  (setq bar 345)                =&gt; 345
  (default-value 'bar)          =&gt; 234
</description>
<seealso>symbol-value</seealso>
<seealso>setq-default</seealso>
<link></link>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>defconstant</title>
<type>Macro</type>
<arguments>defconstant NAME VALUE &amp;optional DOC</arguments>
<package>lisp</package>
<description>
定数を宣言します。

使用例：
  ;;; encoding.lの中より
  (defconstant *eol-crlf* 1)
  =&gt; *eol-crlf*
</description>
<seealso>constantp</seealso>
<seealso>defvar</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>define-abbrev-table</title>
<type>Function</type>
<arguments>define-abbrev-table TABNAME &amp;optional DEFS</arguments>
<package>editor</package>
<description>
abbrev-tableを定義します。

  TABNAME : abbrev-tableの名前にあたるシンボル
  DEFS    : 静的略称展開の定義のリスト

また、TABNAMEが*abbrev-table-name-list*に登録され、編集やファイル出力と
いった操作が可能になります。

使用例:
  ;;; c-mode.lの定義
 (defvar *c-mode-abbrev-table* nil)
 (unless *c-mode-abbrev-table*
   (define-abbrev-table '*c-mode-abbrev-table*))
</description>
<seealso>*abbrev-table-name-list*</seealso>
<seealso>*local-abbrev-table*</seealso>
<seealso>*global-abbrev-table*</seealso>
<link></link>
<section>テキスト</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>define-command-bar</title>
<type>Function</type>
<arguments>define-command-bar SYM NAME &amp;optional EDGE X Y W</arguments>
<package>editor</package>
<description>
※以下は私見です。

ツールバーやタブバーを総称してツールバーと呼ぶようです。作成するときやツ
ールバーのリストを操作するときは全てtool-bar系の関数を使います。単に表示
するだけならば、show-tool-barを使えば可能です。

ただし、メニューの[表示]-[ツールバー]の一覧に追加する場合には、
command-bar系の関数を使います。define-command-barで登録したツールバーは、
[表示]-[ツールバー]から表示を制御することが可能です。予め、
define-command-barで定義したSYMに対応する、ツールバー・タブバーを作って
おく必要があります。

以下はタブバーを操作する場合の例です。

  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))

  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))

また、ユーザのツールバーなどを作成する場合には、delete-command-barで削除
する手順を考慮することをおすすめします。コマンドバーは（シンボル名だけ）
ヒストリ変数に格納されます。その実体（ツールバーやタブバー）がなくとも、
ずっと[表示]-[ツールバー]に残ってしまいます。そのようなときは、手動で削
除する必要があります。

似たような話で、コマンドバーには関数名だけを指定しておいて、後から本体を
読み込みたい場合には、autoloadで出来ます。本体の初期化に時間が掛かる場合
には、このように分離するほうが良いと思います。

使用例：
  ------------------------------------------------
  ;;; .xyzzy
  (progn
    (define-command-bar 'a-bar "a bar")
    (autoload 'a-bar "a-bar.l"))
  ------------------------------------------------

  ------------------------------------------------
  ;;; a-bar.l
  (progn
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  ------------------------------------------------
</description>
<seealso>delete-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>define-history-variable</title>
<type>Macro</type>
<arguments>define-history-variable NAME &amp;optional (INITIAL-VALUE nil sv) DOC</arguments>
<package>editor</package>
<description>
ヒストリ変数を定義します。

  NAME          : ヒストリ変数名を指定します。
  INITIAL-VALUE : 初期値を設定します。
  DOC           : 変数の説明を指定します。

ヒストリ変数とは、次回のxyzzyの立ち上げまで値を保持してくれる(lispを書く
人には)便利な変数です。ヒストリ変数がないと各マクロごとに独自の保存方法
をとらないといけませんが、ヒストリ変数のおかげで宣言するだけで変数の状態
を保存することが可能な優れものです。

ただし、一旦作成したヒストリ変数はいつまでも残ってしまうので、
不要になったらed::*history-variable-list*を確認した上で、
unregister-history-variableで削除して下さい。

使用例：
  ;;; grepd.lより
  (define-history-variable *grep-directory-history* nil)
  (define-history-variable *grep-file-history* nil)
</description>
<seealso>register-history-variable</seealso>
<seealso>unregister-history-variable</seealso>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>define-key</title>
<type>Function</type>
<arguments>define-key KEYMAP KEY COMMAND</arguments>
<package>editor</package>
<description>
キーマップのキーにコマンドを割り当てます。

  KEYMAP  : キーマップ
  KEY     : 登録するキー
  COMMAND : 実行するコマンド

使用例：
  ;;; Ctrl-X fのキー割り当てを変える
  (define-key ctl-x-map #\f 'my-find-file)
  =&gt; t 
  ;;; Esc-f のキー割り当てを変える
  (define-key esc-map #\f 'my-find-file)
  =&gt; t
  ;;; Ctrl-C aのキー割り当てを変える
  (define-key spec-map #\a 'my-find-file)
  =&gt; t
</description>
<seealso>undefine-key</seealso>
<seealso>global-set-key</seealso>
<seealso>local-set-key</seealso>
<seealso>substitute-key-definition</seealso>
<seealso>make-keymap</seealso>
<seealso>キー表現使用可能文字</seealso>
<seealso>各種言語キーマップ</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>define-menu</title>
<type>Macro</type>
<arguments>define-menu &amp;body BODY</arguments>
<package>editor</package>
<description>
固定的なメニューを定義します。
定義方法は define-popup-menu を参照して下さい。動的にメニューを生成した場
合には create-menu を参照して下さい。 define-menu で生成したメニューも
add-menu-item や insert-menu-item などで項目を追加することも可能です。
</description>
<seealso>create-menu</seealso>
<seealso>add-menu-item</seealso>
<seealso>insert-menu-item</seealso>
<seealso>add-menu-separator</seealso>
<seealso>insert-menu-separator</seealso>
<seealso>copy-menu-items</seealso>
<seealso>delete-menu</seealso>
<seealso>get-menu</seealso>
<seealso>set-menu</seealso>
<seealso>use-local-menu</seealso>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>menu.l</file>
</chapter>

<chapter>
<title>define-popup-menu</title>
<type>Macro</type>
<arguments>define-popup-menu &amp;body BODY</arguments>
<package>editor</package>
<description>
固定的なポップアップメニューを定義します。

  BODY : メニューの定義を記述します。

BODYをインチキなBNFで書くと以下の様になります。

  POPUP-DEF : {MENU-ITEM}*

  MENU-ITEM : :sep
            : (:sep [TAG])
            | (:separator [TAG])
            | (:popup tag name {POPUP-DEF}*)
            | (:item tag name [COMMAND [INIT]])

  TAG       : メニュー項目を識別する任意のオブジェクトです。
              タグ同士はeqで比較されます

  COMMAND   : メニュー項目が選択されたときに実行されるコマンドです。

  INIT      : メニューが開く直前に評価され、返される値によってメニューの
              状態が設定されます。任意のS式が指定できますが、あまり無茶
              なことはしないでください。式の値として意味のある値には以下
              のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示
        :undo         undo不可能であれば灰色表示
        :redo         redo不可能であれば灰色表示
        :selection    カレントバッファのテキストが未選択であるか矩形選択
                      であれば灰色表示
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外
                      の選択であれば灰色表示
        :clipboard    クリップボードが空であれば灰色表示
        :check        チェック
        :disable      灰色表示
        その他        使用可能

使用例：
  ;;; niftylog.l
  (define-popup-menu
    (:item nil "メッセージを読んだことにする(&amp;R)"
     'log-read-article)
    (:item nil "メッセージを読んでないことにする(&amp;N)"
     'log-unread-article)
    (:item nil "スレッドを読んだことにする(&amp;T)"
     'log-read-thread)
    (:item nil "スレッドを読んでないことにする(&amp;H)"
     'log-unread-thread)
    (:item nil "ニュースグループを読んだことにする(&amp;G)")
    (:item nil "ニュースグループを読んでないことにする(&amp;P)"))
  =&gt; #&lt;menu 48698340&gt;
</description>
<seealso>create-popup-menu</seealso>
<seealso>track-popup-menu</seealso>
<seealso>add-popup-menu</seealso>
<seealso>insert-popup-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>menu.l</file>
</chapter>

<chapter>
<title>defmacro</title>
<type>Macro</type>
<arguments>defmacro NAME (&amp;rest LAMBDA-LIST) &amp;body BODY</arguments>
<package>lisp</package>
<description>
マクロを定義します。

使用例：
  ;;; cadrをマクロで定義し直した場合
  (defmacro cadr (x)
    (list 'car (list 'cdr x)))
  =&gt; cadr
  (macroexpand '(cadr y))
  =&gt; (car (cdr y))

参考：
  --- 亀井さんの説明 [xyzzy:03975] ---
  
  マクロは 2 回評価される関数みたいなものと思っていれば
  間違いないでしょう(ただし 1 回目の評価のときには引数の
  評価はされない)。ごく簡単な例をあげると、
  
    (defmacro foo ()
      '(+ 1 2))
  
  このように定義して (foo) を評価すると、1 回目の評価で
  (+ 1 2) が返り、それをさらに評価して 3 が返る、となり
  ます。引数がある場合も同様に、
  
    (defmacro bar (n)
      (list '+ 1 n))
  
    (bar 3)
    -&gt; (+ 1 3)
    =&gt; 4
  
  となります。
  
  | (M (any1) (any2) (any3)) と呼び出すと、
  |     (progn
  |       (m-setup)
  |       (any1)
  |       (any2)
  |       (any3)
  |       (m-cleanup))
  | と呼ばれるのと同じよう動作するものはどうしたら良いですか？
  
  この場合、引数が 3 つなので、こうなります。
  
    (defmacro M (a b c)
      (list 'progn '(m-setup) a b c '(m-cleanup)))
  
    (M (any1) (any2) (any3))
    -&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    =&gt; ?
  
  ふつ〜、引数は何個でもありだろうってなときは、通常の関
  数と同様に &amp;rest で受けてやればいいわけですね。
  
    (defmacro M2 (&amp;rest args)
      (append '(progn) '((m-setup)) args '((m-cleanup))))
  
    (M2 (any1) (any2) (any3))
    -&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    =&gt; ?
  
  ちなみに、1 回目がどのように評価されているか(マクロの
  展開)を見るには macroexpand を使います。
  
    (macroexpand '(M2 (any1) (any2) (any3)))
    =&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
  
  複雑なマクロ定義だと、list やら append やら cons やら 
  quote やらをごちゃごちゃ書くのがめんどくせ〜、というわ
  けでテンプレートを使うことができます。詳しい説明は面倒
  なのでしませんが(^^; 上の例をテンプレートを使って書く
  とこのようになります。
  
    (defmacro M (a b c)
      `(progn
         (m-setup)
         ,a ,b ,c
         (m-cleanup)))
  
    (defmacro M2 (&amp;rest args)
      `(progn
         (m-setup)
         ,@args
         (m-cleanup)))
</description>
<seealso>macroexpand</seealso>
<seealso>``'(backquote)</seealso>
<section>マクロ</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>defpackage</title>
<type>Macro</type>
<arguments>defpackage PACKAGE-NAME &amp;rest OPTIONS</arguments>
<package>lisp</package>
<description>
新しくパッケージを作ります。

  :nicknames              パッケージの別名 (複数指定可能)
  :documentation          パッケージのドキュメント (docstring)
  :use                    useするパッケージのリスト
  :shadow                 shadowするシンボルのリスト
  :shadowing-import-from  指定したパッケージからshadowing-importするシンボルのリスト
  :import-from            指定したパッケージからimportするシンボルのリスト
  :export                 exportするシンボルのリスト
  :intern                 internするシンボルのリスト
  :internal-size          内部シンボルのハッシュサイズ
  :external-size          外部シンボルのハッシュサイズ

:internal-size 及び :external-size の大きさは、だいたい登録するシンボル
数の1/3ぐらいの値でいいでしょう。この値が足らないからといって、新しいシ
ンボルが登録できない訳ではないので、たいして気にする必要はないでしょう。
ハッシューがチェーンされて、検索(intern時のみ）がちょっと遅くなるだけで
す。こだわる方は素数を選ぶでしょう。

使用例：

  ;;; henmiというパッケージを作る。
  ;;; lisp, editorをuseしています。
  (defpackage "henmi"
     (:use "lisp" "editor")
     (:documentation "henmi's package")
     (:internal-size 200)
     (:external-size 10))
  =&gt; #&lt;package: henmi&gt;

  (documentation (find-package "henmi") t)
  =&gt; "henmi's package"

互換性:
  :internal-size, :external-size はCommon Lispにはない。

補足：
  :documentation引数は xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>make-package</seealso>
<seealso>find-package</seealso>
<seealso>use-package</seealso>
<seealso>delete-package</seealso>
<seealso>in-package</seealso>
<seealso>package-name</seealso>
<seealso>package-nicknames</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>defstruct</title>
<type>Macro</type>
<arguments>defstruct NAME-AND-OPTIONS &amp;rest REST</arguments>
<package>lisp</package>
<description>
構造体を定義します。C言語のstruct文に相当します。
オプションとして以下のものを指定できます。
以下、xxxx の部分には構造体名が入ります。

  :conc-name         通常、xxxx-スロット名 という名前を持つ関数で変数に
                     アクセスしますが、この名前を変更します。xxxx- 
                     の部分に相当する名前を指定します。
  :constructor       指定したコンストラクタを生成します。
                     複数の :constructor 宣言することができます。 引数には
                       コンストラクタ名 (変数名1 変数名2 ... 変数名n)
                     の様に指定します。&amp;key や &amp;optionalを使用したり、
                     スロットのデフォルト値とは異なるデフォルト値を指定できま
                     す。
                     これ以上の詳細は不明です。
  :copier            コピー関数名を指定したものに変更します。異なる動作をする
                     関数を指定できるわけではありません。
                     コピー関数は、新しい構造体オブジェクトを作ってスロットを
                     コピーします。新旧の構造体で各スロットは、同じオブジェク
                     トを共有します。
  :predicate         指定された構造体であるか否かを調べる関数名を指定します。
                     この名前を持つ述語をシステムが生成します。
                     デフォルトは、 xxxx-p です。
  :include           他の構造体名を指定することで、構造体を継承します。
                     継承した構造体にある変数の宣言が、この構造体でも宣言され
                     ているものとして扱われます。
                     これ以上の詳細は不明です。
  :print-function    オブジェクトを print する時に使われる関数を指定します。
                     format関数の ~A などでオブジェクトをプリントする時に呼び出
                     される関数が変わります。指定する関数は3つの引数をとり、
                     順にオブジェクト、ストリーム、（詳細不明）をとります。
                     第3引数は、pretty printに関する値が来ます。
                     :print-function が指定されない場合、 #S 構文でプリントさ
                     れます。
  :type              （詳細不明）
  :named             （詳細不明）
  :initial-offset    （詳細不明）

引数:
  NAME-AND-OPTIONS   オプションを指定しないときは構造体名、オプションを指定する
                     ときは、
                       (構造体名 (オプション名1 値1) (オプション名2 値2) ... )
                     の様に指定します。
  REST               構造体のスロットを指定します。スロット名のみを書くか、
                       (スロット名 デフォルト値 :type タイプ名 :read-only フラグ) 
                     の様に書いてひとつのスロットを定義します。 
                     :type と :read-only は、逆順にしても片方のみでも構いません。
                     リスト形式で書いた場合、後ろから順に省略できます。
                     タイプ名は、この構造体のオブジェクトであるかどうかを調べる
                     述語の生成に使うことができますが、xyzzy では使われていない
                     ようです。

特にオプション指定しないと make-xxxx, copy-xxxx, xxxx-p, xxxx-変数名 という関数
が作られるようです。 

  make-xxxx     デフォルトのコンストラクタ
  copy-xxxx     デフォルトのコピー関数
  xxxx-p        指定された構造体であるか否かを調べる関数
  xxxx-変数名   変数へのアクセス関数

定義：
  ;;; struct.lの定義
  (defmacro defstruct (name-and-options &amp;rest rest)
    (eval-when (:compile-toplevel :load-toplevel :execute)
      (defstruct-helper name-and-options rest)))

使用例：
  ;;; FTPサーバを表す構造体の場合
  ;;; 初期値を予め指定することも可能
  (defstruct ftpsvr 
     anonymous hostname (port 80))
  =&gt; #&lt;structure-definition: ftpsvr&gt;
  (setq f1 (make-ftpsvr))
  =&gt; #S(ftpsvr anonymous nil hostname nil port 80)
  (setq f2 (make-ftpsvr  :anonymous t :hostname "ftp.world.com"))
  =&gt; #S(ftpsvr anonymous t hostname "ftp.world.com" port 80)
  (setq f3 #S(ftpsvr anonymous nil hostname "localhost"))
  =&gt; #S(ftpsvr anonymous nil hostname "localhost" port 80)

  ;;; 人を表す構造体の場合
  (defstruct person
     (name nil :type string)
     age
     (bloodtype "A"))
  =&gt; #&lt;structure-definition: person&gt;
  (setq p1 (make-person :name "Mike" :age 19))
  =&gt; #S(person name "Mike" age 19 bloodtype "A")
  (person-name p1)
  =&gt; "Mike"
  (setq p2 (copy-person p1))
  =&gt; #S(person name "Mike" age 19 bloodtype "A")
  (setf (person-bloodtype p1) "O")
  =&gt; "O"
  (person-bloodtype p1)
  =&gt; "O"
  (person-bloodtype p2)
  =&gt; "A"

  ;;; 患者を表す構造体の場合
  (defstruct (patient
             (:conc-name p-)
             (:print-function
              (lambda (o s p)
                (format s "&lt;patient ~A ~D ~A&gt;" (p-name o) (p-age o) (p-sicks o))))
              (:include person))
     (sicks nil :type (or nil list))
     id)
  =&gt; #&lt;structure-definition: patient&gt;
  (setq p3 (make-patient :name "Lucy" :age 18 :sicks '("かぜ")))
  =&gt; #S(patient name "Lucy" age 18 bloodtype "A" sicks ("かぜ") id nil)
  (format nil "~A" p3)
  =&gt; "&lt;patient Lucy 18 (かぜ)&gt;"
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>struct.l</file>
</chapter>

<chapter>
<title>defun</title>
<type>Macro</type>
<arguments>defun NAME (&amp;rest LAMBDA-LIST) &amp;body BODY</arguments>
<package>lisp</package>
<description>
関数を定義します。NAME がすでに関数定義を持つ場合は上書きされます。
BODY の先頭に documentation 文字列や interactive 宣言を含めることができます。
</description>
<seealso>lambda</seealso>
<section>関数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>defvar-local</title>
<type>Macro</type>
<arguments>defvar-local NAME INITIAL-VALUE &amp;optional DOC</arguments>
<package>editor</package>
<description>
変数NAMEがバッファ毎に異なる値を持つようにします。関連する関数として、
defvar/make-local-variable等がありますが、それぞれ機能が異なります。
defvar-localはdefvarと異なり、スペシャル変数とはならないので注意が必要です。

  defvar              : スペシャル変数を作る。
  defvar-local        : 全バッファで変数が独自の値を持つようにする。
  make-local-variable : 特定のバッファで変数が独自の値を持つようにする。

また、defvar-localだけではその変数はローカル変数にはならないようです。バ
ッファでsetqをして初めてローカルになる（local-variable-pがtになる）よう
です。

使用例：
  ;;; defvarとdefvar-localを使ってダイナミックかレキシカルかを確認する。
  (defvar var 3)
  =&gt; var  
  (defvar-local var-local 3)
  =&gt; var-local
  
  (defun foo () (let ((var 4) (var-local 4)) (bar)))
  =&gt; foo
  (defun bar () (format nil "var : ~S, var-local : ~S" var var-local))
  =&gt; bar
  
  (foo)
  =&gt; "var : 4, var-local : 3"
(defvar-local *dabbrevs-case-fold* nil)
</description>
<seealso>make-local-variable</seealso>
<seealso>setq-default</seealso>
<seealso>local-variable-p</seealso>
<seealso>buffer-local-value</seealso>
<seealso>defvar</seealso>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>defvar</title>
<type>Macro</type>
<arguments>defvar NAME &amp;optional (INITIAL-VALUE () SV) DOC</arguments>
<package>lisp</package>
<description>
グローバルなスペシャル変数を宣言します。
宣言された変数はダイナミックなスコープを持つようになります。
INITIAL-VALUE が与えられた場合、NAME が変数としての値を持たなければ
INITIAL-VALUE を評価し、その結果を変数値として設定します。
</description>
<seealso>defparameter</seealso>
<seealso>defvar-local</seealso>
<seealso>defconstant</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>delete-backward-char-or-selection</title>
<type>Function</type>
<arguments>delete-backward-char-or-selection &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
セレクションがあればセレクション全体を、そうでなければカーソルの後方の
文字を削除します。[C-h]
</description>
<seealso>delete-char-or-selection</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-buffer</title>
<type>Function</type>
<arguments>delete-buffer BUFFER</arguments>
<package>editor</package>
<description>
バッファを削除しますが、kill-bufferと違い対話的に削除するかどうかは聞き
ません。kill-bufferも内部的にはdelete-bufferを使っています。

delete-bufferでは以下の二つのフックが順番に実行されます。

  *before-delete-buffer-hook*
        delete-bufferを継続するかどうかを制御します。登録された関数が一
        つでもnilを返すとdelete-bufferを中止します。

  *delete-buffer-hook*
        delete-bufferされるバッファで何か処理を行う場合に使用します。
</description>
<seealso>*before-delete-buffer-hook*</seealso>
<seealso>*delete-buffer-hook*</seealso>
<seealso>kill-buffer</seealso>
<seealso>deleted-buffer-p</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-char-or-selection</title>
<type>Function</type>
<arguments>delete-char-or-selection &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
セレクションで選択中ならばセレクション全体を、そうでなければカーソルの位
置の文字を削除します。delete-charとはセレクション時の動作が異なります。
[C-d], [Delete]
</description>
<seealso>delete-char</seealso>
<seealso>delete-selection</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-char</title>
<type>Function</type>
<arguments>delete-char &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
指定文字数分だけ削除します。
</description>
<seealso>delete-char-or-selection</seealso>
<seealso>delete-backward-char</seealso>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-directory</title>
<type>Function</type>
<arguments>delete-directory DIRNAME &amp;key :if-does-not-exist :if-access-denied</arguments>
<package>lisp</package>
<description>
ディレクトリを削除します。

  DIRNAME            : 削除するディレクトリ名を指定します。
  :if-does-not-exist : ディレクトリが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :if-access-denied  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：
  (delete-directory "C:/xyzzy/testdir")
  =&gt; t
</description>
<seealso>delete-file</seealso>
<seealso>create-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-file-in-archive</title>
<type>Function</type>
<arguments>delete-file-in-archive ARCHIVE-FILE &amp;rest FILES</arguments>
<package>editor</package>
<description>
アーカイブから指定したファイルを削除します。

  ARCHIVE-FILE : アーカイブを指定します。
  FILES        : 削除するファイルを指定します。

使用例：
  ;;; c:/tmp/foo.lzh から xyz.c を削除します。
  (delete-file-in-archive "c:/tmp/foo.lzh" "xyz.c")
</description>
<seealso>create-archive</seealso>
<seealso>extract-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-file</title>
<type>Function</type>
<arguments>delete-file FILE &amp;key :if-does-not-exist :if-access-denied :recycle</arguments>
<package>lisp</package>
<description>
ファイルを削除します。

  FILE               : 削除するファイル名を指定します。
  :if-does-not-exist : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :if-access-denied  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：  
  (delete-file "C:/xyzzy/test.txt")
  =&gt; t
</description>
<seealso>delete-directory</seealso>
<seealso>rename-file</seealso>
<seealso>copy-file</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-horizontal-spaces</title>
<type>Function</type>
<arguments>delete-horizontal-spaces</arguments>
<package>editor</package>
<description>
同一行内のカーソル位置の前後の空白を削除します。[ESC \]
</description>
<seealso>just-one-space</seealso>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-if-not</title>
<type>Function</type>
<arguments>delete-if-not PREDICATE SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。
</description>
<seealso>remove-if-not</seealso>
<seealso>delete</seealso>
<seealso>delete-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-if</title>
<type>Function</type>
<arguments>delete-if PREDICATE SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。
</description>
<seealso>remove-if</seealso>
<seealso>delete</seealso>
<seealso>delete-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-indentation</title>
<type>Function</type>
<arguments>delete-indentation &amp;optional ARG</arguments>
<package>editor</package>
<description>
インデントを削除し直前の行と連結します。[ESC ^]
連結する行とされる行は、半角スペースで区切られます。

  ARG : 連結する行を指定します。
        t   次行のインデントを削除し、現在の行に連結します。
        nil 現在の行のインデントを削除し、直前の行に連結します。
</description>
<seealso>just-one-space</seealso>
<seealso>newline-and-indent</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-last-ime-composition</title>
<type>Function</type>
<arguments>delete-last-ime-composition</arguments>
<package>editor</package>
<description>
IME 変換直後であれば、直前に変換した文字列を削除します。[C-c C-d]
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>delete-marker</title>
<type>Function</type>
<arguments>delete-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーを削除します。
オブジェクトはマーカーとして使えなくなります。
成功した場合 t、すでに削除されていた場合は nil を返します。

使用例：
  (delete-marker m)
  =&gt; t
  m
  =&gt; #&lt;deleted-marker 128914348&gt;
</description>
<seealso>unset-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-menu</title>
<type>Function</type>
<arguments>delete-menu MENU TAG-OR-POSITION &amp;optional TAG-OR-POSITION-P</arguments>
<package>editor</package>
<description>
メニューから項目等を削除します。

  MENU              : 削除するメニューを指定します。
  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置と
                      して解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
  
タグを指定した場合にはメニューを再帰的に検索し最初に見つかった項目を削除
します。 タグが存在しない場合やメニュー項目数以上の位置を指定した場合に
は、削除に失敗します。

戻り値は以下のとおりです。

  t   削除に成功した。
  nil 削除に失敗した。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-other-windows</title>
<type>Function</type>
<arguments>delete-other-windows</arguments>
<package>editor</package>
<description>
現在カーソルがあるウィンドウ以外のウィンドウを削除します。 [C-x 1]
ただし、現在カーソルがあるウィンドウがミニバッファウィンドウの場合は他の
ウィンドウを削除しません。

戻り値：
  t     ウィンドウの削除に関わらず t 固定
</description>
<seealso>delete-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-package</title>
<type>Function</type>
<arguments>delete-package PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージを削除します。

使用例：
  ;;; test 用パッケージを作る
  (defpackage "test")
  =&gt; #&lt;package: test&gt;
  (find-package "test")
  =&gt; #&lt;package: test&gt;
  ;;; test パッケージを削除する
  (delete-package "test")
  =&gt; t
  (find-package "test")
  =&gt; nil
</description>
<seealso>make-package</seealso>
<seealso>defpackage</seealso>
<seealso>パッケージ</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-region</title>
<type>Function</type>
<arguments>delete-region FROM TO</arguments>
<package>editor</package>
<description>
指定された範囲を削除します。
</description>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-text-attributes</title>
<type>Function</type>
<arguments>delete-text-attributes TAG &amp;key :test :test-not :key</arguments>
<package>editor</package>
<description>
set-text-attributeで指定したタグの属性を消します
</description>
<seealso>delete-text-attribute-point</seealso>
<seealso>delete-text-attributes-if</seealso>
<seealso>clear-all-text-attributes</seealso>
<seealso>set-text-attribute</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-tool-bar</title>
<type>Function</type>
<arguments>delete-tool-bar NAME</arguments>
<package>editor</package>
<description>
ツールバーNAMEを削除します。
コマンドバーとして登録していた場合には、[表示]-[ツールバー]に残骸が残っ
てしまいますので、delete-command-barで削除する必要があります。
</description>
<seealso>create-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-trailing-spaces</title>
<type>Function</type>
<arguments>delete-trailing-spaces</arguments>
<package>editor</package>
<description>
ポイント後方の連続するスペースを削除します。
</description>
<seealso></seealso>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete</title>
<type>Function</type>
<arguments>delete ITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でITEMと一致するものを削除したシーケンスを返します。
引数 SEQUENCE は破壊されます。

  :count    : 削除する文字数を制限します。
  :from-end : :countが指定された場合にのみ意味を持ちます。
         nil    SEQUENCEの先頭から削除します。
         t      SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        =&gt; "abcabcdef"
  (remove #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "abcabcdef"
  (delete #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "acacdef"
</description>
<seealso>remove</seealso>
<seealso>delete-if</seealso>
<seealso>delete-if-not</seealso>
<seealso>delete-duplicates</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>deleted-buffer-p</title>
<type>Function</type>
<arguments>deleted-buffer-p BUFFER</arguments>
<package>editor</package>
<description>
バッファが削除されているかどうかを調べます。
BUFFERにはバッファ型のものしか指定できません。

  t   指定されたバッファは既に削除されています。
  nil 指定されたバッファは未だ削除されていません。
</description>
<seealso>delete-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>denominator</title>
<type>Function</type>
<arguments>denominator RATIONAL</arguments>
<package>lisp</package>
<description>
分数の分母を返します。
</description>
<seealso>numerator</seealso>
<seealso>/</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>describe-function</title>
<type>Function</type>
<arguments>describe-function SYMBOL</arguments>
<package>editor</package>
<description>
指定された関数の引数と docstring を表示します。
</description>
<seealso>describe-variable</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-key-briefly</title>
<type>Function</type>
<arguments>describe-key-briefly KEY &amp;optional ARG</arguments>
<package>editor</package>
<description>
指定したキーにバインドされた関数を表示します。[C-x ?]

  KEY : 検索するキー
  ARG : 出力(表示)先をどこにするか
        nil     : ステータスバーに表示
        non-nil : バッファに「キー (関数名)」のフォーマットで文字列を出力
</description>
<seealso>describe-key</seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-key</title>
<type>Function</type>
<arguments>describe-key KEY</arguments>
<package>editor</package>
<description>
指定したキーにバインドされた関数と docstring を表示します。
</description>
<seealso>describe-key-briefly</seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-variable</title>
<type>Function</type>
<arguments>describe-variable SYMBOL</arguments>
<package>editor</package>
<description>
指定された変数の現在の値、種類(constant or special)および docstring を表
示します。
</description>
<seealso>describe-function</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>dialog-box</title>
<type>Function</type>
<arguments>dialog-box TEMPLATE INITIAL-VALUE CHECK-OR-DISABLE</arguments>
<package>editor</package>
<description>
ダイアログボックスを表示します。ダイアログはdialogで定義されたものを使います。

  TEMPLATE :
      lispの形式で記述されたダイアログテンプレートを指定します。
      詳細は、関数dialogを参照してください。

  INITIAL-VALUE :
      エディトボックス等に入れる、文字列などを指定します。
      特に指定しない場合はnilでもかまいません。

  CHECK-OR-DISABLE :
      チェックボックス等の初期選択状態を指定します。
      特に指定しない場合はnilでもかまいません。

戻り値は多値なので、 multiple-value-bind 等で受け取る必要があります。1番
目の戻り値は、cancelボタンが押されたらnil、okボタンが押されたらtが返ります。
  
使用例：
  ;;; テスト用のダイアログを定義します。
  (setq *test-dialog-template*
    `(dialog 0 0 300 100 
             (:caption "について")
             (:font 9 "ＭＳ Ｐゴシック")
             (:control
              (:static nil nil #x50020003 7 7 18 21)
              (:static nil ,(concat "XYZZY version "
                                    (software-version))
               #x50020000 34 7 92 8)
              (:static nil "Copyright (C) 1996, 97 T.Kamei"
               #x50020000 34 17 92 8)
              (:button IDOK "OK" #x50010001 52 35 36 14))))

  ;;; テスト用のダイアログを表示します。
  (defun test-dialog ()
    (interactive)
    (dialog-box *test-dialog-template* nil nil)
    t)
</description>
<seealso>dialog</seealso>
<seealso>file-name-dialog</seealso>
<seealso>directory-name-dialog</seealso>
<seealso>drive-dialog</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dialog</title>
<type>Function</type>
<arguments>dialog X Y W H &amp;rest CONTROLS</arguments>
<package>lisp</package>
<description>
ダイアログを定義します。

  X Y      : ダイアログの表示位置を指定します。
  W H      : ダイアログの大きさを指定します。
  CONTROLS : コントロールを指定します。

コントロールをxyzzyで作成するのは面倒なので、VisualC++のリソース作成画面
で、部品を配置して変換する方法が用意されています。新しくバッファを作って 
*.rcファイルから必要な部分を持ってきた後で、

  M-x convert-dialog-template-buffer

バッファ名を選択するとlisp形式に変換されます。
</description>
<seealso>dialog-box</seealso>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>digit-char-p</title>
<type>Function</type>
<arguments>digit-char-p CHAR &amp;optional (RADIX 10)</arguments>
<package>lisp</package>
<description>
CHAR が数字ならその数字の10進表現での値を、そうでなければ nil を返します。

  RADIX : 基数

使用例：  
  (digit-char-p #\1)
  =&gt; 1
  (digit-char-p #\a)
  =&gt; nil
  (digit-char-p #\a 16)
  =&gt; 10
  (digit-char-p #\RET)
  =&gt; nil
</description>
<seealso>digit-char</seealso>
<seealso>characterp</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>digit-char</title>
<type>Function</type>
<arguments>digit-char WEIGHT &amp;optional (RADIX 10)</arguments>
<package>lisp</package>
<description>
RADIX を基数とした場合の WEIGHT の表示上の文字を返します。
下の例ですと、 (digit-char 12 16) は16進表記した場合の12は、
#\C になります。WEIGHT が RADIX 以上になると nil が返ります。

使用例：
  (digit-char 7)
  =&gt; #\7
  (digit-char 12)
  =&gt; nil
  (digit-char 12 16)
  =&gt; #\C
  (digit-char 6 2)
  =&gt; nil
  (digit-char 1 2)
  =&gt; #\1
</description>
<seealso>digit-char-p</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ding</title>
<type>Function</type>
<arguments>ding</arguments>
<package>editor</package>
<description>
音を鳴らします？（詳細不明）

使用例：
  ;;; 音を鳴らす。
  (ding)
  =&gt; nil
</description>
<seealso>undefined</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>directory-name-dialog</title>
<type>Function</type>
<arguments>directory-name-dialog &amp;key :title :default</arguments>
<package>editor</package>
<description>
ディレクトリを指定するダイアログを表示します。
ユーザーが指定したディレクトリを返します。
  
  :title   : ダイアログのタイトル
  :default : 初期表示するディレクトリ

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (directory-name-dialog)
  =&gt; "C:/applications/xyzzy/site-lisp"
</description>
<seealso>file-name-dialog</seealso>
<seealso>read-directory-name</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>directory-namestring</title>
<type>Function</type>
<arguments>directory-namestring PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのディレクトリ部分を返します。

使用例：  
  (directory-namestring "C:/xyzzy/xyzzy.exe")
  =&gt; "C:/xyzzy/"
  (directory-namestring "~/test.txt")
  =&gt; "C:/HOME/"
  (directory-namestring "/usr/local/bin")
  =&gt; "C:/usr/local/"
</description>
<seealso>pathname-directory</seealso>
<seealso>file-namestring</seealso>
<seealso>remove-trail-slash</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>directory</title>
<type>Function</type>
<arguments>directory PATHNAME &amp;key :absolute :recursive :wild :depth :file-only :show-dots :count :directory-only :callback :file-info</arguments>
<package>lisp</package>
<description>
対象ディレクトリ下のファイル名をリストで得ます。

  PATHNAME        : 検索するディレクトリのパスです。
  :absolute       : 検索結果をフルパスで取得します。
  :recursive      : サブディレクトリも対象とするかを制御します。
        t               サブディレクトリの中まで検索
        nil             サブディレクトリの中までは検索しない
  :wild           : ワイルドカード指定です。リストでも可です。
  :depth          : :recursive 指定するときの再帰の深さです。
  :file-only      : ファイルしか検索しません。
  :show-dots      : ディレクトリとして"./"と"../"を加えます。
  :count          : 表示されるファイルの個数を制限します。
  :directory-only : ディレクトリしか検索しません。
  :callback       : 見つかったファイルを引数にして funcall します。
                    funcall した結果をリストにして返します。
  :file-info      : ファイルの属性を取得します。
                    get-file-info で取得できるものと同じです。

使用例：
  ;;;  "../"は出したいけど、"./"を出したくない場合
  (delete "./" (directory ... :show-dots t) :test #'string=)

  ;;; "C:/"の配下を一覧表示する。
  (directory "C:/" :callback #'(lambda (x) (print x)))

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string&lt;)

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string-lessp)
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>display-first-tab-char</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
タブの表示に使用する文字を設定します。最初の文字は
display-first-tab-charで設定し、以降の文字は
display-rest-tab-charで設定します。
xyzzy 0.2.2.215〜

使用例：
  (setq-default display-first-tab-char #\rightwards_arrow_to_bar)
  (setq-default display-rest-tab-char nil)
</description>
<seealso>display-rest-tab-char</seealso>
<link></link>
<section>文字</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>display-newline-char</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行の表示に使用する文字を設定します。
  半角文字  指定した文字で表示
  nil       空白で表示
  上記以外  従来の文字で表示

使用例：
  (setq-default display-newline-char #\downwards_arrow_with_tip_leftwards)
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>do*</title>
<type>Macro</type>
<arguments>do* (&amp;rest VARLIST) (&amp;optional END-TEST &amp;rest RESULT) &amp;body BODY</arguments>
<package>lisp</package>
<description>
doと同じようにループ処理を行う。
doとだいたい同じだけど、letとlet*の違いのように、局所変数の初期化と更
新の方法にある。doはletを使って局所変数を初期化しているため、全ての初
期値を計算してから局所変数をバインドするが，do*ではletの代わりにlet*
が使われている。またpsetqのかわりにsetqを使う。

do*式の一般形は、

(block nil
  (let* ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
         (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
                  ...
         (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (tagbody
      loop
      (when &lt;終了条件&gt;
        (return (progn &lt;後式1&gt; ... &lt;後式p&gt;)))
      &lt;式1&gt;
      ...
      &lt;式n&gt;
     (setq &lt;変数1&gt; &lt;ステップ1&gt;
              ...
           &lt;変数m&gt; &lt;ステップm&gt;)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)
</description>
<seealso>do</seealso>
<seealso>let</seealso>
<seealso>let*</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>do-all-symbols</title>
<type>Macro</type>
<arguments>do-all-symbols (VAR &amp;optional RESULT-FORM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
全シンボルを列挙します。

  VAR         : 列挙されたシンボルを格納する変数名を指定します。
  RESULT-FORM : （詳細不明）
  BODY        : 実行するフォームを指定します。

使用例：
  ;;; シンボルを列挙して変数・関数・マクロ・パッケージを出力してみる。
  (do-all-symbols (sym)
    (and (or (boundp sym)
             (fboundp sym))
         (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S~%"
                 (boundp sym)
                 (fboundp sym)
                 (macro-function sym)
                 (package-name (symbol-package sym))
                 sym)))
</description>
<seealso>with-package-iterator</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>do-completion</title>
<type>Function</type>
<arguments>do-completion FROM TO TYPE &amp;optional COMPL WORD LAST-CHAR (POPUP-P *POPUP-COMPLETION-LIST-DEFAULT*)</arguments>
<package>editor</package>
<description>
テキストの補完をします。
詳細は*do-completionを参照して下さい。

使用例：
  ;;; カーソルの直前のパスを補完します。
  (do-completion (point) 
                 (progn (skip-syntax-spec-backward "^ ") (point))
                 :file-name)
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>do-events</title>
<type>Function</type>
<arguments>do-events</arguments>
<package>lisp</package>
<description>
長い処理の途中に、Windowsのイベントを処理してあげるおまじないらしい。

使用例：
  ;;; イベント処理をしてみる。
  (do-events)
  =&gt; nil
</description>
<seealso>refresh-screen</seealso>
<seealso>sit-for</seealso>
<seealso>sleep-for</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>do</title>
<type>Macro</type>
<arguments>do (&amp;rest VARLIST) (&amp;optional END-TEST &amp;rest RESULT) &amp;body BODY</arguments>
<package>lisp</package>
<description>
(do ((var1 init1 step1)
     (var2 init2 step2)
            ...
     (varm initm stepm))
    (end-test result1 result2 ... resultm) 
   declaration1
       ...
   declarationN)

(do ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
     (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
              ...
     (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (&lt;&lt;終了条件&gt; &lt;後式1&gt; ... &lt;後式p&gt;) 
   &lt;式1&gt;
   ...
   &lt;式n&gt;)


&lt;変数1&gt;〜&lt;変数m&gt;までを局所変数とし，&lt;終了条件&gt;が真
になるまでdo式本体の&lt;式1&gt;〜&lt;式n&gt;を繰り返し実行する。&lt;
変数1&gt;〜&lt;変数m&gt;までは変数を表す記号で，do式の中で局所的に使
われる変数を指定する。do式が評価されるときは，まず&lt;初期値1&gt;〜
&lt;初期値m&gt;までが評価され，その値が各局所変数にバインドされる。そ
の後で，&lt;終了条件&gt;が評価され，もし値がnilであれば本体を実行する。
次に&lt;ステップ1&gt;〜&lt;ステップm&gt;までを評価してその値を各局所
変数に代入してから&lt;終了条件&gt;を評価する。これを&lt;終了条件&gt;
の値がnil以外になるまで繰り返す。&lt;終了条件&gt;の値がnil以外になっ
たら，&lt;終了条件&gt;に続く&lt;後式1&gt;〜&lt;後式p&gt;を評価し，そ
の最後の式の値をdo式の値とする。

do式の一般形は，

(block nil
  (let ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
        (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
                 ...
        (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (tagbody
      loop
      (when &lt;終了条件&gt;
        (return (progn &lt;後式1&gt; ... &lt;後式p&gt;)))
      &lt;式1&gt;
      ...
      &lt;式n&gt;
     (psetq &lt;変数1&gt; &lt;ステップ1&gt;
              ...
            &lt;変数m&gt; &lt;ステップm&gt;)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)
</description>
<seealso></seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>dolist</title>
<type>Macro</type>
<arguments>dolist (VAR LISTFORM &amp;optional (RESULTFORM ''())) &amp;body BODY</arguments>
<package>lisp</package>
<description>
リストの長さ分だけ繰り返しを行います。

  (dolist (&lt;変数&gt; &lt;リスト式&gt; &lt;値&gt;)
    &lt;式1&gt; ... &lt;式n&gt;)

まず&lt;リスト式&gt;を評価する。その後リストの要素ごとに変数をその要素に
バインドして，本体の&lt;式1&gt;〜&lt;式n&gt;までを評価する。本体式の評価
が全ての要素に対して終わると，&lt;値&gt;を評価し，dolistの値として返す。
また&lt;値&gt;は省略でき，その場合はdolistの値はnilである。

dolist式の一般形は，
  
  (do* ((temp &lt;リスト式&gt; (cdr temp))
        (&lt;変数&gt; (car temp) (car temp)))
      ((endp temp) &lt;値&gt;)
    &lt;式1&gt;
    ...
    &lt;式n&gt;)
  
と同値である。

使用例：
  (let ((result nil))
    (dolist (item '("Lois" "Charley" "David") (nreverse result))
      (push (length item) result)))
  =&gt; (4 7 5)
</description>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>DOSのコマンドをキックして結果を文字列にするには？</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
| DOSのコマンド(コンソールアプリって言ったほうがいいのかな？）
| をキックして、結果を文字列として、取り出す事はできますか？

こんな感じでしょうか。

(defun command-substitution (command)
  (let ((outfile nil)
        (buffer nil))
    (unwind-protect
        (save-excursion
          (setq buffer (create-new-buffer "*foo*"))
          (setq outfile (make-temp-file-name))
          (call-process command :output outfile :show :hide :wait t)
          (set-buffer buffer)
          (insert-file-contents outfile)
          (goto-char (1- (point-max)))
          (when (looking-for "\n")
            (delete-char 1))
          (goto-char (point-min))
          (replace-buffer "\n+" " " :regexp t)
          (buffer-substring (point-min) (point-max)))
      (and buffer
           (delete-buffer buffer))
      (and outfile
           (delete-file outfile)))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>dotimes</title>
<type>Macro</type>
<arguments>dotimes (VAR COUNTFORM &amp;optional (RESULTFORM ''())) &amp;body BODY</arguments>
<package>lisp</package>
<description>
(dotimes (&lt;変数&gt; &lt;整数式&gt; &lt;値&gt;)
  &lt;式1&gt; ... &lt;式n&gt;)

指定された回数だけ繰り返しを行います。

まず&lt;整数式&gt;を評価します。その値をnとすると、0〜n-1までのそれぞれの
整数値に対して、&lt;変数&gt;をその整数値にバインドして、本体の&lt;式1&gt;〜&lt;式n&gt;
までを評価します。すなわち本体式はn回繰り返されます。本体式の評
価がn回繰り返されると、&lt;値&gt;を評価し、dotimesの値として返します。
また&lt;値&gt;は省略でき、その場合dotimesの戻り値はnilです。

dotimes式の一般形は、

(do* ((temp &lt;整数式&gt;)
      (&lt;変数&gt; 0 (1+ &lt;変数&gt;)))
    ((&gt;= &lt;変数&gt; temp) &lt;値&gt;)
  &lt;式1&gt;
  ...
  &lt;式n&gt;)

と同値です。
</description>
<seealso></seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>double-float-p</title>
<type>Function</type>
<arguments>double-float-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が double-float なら t 、それ以外なら nil を返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>downcase-region</title>
<type>Function</type>
<arguments>downcase-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語を小文字にします。[C-x C-l]
</description>
<seealso>downcase-word</seealso>
<seealso>capitalize-region</seealso>
<seealso>upcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>downcase-word</title>
<type>Function</type>
<arguments>downcase-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から単語の末尾までを小文字に変換します。[ESC l]
</description>
<seealso>upcase-word</seealso>
<seealso>capitalize-word</seealso>
<seealso>downcase-region</seealso>
<seealso>downcase-selection</seealso>
<seealso>string-downcase</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>drive-dialog</title>
<type>Function</type>
<arguments>drive-dialog &amp;optional DRIVE</arguments>
<package>editor</package>
<description>
ドライブ選択のダイアログを表示します。DRIVEで初期表示するドライブを選択
できます。選択したドライブのドライブ文字がキャラクタで返されます。

使用例：
  (drive-dialog)
  =&gt; #\R
</description>
<seealso>file-name-dialog</seealso>
<seealso>directory-name-dialog</seealso>
<link></link>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dump-xyzzy</title>
<type>Function</type>
<arguments>dump-xyzzy &amp;optional FILENAME</arguments>
<package>editor</package>
<description>
ダンプファイルをFILENAMEにして作成します。
既に作成されていても上書きします。
FILENAME省略時のファイル名は？（未確認）
</description>
<seealso>xyzzy-dumped-p</seealso>
<seealso>version-up-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>echo-stream-input-stream</title>
<type>Function</type>
<arguments>echo-stream-input-stream ECHO-STREAM</arguments>
<package>lisp</package>
<description>
make-echo-streamで作られたECHO-STREAMの入力元のストリームを返します。
</description>
<seealso>make-echo-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>echo-stream-output-stream</title>
<type>Function</type>
<arguments>echo-stream-output-stream ECHO-STREAM</arguments>
<package>lisp</package>
<description>
make-echo-streamで作られたECHO-STREAMの出力先のストリームを返します。
</description>
<seealso>make-echo-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ed::find-file-internal</title>
<type>Function</type>
<arguments>find-file-internal FILENAME &amp;optional NOWARN (KANJI-CODE nil SVAR) NEWLINE-CODE NOMSG</arguments>
<package>editor</package>
<description>
ファイルを開きます。find-fileはfind-file-internalを用いて実装されています。
find-fileは複数のファイルを開く機能がありますが、一つのファイルを開くの
であれば、こちらの方が高速です。

  FILENAME : ファイル名
</description>
<seealso>find-file</seealso>
<seealso>*find-file-hooks*</seealso>
<seealso>*before-find-file-hook*</seealso>
<seealso>*find-file-file-not-found-hook*</seealso>
<seealso>*find-file-auto-mode-function*</seealso>
<seealso>buffer-read-only</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>ed::get-selection-start-end</title>
<type>Function</type>
<arguments>get-selection-start-end</arguments>
<package>editor</package>
<description>
セレクションの開始位置と終了位置を多値で返します。
ただし、矩形選択状態ではnilを返します。
</description>
<section>ポジション</section>
<file>select.l</file>
</chapter>

<chapter>
<title>ed::map-selection</title>
<type>Function</type>
<arguments>map-selection FN</arguments>
<package>editor</package>
<description>
セレクションの開始位置と終了位置を引数にして関数を呼び出します。

  FN : 呼び出す関数を指定します。呼び出し時には開始位置と終了位置を渡し
       ますので、そのような関数のI/Fにしておかなければなりません。

使用例：
  ;;;
  (defun map-test ()
    (interactive)
    (ed::map-selection #'(lambda (start end) (message (format nil "~s ~s" start end)))))

補足：
  editorパッケージからエクスポートされてないので、ed::をつける必要があります。
  選択の開始位置と終了位置を正確に渡すので、前後関係に注意して下さい。
</description>
<section>ポジション</section>
<file>select.l</file>
</chapter>

<chapter>
<title>ed::toggle-mode</title>
<type>Function</type>
<arguments>toggle-mode VAR ARG SV</arguments>
<package>editor</package>
<description>
マイナーモードの状態を表す変数VARを設定します。
SVがnilならば状態は反転します。
ARGが負数もしくはnilならば無効になります。
ARGが非負数値もしくはnon-nilならば有効になります。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>eighth</title>
<type>Function</type>
<arguments>eighth X</arguments>
<package>lisp</package>
<description>
list の 8 番目の要素を返します。

  (eighth X) = (nth 7 X)

使用例：
  (eighth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 8
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>eject-media</title>
<type>Function</type>
<arguments>eject-media DRIVE</arguments>
<package>editor</package>
<description>
DRIVEに指定したドライブをイジェクトします。
DRIVEはキャラクタで指定します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"
  
  (eject-media (svref a 0)) ; イジェクト不可能なドライブ
  =&gt;指定されたデバイス名は無効です。 

  (eject-media #\P)
  =&gt;t
(svref (default-directory) 0))
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>elt</title>
<type>Function</type>
<arguments>elt SEQUENCE INDEX</arguments>
<package>lisp</package>
<description>
SEQUENCEのINDEX番目の要素を返します。
INDEXは0を基底とします。なければnilを返します。
</description>
<seealso>nth</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enable-post-buffer-modified-hook</title>
<type>Function</type>
<arguments>enable-post-buffer-modified-hook ENABLE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
post-buffer-modified-hookを有効・無効にします。
カレントバッファの値のみ変更します。

  ENABLE  : non-nil 有効にします
            nil     無効にします
  BUFFER  : 有効にするバッファを指定します。
            省略時やnilを与えた場合はカレントバッファを指定したとみなします。
</description>
<seealso>post-buffer-modified-hook-enabled-p</seealso>
<seealso>post-buffer-modified-hook</seealso>
<link>[xyzzy:06354]</link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>encode-universal-time</title>
<type>Function</type>
<arguments>encode-universal-time SECOND MINUTE HOUR DAY MONTH YEAR &amp;optional TIME-ZONE</arguments>
<package>lisp</package>
<description>
日時からユニバーサルタイム形式の時間に変換します「1900年1月1日0時0分0秒
から指定された日時まで秒数」をユニバーサルタイム形式の時間と呼びます。

  SECOND    : 秒数
  MINUTE    : 分
  HOUR      : 時
  DAY       : 日
  MONTH     : 月
  YEAR      : 年
  TIME-ZONE : タイムゾーンを指定します。GMTからの差分の時間を指定するようです。
              省略すると選択しているタイムゾーンとの差分が使用されます。
              普通はGMTとJSTとの差分の-9(時間)となります。

ユニバーサルタイム形式の時間から日時への変換はdecode-universal-timeを使用します。

使用例：
  (encode-universal-time 0 0 0 1 1 1900)    =&gt; -32400
  (encode-universal-time 0 0 0 1 1 1900 0)  =&gt; 0
  (encode-universal-time 0 0 0 1 1 1900 -9) =&gt; -32400
  (encode-universal-time 0 30 18 24 4 2003) =&gt; 3260165400

参照：
  timestmp.l
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>end-of-buffer</title>
<type>Function</type>
<arguments>end-of-buffer</arguments>
<package>editor</package>
<description>
カーソルをバッファの末尾に移動します。[ESC &gt;]
元あったカーソル位置にはマークを設定します。

マークを変更しないためには
(goto-char (point-max))を使います。
</description>
<seealso>beginning-of-buffer</seealso>
<seealso>set-mark-command</seealso>
<seealso>selection-end-of-buffer</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>end-of-defun</title>
<type>Function</type>
<arguments>end-of-defun &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを関数定義の末尾に移動します。[ESC C-e]
</description>
<seealso>beginning-of-defun</seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>end-of-line</title>
<type>Function</type>
<arguments>end-of-line</arguments>
<package>editor</package>
<description>
現在行の終りに移動します。[C-e], [C-Right]
</description>
<seealso>beginning-of-line</seealso>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>endp</title>
<type>Function</type>
<arguments>endp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が空かどうかを返します。
リストの終わりを判定するのに使用されます。 null と異なり、
例えば文字列を指定するとエラーを発生します。

  空リストもしくはnil   t
  空でないリスト        nil
  それ以外              エラー

使用例：
  ;;; nullとの違いを見てみる。
  (endp "foo")  =&gt; 不正なデータ型です: t: list
  (endp nil)    =&gt; t
  (null "foo")  =&gt;nil
  (null nil)    =&gt; t
</description>
<seealso>null</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enlarge-window-horizontally</title>
<type>Function</type>
<arguments>enlarge-window-horizontally &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの幅を大きくします。[C-x }]

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (enlarge-window-horizontally (- *lister-margin* (window-width)))
</description>
<seealso>shrink-window-horizontally</seealso>
<seealso>enlarge-window</seealso>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>enlarge-window</title>
<type>Function</type>
<arguments>enlarge-window &amp;optional EXTEND VERTICAL</arguments>
<package>editor</package>
<description>
ウィンドウの行数・桁数を変更します。[C-x z], [C-x ^]
VERTICALを指定しない場合には行数を変更します。

  EXTEND   : 大きくする行数・桁数を指定します。負数を指定すると小さくなります。
  VERTICAL : 桁・行のどちらを設定するか指定します。
        t       桁数を変更する。
        nil     行数を変更する。

使用例：
  ;;; ウィンドウを変更してみる。
  (enlarge-window 2 t)  =&gt; t
  (enlarge-window 100)  =&gt; 変更できません 
</description>
<seealso>shrink-window</seealso>
<seealso>enlarge-window-horizontally</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enum-buffers</title>
<type>Function</type>
<arguments>enum-buffers FN</arguments>
<package>editor</package>
<description>
関数がnil以外を返すまでバッファを列挙し続けます。

使用例：
  ;;; バッファを列挙し続ける。
  (enum-buffers #'(lambda (x) (and (yes-or-no-p "~S" x) x)))
  =&gt; #&lt;buffer:  *Completion*&gt;
</description>
<seealso>buffer-list</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eobp</title>
<type>Function</type>
<arguments>eobp</arguments>
<package>editor</package>
<description>
ポイントがバッファの最後にあるかどうか調べます。

使用例：
  ;;; バッファの最後までカーソルをひとつひとつ進める？
  (while (not (eobp))
    (forward-char))
</description>
<seealso>bobp</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eolp</title>
<type>Function</type>
<arguments>eolp</arguments>
<package>editor</package>
<description>
カーソルが行末にあるかどうか調べます。

  t     カーソルが行末にある
  nil   カーソルは行末にはない
</description>
<seealso>bolp</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eq</title>
<type>Function</type>
<arguments>eq X Y</arguments>
<package>lisp</package>
<description>
X と Y が同一オブジェクトならt、そうでないならnilを返します。数値や文字
列に対しては見かけ上同じでもtとなる保証はありません。xyzzyでは、数値はt
となるが文字列ではnilとなるように実装されているようです。

使用例：
  ;;; eqで比較してみる。
  (eq 'foo 'foo)        =&gt; t    ; 仕様
  (eq 2 2)              =&gt; t    ; 処理系依存
  (eq "foo" "foo")      =&gt; nil  ; 処理系依存
  (eq '(1 2) '(1 2))    =&gt; nil  ; 処理系依存
</description>
<seealso>eql</seealso>
<seealso>equal</seealso>
<seealso>equalp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eql</title>
<type>Function</type>
<arguments>eql X Y</arguments>
<package>lisp</package>
<description>
X と Y が同一オブジェクトか、同じ型の数値または文字型で値が等しいかを返
します。等しければtを、そうでなければnilを返します。eqとは異なり、値とし
て等しいかを判断します。ただし、中身までは見ないので文字列は対象外となり
ます。

使用例：
  ;;; eqlで比較してみる。
  (eql 'foo 'foo)       =&gt; t    ; 仕様
  (eql 2 2)             =&gt; t    ; 仕様
  (eql "foo" "foo")     =&gt; nil  ; 処理系依存
  (eql '(1 2) '(1 2))   =&gt; nil  ; 処理系依存
</description>
<seealso>eq</seealso>
<seealso>equal</seealso>
<seealso>equalp</seealso>
<seealso>char=</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>equal</title>
<type>Function</type>
<arguments>equal X Y</arguments>
<package>lisp</package>
<description>
X と Y が同じ構造を持っていればtを、そうでなければnilを返します。

使用例：
  ;;; equalで比較してみる。
  (equal 'foo 'foo)     =&gt; t    ; 仕様
  (equal 2 2)           =&gt; t    ; 仕様
  (equal "foo" "foo")   =&gt; t    ; 仕様
  (equal '(1 2) '(1 2)) =&gt; t    ; 仕様
</description>
<seealso>eq</seealso>
<seealso>eql</seealso>
<seealso>equalp</seealso>
<seealso>=</seealso>
<seealso>char=</seealso>
<seealso>string=</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>equalp</title>
<type>Function</type>
<arguments>equalp X Y</arguments>
<package>lisp</package>
<description>
equalと同じように X と Y を比較します。
ただし、一部の差異を許容します。
例えば文字・文字列の比較では大文字と小文字を区別しません。

使用例：
  ;;; equalpで比較してみる。
  (equalp "Foo" "foo")  =&gt; t
</description>
<seealso>eq</seealso>
<seealso>eql</seealso>
<seealso>equal</seealso>
<seealso>=</seealso>
<seealso>char-equal</seealso>
<seealso>string-equal</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>erase-buffer</title>
<type>Function</type>
<arguments>erase-buffer BUFFER</arguments>
<package>editor</package>
<description>
バッファの内容を削除します。
以下の内容がクリアされます。
  ・バッファ上のテキスト
  ・変更フラグ
  ・修正日付
  ・restriction
  ・UNDO情報
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>error</title>
<type>Function</type>
<arguments>error DATUM &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
例外を発生します。

発生させた例外は上位の階層でハンドリングすることができます。
ハンドリングの方法はhandler-caseを参照して下さい。
</description>
<seealso>handler-case</seealso>
<seealso>ignore-errors</seealso>
<seealso>unwind-protect</seealso>
<seealso>エラー処理関係</seealso>
<seealso>stack-trace</seealso>
<seealso>make-condition</seealso>
<seealso>si:*condition-string</seealso>
<seealso>si:*throw-error</seealso>
<section>エラー</section>
<file>handler.l</file>
</chapter>

<chapter>
<title>etc-path</title>
<type>Function</type>
<arguments>etc-path</arguments>
<package>editor</package>
<description>
*etc-path*を返します。
</description>
<seealso>*etc-path*</seealso>
<link></link>
<section>システム</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>eval-region</title>
<type>Function</type>
<arguments>eval-region FROM TO &amp;optional STREAM</arguments>
<package>editor</package>
<description>
リージョン内に書かれたLispコードを評価します。

使用例：
  (eval-region from to (selected-buffer))
</description>
<seealso>eval-buffer</seealso>
<section>評価</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>eval-when</title>
<type>Special Form</type>
<arguments>eval-when ({SITUATION}*) {FORM}*</arguments>
<package>lisp</package>
<description>
ひとことで言うと、フォームをいつ評価するかってことです。

今回の例だと、define-dll-entry などのマクロはコンパイル時に展開
されなければならないのですが、define-dll-entry は foreign で定
義されているので、foreign がロードされていないとマクロであるこ
とが認識できません。(eval-when ...) がなく、単に (require 
"foreign") だけだと、コンパイル時には単なる関数コールだとみなさ
れてしまうため、マクロが展開されなくなってしまいます。そのため
に、eval-when でコンパイルするときも foreign をロードしろと指定
しているわけです。


          ソース                       ソース（左と同一）
            ↓  (eval)                   ↓  (compile)
      Lispインタープリタ           Lispコンパイラ
                                         ↓
                                        *.lc
                                         ↓   (load)
                                   Lispインタープリタ

C言語だと maxというのがマクロですよね。

#define max(a,b)   ((a&gt;b)?a:b)

こんなん。

int foo(int x, int y)
{
   return max(x, y);
}
と書いたら、
int foo(int x, int y)
{
   return ((x&gt; y) ? x : y);
}

こう書いたのと等価ですよね。
Ｃの入門書だとプリプロセッサがいったん展開してから、コンパイル
すると書かれていると思います。

lispだとこんなんになるんですが

----    test.l ---------

(defmacro macro-max (a b)
  `(if (&gt; ,a ,b) ,a ,b))

(defun foo (x y)
  (macro-max x y))

------------------------

M-x byte-compile-fileってやったときに、
(defmacro macro-maxっていう文は、コンパイルするんでなくって
eval(インタープリタが評価する）しとかないといけない。

でないとfooのところで、コンパイル前にソースを展開できない。

だから eval-when (compile)なんです。
よくわからなかったら、３つ全部つけておけば大丈夫という説もある^^;

(eval-when (:compile-toplevel :load-toplevel :execute)

Common Lispの仕様書では、たしか eval, load, compile
だけ,だったと思います。

eval        --- インタープリタにロードするときeval
compile     --- compile時にeval
load        --- compileした*.lc をロードするときeval

(eval-when (:compile-toplevel :load-toplevel :execute)
って、今まで、xyzzyオリジナルかと思ってました。

でもallegloのhelpをみていたら、
(eval-when (:compile-toplevel :load-toplevel :execute)
ってありますね。^^;
知りませんでした。

| Common Lispの仕様書では、たしか eval, load, compile
| だけ,だったと思います。

CLtL1 ではそうだったんですが、CLtL2 で変わりました。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eval</title>
<type>Function</type>
<arguments>eval FORM</arguments>
<package>lisp</package>
<description>
FORM を評価します。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>evenp</title>
<type>Function</type>
<arguments>evenp INTEGER</arguments>
<package>lisp</package>
<description>
INTEGERが偶数ならばt、そうでなければnilを返します。

使用例：  
  (evenp 2)
  =&gt; t
  (evenp 0)
  =&gt; t
  (evenp 1)
  =&gt; nil
</description>
<seealso>oddp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>every</title>
<type>Function</type>
<arguments>every PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、nilをすぐに返します。
全ての要素がPREDICATEを満たす場合、 t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>some</seealso>
<seealso>notevery</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>execute-shell-command</title>
<type>Function</type>
<arguments>execute-shell-command COMMAND &amp;optional INFILE OUTPUT ENVIRON DIRECTORY</arguments>
<package>editor</package>
<description>
外部プログラムを実行します。結果だけをxyzzyに取り込みます。

  COMMAND    : 実行するコマンドをオプション付で指定します。
  INFILE     : 標準入力を使用する外部プログラムであれば入力ファイル名を
               指定します。
  OUTPUT     : 標準出力を出力するバッファを指定します。
  ENVIRON    : 設定する環境変数を連想リスト形式で渡します。
                (("HOME" . "C:/applications/xyzzy/")
                 ("TOPDIR" . "C:/spool/"))
  DIRECTORY  : 実行するディレクトリを指定します。

このコマンドは call-process を使って実装されています。
call-processとは違って標準出力をバッファに出力します。出力するバッファは完
全に破壊されますので注意してください。
外部プログラムとして実行したくない場合は， execute-subprocess を使います。

使用例：
  ;;; コマンドプロンプトのhelpを表示してみる。
  (execute-shell-command "help" nil (selected-buffer))
</description>
<seealso>call-process</seealso>
<seealso>execute-subprocess</seealso>
<seealso>shell-execute</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>exp</title>
<type>Function</type>
<arguments>exp NUMBER</arguments>
<package>lisp</package>
<description>
自然対数の底 e の NUMBER 乗の数値を返します。

使用例：
  ;;; 自然対数の底 e とその二乗を表示してみる。
  (exp 1)
  =&gt; 2.718282
  (exp 2)
  =&gt; 7.389056
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>export</title>
<type>Function</type>
<arguments>export SYMBOLS &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
シンボルをパッケージの外部から参照できるようにします。

引数で指定された シンボル（変数や関数）はパッケージからエクスポートされ、
別のパッケージから修飾子無しで参照できるようになります。ただし、修飾子無
しで参照するには、別のパッケージからもuse-packageもしておかないといけませ
ん。
                   use  ┌system──┐
                    ┌─┤          │
  ┌lisp───┐←─┘  └─────┘        ┌user───┐
  │          │←────────────┬─┤          │
  └─────┘←─┐  ┌editor──┐    │  └─────┘
                    └─┤          │←─┘
                        └─────┘

上の図はどのパッケージをuse-pakcageしているかを示しています。
パッケージがuseする他のパッケージはpackage-use-listを使って確認すること
ができます。userは、lispとeditorをuse-packageしています。

si:system-rootはsystemからexportされていますが、userがsystemを
use-packageしていないので修飾子が必要です。

  ;;; system-rootがsystemからexportされていることを確認する。
  (find-symbol "system-root" "system")
  =&gt; system:system-root
     :external

このためuserからsystem-rootを使用する場合には(si:system-root)という呼び
出し方になります。

使用例：
    ;;; 引数で指定された aset, file-name-sans-versions, ...は
    ;;; エクスポートされ、別のパッケージから参照できるようになる。
    (export '(aset file-name-directory file-name-nondirectory
          file-name-sans-versions))
</description>
<seealso>パッケージ</seealso>
<seealso>use-package</seealso>
<seealso>どの関数の頭に何がつくのでしょうか？</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>expt</title>
<type>Function</type>
<arguments>expt BASE-NUMBER POWER-NUMBER</arguments>
<package>lisp</package>
<description>
べき乗します。

使用例：  
  (expt 2 10)
  =&gt; 1024
  (expt 10 3)
  =&gt; 1000
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>extract-archive</title>
<type>Function</type>
<arguments>extract-archive ARCHIVE-FILE TO-DIRECTORY &amp;rest FILES</arguments>
<package>editor</package>
<description>
アーカイブを展開します。

ARCHIVE-FILE : 展開するアーカイブを指定します。
TO-DIRECTORY : 展開するディレクトリを指定します。
FILES        : 展開するファイルを指定します。指定しない場合は、全てのフ
               ァイルが展開されます。

使用例：
  ;;; d:/foo.lzh を c:/tmp に展開します。
  (extract-archive "d:/foo.lzh" "c:/tmp")
</description>
<seealso>create-archive</seealso>
<seealso>delete-file-in-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fast-scroll-down</title>
<type>Function</type>
<arguments>fast-scroll-down</arguments>
<package>editor</package>
<description>
高速に下スクロールします。[C-Up]
</description>
<seealso>fast-scroll-up</seealso>
<seealso>scroll-window</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>fast-scroll-up</title>
<type>Function</type>
<arguments>fast-scroll-up</arguments>
<package>editor</package>
<description>
高速に上スクロールします。[C-Down]
</description>
<seealso>fast-scroll-down</seealso>
<seealso>scroll-window</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>fboundp</title>
<type>Function</type>
<arguments>fboundp SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルに関数が定義されているかどうかを返します。

使用例：
  (fboundp 'car)
  =&gt; t
  (fboundp 't)
  =&gt; nil
</description>
<seealso>boundp</seealso>
<seealso>fmakunbound</seealso>
<seealso>macro-function</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fceiling</title>
<type>Function</type>
<arguments>fceiling NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
ceiling と同じですが浮動小数点数を返します。
</description>
<seealso>ceiling</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ffloor</title>
<type>Function</type>
<arguments>ffloor NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
floor と同じですが浮動小数点数を返します。
</description>
<seealso>floor</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fifth</title>
<type>Function</type>
<arguments>fifth X</arguments>
<package>lisp</package>
<description>
list の 5 番目の要素を返します。

  (fifth X) = (nth 4 X)

使用例：
  (fifth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 5
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>file-directory-p</title>
<type>Function</type>
<arguments>file-directory-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEがディレクトリならt、そうでなければnilを返します。

使用例：  
  (file-directory-p "C:/xyzzy/")
  =&gt; t
  (file-directory-p "C:/xyzzy/xyzzy.exe")
  =&gt; nil
  (file-directory-p "~/")
  =&gt; t
</description>
<seealso>file-exist-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-executable-p</title>
<type>Function</type>
<arguments>file-executable-p PATHNAME</arguments>
<package>lisp</package>
<description>
注）何故か実行ファイルでも、tが返らない気がする。
PATHNAMEが実行ファイルか否かを返します。

  t    実行ファイルである。
  nil  実行ファイルではない。
</description>
<seealso>file-exist-p</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-exist-p</title>
<type>Function</type>
<arguments>file-exist-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：  
  (file-exist-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-exist-p "~/")
  =&gt; t
</description>
<seealso>check-valid-pathname</seealso>
<seealso>file-readable-p</seealso>
<seealso>file-writable-p</seealso>
<seealso>file-executable-p</seealso>
<seealso>file-directory-p</seealso>
<seealso>file-write-time</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-length</title>
<type>Function</type>
<arguments>file-length PATHNAME</arguments>
<package>lisp</package>
<description>
指定されたファイルの大きさをバイト単位で返します。

  PATHNAME : ファイル名を指定します。

使用例：
  (file-length "C:/xyzzy/xyzzy.exe")
  =&gt; 977408
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-name-dialog</title>
<type>Function</type>
<arguments>file-name-dialog &amp;key :char-encoding :eol-code :filter :filter-index :title :default :extension :save :multiple :must-exist :explorer :hide-read-only :initial-directory</arguments>
<package>editor</package>
<description>
ファイルを指定するダイアログを表示します。
ユーザーが指定したファイルを返します。多値で返します。
（詳細不明）

  :char-encoding        文字コード指定プルダウンメニューを表示
  :eol-code             改行コード指定プルダウンメニューを表示
  :filter               ファイルの種類リスト
  :filter-index         （詳細不明）
  :title                ダイアログのタイトル
  :default              デフォルトのファイル名
  :initial-directory    初期表示するディレクトリ
  :extension            （詳細不明）
  :save                 non nilならファイル名を付けて保存？
  :multiple             non nilなら複数ファイル指定可
  :must-exist           non nilなら存在しないファイルを指定できない
  :explorer             （詳細不明）
  :hide-read-only       Read Onlyなファイルを表示しない？

使用例：
  ;;; タイトルをFooにして、複数選択可能なダイアログを表示する。
  (file-name-dialog :title "Foo"
                    :multiple t
                    :filter '(("すべてのファイル(*.*)" . "*.*")))
  =&gt; ("C:/applications/xyzzy/xyzzycli.exe")
</description>
<seealso>directory-name-dialog</seealso>
<seealso>open-file-dialog</seealso>
<seealso>read-directory-name</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-namestring</title>
<type>Function</type>
<arguments>file-namestring PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのファイル名の部分を返します。
  
使用例：
  (file-namestring "C:/xyzzy/xyzzy.exe")
  =&gt; "xyzzy.exe"
  (file-namestring "C:/Windows/")
  =&gt; ""

須田さんの場合：
  ;;; 須田さんは、こんなのを定義しているらしい。
  (defun file-name-directory (filename)
    (directory-namestring filename))

  (defun file-name-nondirectory (filename)
    (file-namestring filename))

  (defun file-name-sans-versions (name)
    "Return FILENAME sans backup versions or strings.
  This is a separate procedure so your site-init or startup file can
  redefine it."
    (substring name 0
             (or (string-match "\\.~[0-9]+~\\'" name)
                 (string-match "~\\'" name)
                 (length name))))
</description>
<seealso>pathname-name</seealso>
<seealso>directory-namestring</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-newer-than-file-p</title>
<type>Function</type>
<arguments>file-newer-than-file-p FILE1 FILE2</arguments>
<package>editor</package>
<description>
ファイルの最終更新日を比較します。
戻り値は以下のとおりです。

  t   file1の方が新しい、もしくはfile2が無効。
  nil file2の方が新しい、file1が無効、時間差が無い、のいずれか。
</description>
<seealso>file-write-time</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-position</title>
<type>Function</type>
<arguments>file-position FILE-STREAM &amp;optional POSITION</arguments>
<package>lisp</package>
<description>
FILE-STREAM上の現在位置を取得・変更します。
POSITIONを省略すると、FILE-STREAMの現在位置を返します。
POSITIONを指定すると、FILE-STREAMの現在位置を変更します。

  FILE-STREAM : 入出力するストリームを指定します。
  POSITION    : ストリームの先頭からの位置を指定します。
                0を基底とするインデックスです。

POSITIONには負の数値を指定することはできません。
また、ストリームの終端を越えた数値を指定すると、
その間はNUL文字が詰められます。

使用例：
  ;;; "01234567"と出力後、移動して"abc"と出力します。
  (setq foo (open "abc.txt" :direction :output))
  =&gt; #&lt;file-output stream: C:/applications/xyzzy/abc.txt&gt;
  (princ "0123456" foo)         =&gt; "0123456"
  (file-position foo 10)        =&gt; t
  (princ "abc" foo)             =&gt; "abc"
  (close foo)                   =&gt; t
</description>
<seealso>buffer-stream-point</seealso>
<seealso>buffer-stream-set-point</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-property</title>
<type>Function</type>
<arguments>file-property PATHNAME</arguments>
<package>editor</package>
<description>
PATHNAMEのファイルのプロパティを表示します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (file-property a)
  =&gt;t
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-readable-p</title>
<type>Function</type>
<arguments>file-readable-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが読み取り可能ならt、そうでなければnilを返します。

使用例：
  (file-readable-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-readable-p "~/")
  =&gt; nil
</description>
<seealso>file-writable-p</seealso>
<seealso>file-exist-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-writable-p</title>
<type>Function</type>
<arguments>file-writable-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが書き込み可能ファイルならt、そうでなければnilを返します。

使用例：  
  (file-writable-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-writable-p "~/")
  =&gt; nil
</description>
<seealso>file-readable-p</seealso>
<seealso>file-exist-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-write-time</title>
<type>Function</type>
<arguments>file-write-time FILENAME</arguments>
<package>lisp</package>
<description>
ファイルの最終更新日をユニバーサルタイム形式で返します。

  FILENAME : ファイル名を指定します。
             フルパスでなければ(default-directory)からの相対パスになります。

使用例：
  ;;; .xyzzyの最終更新日を返します。
  (file-write-time ".xyzzy")
  =&gt; 3076147256
</description>
<seealso>set-file-write-time</seealso>
<seealso>file-newer-than-file-p</seealso>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<seealso>file-exist-p</seealso>
<seealso>get-universal-time</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-calc-directory-byte-size</title>
<type>Function</type>
<arguments>filer-calc-directory-byte-size</arguments>
<package>editor</package>
<description>
ファイラにて選択したディレクトリのファイルサイズの合計を計算します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-calc-directory-size</title>
<type>Function</type>
<arguments>filer-calc-directory-size</arguments>
<package>editor</package>
<description>
ファイラにて選択したディレクトリのディスク使用量を計算します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-clear-all-marks</title>
<type>Function</type>
<arguments>filer-clear-all-marks &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてマークを全て解除します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-close</title>
<type>Function</type>
<arguments>filer-close RESULT</arguments>
<package>editor</package>
<description>
ファイラを閉じます。

  RESULT : モーダルファイラの場合、関数filerの戻り値に影響を与えます。
           （詳細不明）
</description>
<seealso>filer-cancel</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-context-menu</title>
<type>Function</type>
<arguments>filer-context-menu</arguments>
<package>editor</package>
<description>
ファイラにてコンテキストメニューを表示します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file></file>
</chapter>

<chapter>
<title>filer-count-marks</title>
<type>Function</type>
<arguments>filer-count-marks &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてマークされたファイルの数を返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します。
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-current-file-directory-p</title>
<type>Function</type>
<arguments>filer-current-file-directory-p &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルがディレクトリかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-current-file-dot-dot-p</title>
<type>Function</type>
<arguments>filer-current-file-dot-dot-p &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルが親ディレクトリを示す ".." 
であるかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-demand-reload</title>
<type>Function</type>
<arguments>filer-demand-reload</arguments>
<package>editor</package>
<description>
（詳細不明）
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-dual-window-p</title>
<type>Function</type>
<arguments>filer-dual-window-p</arguments>
<package>editor</package>
<description>
ファイラが二画面ファイラかどうかを判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-forward-line</title>
<type>Function</type>
<arguments>filer-forward-line &amp;optional ARG SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソルを次の行に移動します。

  ARG                : 指定行数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-forward-page</title>
<type>Function</type>
<arguments>filer-forward-page &amp;optional ARG SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソルを次のページに移動します。

  ARG                : 指定ページ数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-current-file</title>
<type>Function</type>
<arguments>filer-get-current-file &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルのパスを返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-directory</title>
<type>Function</type>
<arguments>filer-get-directory &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて現在表示しているディレクトリのフルパスを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-drive</title>
<type>Function</type>
<arguments>filer-get-drive &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて現在表示しているドライブを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-mark-files</title>
<type>Function</type>
<arguments>filer-get-mark-files &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてマークされたファイルのパスをリストの形で返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-sort-order</title>
<type>Function</type>
<arguments>filer-get-sort-order &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにおけるファイルの表示順を返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-text</title>
<type>Function</type>
<arguments>filer-get-text</arguments>
<package>editor</package>
<description>
一画面ファイラにて上部のファイル名の欄に書いてあるテキストを返します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-bof</title>
<type>Function</type>
<arguments>filer-goto-bof &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソルをウィンドウの先頭に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-goto-eof</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-eof</title>
<type>Function</type>
<arguments>filer-goto-eof &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソルをウィンドウの最後に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-goto-bof</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-file</title>
<type>Function</type>
<arguments>filer-goto-file STRING &amp;optional START REVERSE WILD-P</arguments>
<package>editor</package>
<description>
ファイラにてファイル名が STRING の位置にカーソルを移動します。

  STRING  : 検索するファイル名
  START   : 検索を開始する位置
     nil      先頭から
     t        現在位置から
     それ以外 現在位置の次から
  REVERSE : 探す方向
     nil      前方向
     non-nil  後方向
  WILD-P  : ワイルドカードを有効にするか
     nil      無効
     t        有効
     それ以外 有効かつ先頭一致(末尾に"*"を補う)
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-isearch</title>
<type>Function</type>
<arguments>filer-isearch &amp;optional CHAR NO-WRAP SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてインクリメンタルサーチによるカーソル移動を行います。

  CHAR               : 検索する文字。nil の時は入力されたキーを検索します。
  NO-WRAP            : 最後までいったら、最初に戻るかどうか
             nil         戻らない
             non-nil     戻る
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-left-window-p</title>
<type>Function</type>
<arguments>filer-left-window-p</arguments>
<package>editor</package>
<description>
二画面ファイラにて現在アクティブなウィンドウが左側のウィンドウか判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-left-window</title>
<type>Function</type>
<arguments>filer-left-window</arguments>
<package>editor</package>
<description>
二画面ファイラにて左側のウィンドウをアクティブにします。
</description>
<seealso>filer-right-window</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark-all</title>
<type>Function</type>
<arguments>filer-mark-all &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて現在表示しているディレクトリにあるファイル全てをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark-match-files</title>
<type>Function</type>
<arguments>filer-mark-match-files MASK &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
MASK の示す条件を満たすファイルを全てマークします。

  MASK               : マークするファイル名の条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark</title>
<type>Function</type>
<arguments>filer-mark &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-modal-p</title>
<type>Function</type>
<arguments>filer-modal-p</arguments>
<package>editor</package>
<description>
ファイラがモーダルか判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-modify-column-width</title>
<type>Function</type>
<arguments>filer-modify-column-width N D &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにおけるそれぞれのカラムの幅を変えます。

  N                  : 変更するカラム
             0           ファイル名
             1           サイズ
             2           更新日時
             3           属性
  D                  : 変更量
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-read-char</title>
<type>Function</type>
<arguments>filer-read-char</arguments>
<package>editor</package>
<description>
ファイラにてキーボードからの入力を読み込み、文字を返します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-reload</title>
<type>Function</type>
<arguments>filer-reload &amp;optional MASK SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラの画面を更新し、最新の状態にします。

  MASK               : 表示するファイルの条件を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-right-window</title>
<type>Function</type>
<arguments>filer-right-window</arguments>
<package>editor</package>
<description>
二画面ファイラにて右側のウィンドウをアクティブにします。
</description>
<seealso>filer-left-window</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-scroll-left</title>
<type>Function</type>
<arguments>filer-scroll-left &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて左方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-scroll-right</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-scroll-right</title>
<type>Function</type>
<arguments>filer-scroll-right &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて右方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-scroll-left</seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-directory</title>
<type>Function</type>
<arguments>filer-set-directory DIRECTORY &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて表示するディレクトリを DIRECTORY に変更します。

  DIRECTORY          : ディレクトリを指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-file-mask</title>
<type>Function</type>
<arguments>filer-set-file-mask MASK &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて表示する条件を指定します。

  MASK               : 表示する条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-text</title>
<type>Function</type>
<arguments>filer-set-text STRING</arguments>
<package>editor</package>
<description>
一画面ファイラのファイル名の欄に STRING をセットします。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-sort</title>
<type>Function</type>
<arguments>filer-sort ARG &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにおけるファイルの表示順を変更します。

  ARG                : 表示順を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-subscribe-to-reload</title>
<type>Function</type>
<arguments>filer-subscribe-to-reload PATH &amp;optional SUB-DIRECTORY-P</arguments>
<package>editor</package>
<description>
ファイラにて PATH を表示しているウィンドウを更新し、
最新の状態にします。

  PATH            : パスを指定します
  SUB-DIRECTORY-P : PATH のサブディレクトリを更新対象にするか否か
          nil         更新しない
          non-nil     更新する
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-swap-windows</title>
<type>Function</type>
<arguments>filer-swap-windows</arguments>
<package>editor</package>
<description>
二画面ファイラにてもう一方のウィンドウへフォーカスを移します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-toggle-all-marks</title>
<type>Function</type>
<arguments>filer-toggle-all-marks &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにて現在のディレクトリの全てのファイルについてマークされた状態と
されていない状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-toggle-mark</title>
<type>Function</type>
<arguments>filer-toggle-mark &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルについてマークされた状態とされていない
状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-viewer</title>
<type>Function</type>
<arguments>filer-viewer</arguments>
<package>editor</package>
<description>
ファイラにてカーソル位置のファイルの最初の方を見ることができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer</title>
<type>Function</type>
<arguments>filer &amp;optional PATH ALLOW-MULTIPLE-SELECT-P CAPTION DUAL-WINDOW-P MODELESSP</arguments>
<package>editor</package>
<description>
ファイラを開きます。

  PATH      : ファイラが最初に表示するディレクトリを指定します。
  ALLOW-MULTIPLE-SELECT-P
            : ファイルを複数選択可能にするかどうかを指定します。
  CAPTION   : ファイラのウィンドウのタイトルを指定します。
  DUAL-WINDOW-P
            : 二画面ファイラで開くかどうかを指定します。
  MODELESSP : モードレスダイアログでファイラを開くかどうかを指定します。
              モードレスの場合には編集しつつファイラを表示できます。

選択結果を多値で返します。

  最初の戻り値はユーザが選択したファイルのリストを返します。
  次の戻り値はOKボタンを押したらt、CANCELボタンを押したらnilを返します。

使用例：
  ;;; multiple-value-bindでファイルを受け取る。
  (multiple-value-bind (files bool)
       (filer "c:/" t "title" nil)
       (when bool
         (msgbox "~{~S~%~}" files)))
  =&gt; :ok
</description>
<seealso>*filer-primary-directory*</seealso>
<seealso>*filer-secondary-directory*</seealso>
<section>ファイラ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fill-column</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
詰め込み時の折り返しの桁数を保持します。
既定値は 72 です。

使用例:
  ;;; 既定値を 62 に変更する。
  (setq-default fill-column 62)

カレントバッファの値を変更する場合は、関数 set-fill-column
を使用します。
</description>
<seealso>auto-fill-mode</seealso>
<seealso>set-fill-column</seealso>
<seealso>fill-prefix</seealso>
<link></link>
<section>ポジション</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill-paragraph</title>
<type>Function</type>
<arguments>fill-paragraph</arguments>
<package>editor</package>
<description>
現在の段落を詰め込みます。[ESC q]
</description>
<seealso>fill-region-as-paragraph</seealso>
<seealso>fill-prefix</seealso>
<link></link>
<section>文字列</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill-region-as-paragraph</title>
<type>Function</type>
<arguments>fill-region-as-paragraph FROM TO</arguments>
<package>editor</package>
<description>
リージョンを 1 つの段落として詰め込みます。
詰め込み桁数は、変数 fill-column が参照されます。
</description>
<seealso>fill-paragraph</seealso>
<seealso>fill-region</seealso>
<seealso>fill-column</seealso>
<link></link>
<section>リージョン</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill-region-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
fill-region/fill-paragraphの最後で実行されます。
</description>
<seealso>auto-fill-hook</seealso>
<link></link>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>fill-region</title>
<type>Function</type>
<arguments>fill-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の各段落に対し、詰め込みを行います。

使用例:
  ;;; バッファ全体を詰め込み
  (fill-region (point-min) (point-max))
</description>
<seealso>fill-paragraph</seealso>
<seealso>fill-region-as-paragraph</seealso>
<seealso>fill-column</seealso>
<link></link>
<section>リージョン</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill</title>
<type>Function</type>
<arguments>fill SEQUENCE ITEM &amp;key :start :end</arguments>
<package>lisp</package>
<description>
SEQUENCEのそれぞれをITEMに置換えます。元のSEQUENCEは置き換えられます。

使用例：
  ;;; シーケンスを作って、変更してみる。
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  =&gt; "aaaaaaaa"
  (fill foo #\b :start 3 :end 4)
  =&gt; "aaabaaaa"
  foo
  =&gt; "aaabaaaa"
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-buffer</title>
<type>Function</type>
<arguments>find-buffer BUFFER-NAME</arguments>
<package>editor</package>
<description>
名前がBUFFER-NAMEなバッファが存在すればそのバッファを返します。
存在しなければnilを返します。

使用例：
  (find-buffer "*scratch*")
  =&gt; #&lt;buffer: *scratch*&gt;
  (find-buffer "*hoge hoge*")
  =&gt; nil
</description>
<seealso>find-name-buffer</seealso>
<seealso>get-file-buffer</seealso>
<seealso>get-buffer-create</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-file-in-archive</title>
<type>Function</type>
<arguments>find-file-in-archive ARCNAME FILENAME</arguments>
<package>editor</package>
<description>
アーカイブからファイルを展開して開きます。

  ARCNAME  : アーカイブを指定します。
  FILENAME : 展開するファイルを指定します。

使用例：
  (find-file-in-archive "C:/foo/bar.lzh" "hoge/fuga.txt")
</description>
<seealso>extract-archive</seealso>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-file-other-window</title>
<type>Function</type>
<arguments>find-file-other-window FILENAME &amp;optional ENCODING NOMSG</arguments>
<package>editor</package>
<description>
指定されたファイルを別のウィンドウで開きます。[C-x 4 f]
</description>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-file</title>
<type>Function</type>
<arguments>find-file FILENAME &amp;optional ENCODING NOMSG</arguments>
<package>editor</package>
<description>
指定されたファイルを開き、カレントバッファをこのファイルにします。 [C-x C-f]
インタラクティブに呼び出すとファイル名をミニバッファで尋ねます。
プレフィックスアーギュメント付きで呼び出すと、ファイルの文字
コードを指定して開くことができます。

  FILENAME : ファイル名、またはファイル名のリストです。
  ENCODING : ファイルの文字コードを指定します。
  NOMSG    : non-nil でステータスバーに状況などを出力しなくなります。
</description>
<seealso>find-other-file</seealso>
<seealso>find-file-other-window</seealso>
<seealso>ed::find-file-internal</seealso>
<seealso>*prefix-args*</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-if-not</title>
<type>Function</type>
<arguments>find-if-not PREDICATE SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものがあればそれを返します。なければ
nilを返します。
</description>
<seealso>find</seealso>
<seealso>find-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-if</title>
<type>Function</type>
<arguments>find-if PREDICATE SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものがあればそれを返します。なければnilを返します。
</description>
<seealso>find</seealso>
<seealso>find-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-load-path</title>
<type>Function</type>
<arguments>find-load-path FILENAME</arguments>
<package>lisp</package>
<description>
*load-path*からファイルを検索しそのフルパスを返します。

使用例：
  (find-load-path "wip/ftp.l")
  =&gt; "C:/APPLICATIONS/XYZZY/lisp/wip/ftp.l"
  (find-load-path "siteinit.l")
  =&gt; "C:/APPLICATIONS/XYZZY/site-lisp/siteinit.l"
</description>
<seealso>*load-path*</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-other-file</title>
<type>Function</type>
<arguments>find-other-file FILENAME &amp;optional ENCODING NOMSG</arguments>
<package>editor</package>
<description>
現在のバッファを閉じて指定されたファイルを開きます。[C-x C-v]

互換性：
  muleにはなさそう。
</description>
<seealso>*find-other-file-requires-file-name*</seealso>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-package</title>
<type>Function</type>
<arguments>find-package NAME</arguments>
<package>lisp</package>
<description>
パッケージを名前で検索して、そのパッケージを返します。

  NAME : パッケージの名前

使用例：
  ;;; lispとsystemパッケージを取得してみる。
  (find-package "lisp")
  =&gt; #&lt;package: lisp&gt;
  (find-package "si")
  =&gt; #&lt;package: system&gt;

  ;;; "baz"という名のパッケージは存在しない
  (find-package "baz")
  =&gt; nil
</description>
<seealso>パッケージ</seealso>
<seealso>list-all-packages</seealso>
<seealso>defpackage</seealso>
<seealso>delete-package</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-symbol</title>
<type>Function</type>
<arguments>find-symbol STRING &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージ中にシンボルが登録されているかを調べます。

  STRING  : シンボルの名前
  PACKAGE : パッケージの名前

戻り値は多値で返されます。

  nil     シンボルが見つからなかった場合はnilを返します。
  nil以外 シンボルが見つかった場合はそのシンボルをそのまま返します。

使用例：
  ;;; find-fileとfind-file-internalというシンボルを調べてみる。
  (find-symbol "find-file" "lisp")
  =&gt; nil
     nil
  (find-symbol "find-file" "editor")
  =&gt; find-file
     :external
  (find-symbol "find-file-internal" "editor")
  =&gt; editor::find-file-internal
     :internal
</description>
<seealso>intern</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-text-attribute-point</title>
<type>Function</type>
<arguments>find-text-attribute-point POINT</arguments>
<package>editor</package>
<description>
POINT の位置のテキストの属性を多値で返します。

  FROM          属性を付加された開始位置
  TO            属性を付加された終了位置
  TAG           個々の属性を区別するタグ
  FOREGROUND    文字色
  BACKGROUND    背景色
  BOLD          ボールド
  UNDERLINE     下線付き
  STRIKE-OUT    取り消し線
  PREFIX        不明
  EXTEND        不明

使用例：
  ;;; my-tagというタグ名で領域を緑色に設定
  (set-text-attribute (point-min) (point-max) 'my-tag :foreground 2)
  =&gt; t
  ;;; カーソル位置にタグがあれば赤色かつボールドに変更
  (multiple-value-bind (from to tag foreground background bold underline strike-out prefix extend)
      (find-text-attribute-point 1)
    (when tag
      (modify-text-attributes tag ; foregroundとbold以外はそのまま設定する。
       :foreground 1              ; 赤色に設定
       :background background
       :bold t                    ; ボールドに設定
       :underline underline
       :strike-out strike-out
       :prefix prefix
       :extend extend)))
  =&gt; t
</description>
<seealso>modify-text-attributes</seealso>
<seealso>find-text-attribute</seealso>
<seealso>delete-text-attribute-point</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-text-attribute</title>
<type>Function</type>
<arguments>find-text-attribute TAG &amp;key :start :end :from-end :test :test-not :key</arguments>
<package>editor</package>
<description>
set-text-attributeで指定したタグを検索します。

(progn
  (set-text-attribute 1 6 'my-tag 1)
  (multiple-value-bind (from to tag)
      (find-text-attribute 'my-tag)
    (format t "~d, ~d, ~A" from to tag)))
==&gt; 1, 6, my-tag

| 2. set-text-attribute で、複数範囲に同一 tag を指定した場
|    合、find〜 は一番先頭に近いものしか返さない(ところしか
|    見たことがない)のですが、二番目以降を取得することはで
|    きますでしょうか？

find-text-attribute TAG :start POS

で、POS に現在位置+1を与えれば次のが返ってくる予定です。
使ったことないので動くかどうか分かりませんが。

| 3. find-text-attribute の &amp;key 引数は、何か意味を持ってい
|    ますでしょうか？

シーケンスと同様に、:test と :test-not には比較関数を
与えます。また、:key にはアクセス関数(か?)を与えます。
たとえば、tag の形式が

  ("foo" bar)

である場合、

  (find-text-attribute "foo" :test #'equal :key #'car)

とか、

  (find-text-attribute 'bar :test #'eq :key #cadr)

で検索することができる予定です。使ったことないので動く
かどうか分かりませんが。

:test-not は、関数が nil を返した場合に真とする以外は :
test と同様です。:test と :test-not は同時に指定するこ
とはできず、省略した場合は :test #'eql が与えられたも
のとします。また :key を省略した場合は :key #'identity 
が与えられたものとします(たぶん)。
</description>
<seealso>find-text-attribute-if</seealso>
<seealso>find-text-attribute-if-not</seealso>
<seealso>find-text-attribute-point</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find</title>
<type>Function</type>
<arguments>find ITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCE の中で ITEM との :test を満たすものがあればそれを返します。なければ
nilを返します。

使用例：
  ;;; リストから'aを探してみる。
  (find 'a '(e c a b))
  =&gt; a
</description>
<seealso>find-if</seealso>
<seealso>find-if-not</seealso>
<seealso>position</seealso>
<seealso>member</seealso>
<seealso>getf</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>first-error</title>
<type>Function</type>
<arguments>first-error &amp;optional ARG WRAP</arguments>
<package>editor</package>
<description>
grep後の*compilation*バッファ上で実行すると、該当行へジャンプ可能です。[F10]
以後は、next-error([F11], [C-x `])を押すことで次々と該当行へジャンプ可能です。
各種コンパイラの出力結果に応じてジャンプすることも可能です。
また、コンパイラのエラー出力が標準に対応していなくても、
*error-regexp-list*を変更することで対応が可能な場合があります。
</description>
<seealso>next-error</seealso>
<seealso>*error-regexp-list*</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>first</title>
<type>Function</type>
<arguments>first LIST</arguments>
<package>lisp</package>
<description>
carの別名です。
全く同じ動きをします。

使用例：
  ;;; carと同じ動きをする。
  (car '(1 2 3))
  =&gt; 1
  (first '(1 2 3))
  =&gt; 1
  (symbol-function 'car)
  =&gt; #&lt;function: car&gt;
  (symbol-function 'first)
  =&gt; #&lt;function: car&gt;
 
参考：
  ;;; list.lの定義
  (si:*fset 'first #'car)
</description>
<seealso>car</seealso>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>flet</title>
<type>Special Form</type>
<arguments>flet ({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*</arguments>
<package>lisp</package>
<description>
ローカルな関数を定義してフォームを評価します。フォーム内で flet で
定義された関数は、外部で定義された同じ名前の関数よりも優先されます。
関数は同時に複数定義できます。

それぞれの定義方法は defun のように、最初に関数名、
次にパラメータのリスト(&amp;optional, &amp;rest, &amp;key パラメータも使えます)、
そしてoptional declaration と docstring、そして最後にフォームと続きます。

  (flet ((safesqrt (x) (sqrt (abs x)))) 
    ;; The safesqrt function is used in two places. 
    (safesqrt (apply #'+ (map 'list #'safesqrt longlist))))
</description>
<seealso>labels</seealso>
<seealso>macrolet</seealso>
<link></link>
<section>関数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>float</title>
<type>Function</type>
<arguments>float NUMBER &amp;optional OTHER</arguments>
<package>lisp</package>
<description>
任意の型の数値を浮動小数点型に変換します。

  (float 'NUMBER) == (coerce 'NUMBER 'single-float)

使用例：
  ;;; integerをfloatに変換する。
  (setq var 0)                  =&gt; 0
  (type-of var)                 =&gt; integer
  (setq var (float var))        =&gt; 0.0
  (type-of var)                 =&gt; single-float
</description>
<seealso>rationalize</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>floatp</title>
<type>Function</type>
<arguments>floatp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがfloatならt、それ以外ならnilを返します。
</description>
<seealso>numberp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>floor</title>
<type>Function</type>
<arguments>floor NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを負の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBERを越えない最大の整数になります。

使用例：  
  (floor 2.2)
  =&gt; 2
  (floor 2.8)
  =&gt; 2
  (floor -2.4)
  =&gt; -3  
  (multiple-value-list (floor 2.2))
  =&gt; (2 0.2)
</description>
<seealso>ceiling</seealso>
<seealso>truncate</seealso>
<seealso>round</seealso>
<seealso>ffloor</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fmakunbound</title>
<type>Function</type>
<arguments>fmakunbound SYMBOL</arguments>
<package>lisp</package>
<description>
指定されたシンボルの関数定義からの束縛を解消します。
これ以降fboundpはnilを返すようになります。値と関数定義の束縛は独立してい
るので、fmakunboundをしてもboundpの結果は変わりません。

使用例：
  ;;; 関数定義への束縛を解消してみる。
  (defun foo (x) (* x 3))       =&gt; foo
  (fboundp 'foo)                =&gt; t
  (fmakunbound 'foo)            =&gt; foo
  (fboundp 'foo)                =&gt; nil
</description>
<seealso>fboundp</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>focus-tool-bar</title>
<type>Function</type>
<arguments>focus-tool-bar</arguments>
<package>editor</package>
<description>
タブバーにフォーカスを移します。タブバーからはTABを押すことで元のバッフ
ァに戻ることが出来ます。タブバーが存在しないときは、フォーカスは元のバッ
ファのままです。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>following-char</title>
<type>Function</type>
<arguments>following-char</arguments>
<package>editor</package>
<description>
カーソルがある位置のキャラクタを返します。
バッファの末尾にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; "長崎市"の'崎'の上にカーソルがある場合
  (following-char)
  =&gt; #\崎

  ;;; [EOF]にカーソルがある場合
  (following-char)
  =&gt; #\NUL
</description>
<seealso>preceding-char</seealso>
<seealso>char-after</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>format-date-string</title>
<type>Function</type>
<arguments>format-date-string FMT &amp;optional UNIVERSAL-TIME</arguments>
<package>editor</package>
<description>
書式に従って整形した日時を文字列として返します。

  FMT            : 日付用の書式文字列を指定します。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。

使用例：
  (format-date-string "%y/%m/%d %H:%M:%S" 3112500590)
  =&gt; "98/08/19 16:29:50"
  (format-date-string "%y年%#m月%#d日(%v)")
  =&gt; "99年11月10日(水)"

日付用の書式：
  書式文字については timestmp.l を参照して下さい。以下は抜粋です。 
  a: 短い形式の曜日
  A: 長い形式の曜日
  b: 短い形式の月
  B: 長い形式の月
  d: 日(00〜31)                 # (0〜31)
  e: 和暦の年(01〜)             # (1〜)
  E: 和暦の年(元, 02〜)         # (元, 2〜)
  g: 元号(明治,大正,昭和,平成)  # (明,大,昭,平)
  G: 元号(M, T, S, H)
  H: 時(00〜23)                 # (0〜23)
  I: 12時間の時(01〜12)         # (1〜12)
  i: Internet Time(000〜999)
  m: 月(01〜12)                 # (1〜12)
  M: 分(00〜59)                 # (0〜59)
  p: 午前/午後
  P: AM/PM                      # am/pm
  S: 秒(00〜59)                 # (0〜59)
  v: 曜日(日本語)
  y: 年(2桁)
  Y: 年(4桁)
  z: タイムゾーン名(JST-9)
  Z: タイムゾーン(+0900)        # (+09:00)
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date</seealso>
<section>日付・時間</section>
<file>timestmp.l</file>
</chapter>

<chapter>
<title>format-date</title>
<type>Function</type>
<arguments>format-date S FMT &amp;optional UNIVERSAL-TIME</arguments>
<package>editor</package>
<description>
書式に従って整形した日時をストリームに出力します。

  S              : 出力ストリームを指定します。
                   formatの様にtやnilを指定することはできません。
  FMT            : 日付用の書式文字列を指定します。
                   日付用の書式文字列はformat-date-stringを参照して下さい。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>timestmp.l</file>
</chapter>

<chapter>
<title>format-drive</title>
<type>Function</type>
<arguments>format-drive &amp;optional DRIVE QUICK</arguments>
<package>editor</package>
<description>
ドライブをフォーマットします。

  DRIVE : ドライブを文字で指定します。

使用例：
  (format-drive #\a t)
  =&gt; nil
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>format</title>
<type>Function</type>
<arguments>format DESTINATION CONTROL-STRING &amp;rest ARGUMENTS</arguments>
<package>lisp</package>
<description>
出力書式に従って出力します。

  DESTINATION : 出力先を指定します。
        t       標準出力に出力
        nil     文字列として結果を返す
        fp      指定のストリームに出力

  CONTROL-STRING : 以下の出力指定子で整形します。
        ~A      Ascii（アスキー指示）。princタイプで出力。
        ~S      S-Expression（S式指示）。prin1タイプで出力。
        ~%      改行。~n%はn個の改行
        ~&amp;      出力ストリームが行頭でなければ改行。fresh-line参照。
        ~|      改ページ
        ~~      Tilde（チルダ指示）
        ~改行   改行とそれに続く空白文字を無視する
        ~T      Tabulate（タブ指示）
        ~*      次のargumentを無視
        ~?      Indirection（間接指示）
        ~D      10進数
        ~B      Binary（2進指示）
        ~O      Octal（8進指示）
        ~X      Hexadecimal（16進指示）
        ~R      Radix（基数指示）
        ~P      Plural（複数形指示）
        ~C      Character（文字指示）
        ~F      Fixed-format floating-point（固定小数点形式浮動小数指示）
        ~E      Exponential floating-point（指数形式浮動小数指示）
        ~G      General floating-point（一般浮動小数点指示）
        ~$      Dollars floating-point（ドル浮動小数点指示）
        ~(      Case conversion（ケース変換指示）
        ~)      ~(を閉じる
        ~[      Conditional expression（条件選択指示）
        ~]      ~[を閉じる
        ~{      Iteration（反復指示）
        ~}      ~{を閉じる
        ~^      Up and out（ゼロ終了指示）

使用例:
  ;;; 整数に0を付けて出力 ("~[最小桁数][,パディング文字][,桁区切り文字]D")
  (format nil "~5,'0D" 4)
  =&gt; "00004"

  ;;; 整数を3桁ごとにカンマで区切って出力
  (format nil "~:D" 1234567890)
  =&gt; "1,234,567,890"

  ;;; 文字列を最低桁カラムになるように空白を追加して出力
  (format nil "~10A" "foo")
  =&gt; "       foo"
  (format nil "~10@A" "foo")
  =&gt; "foo       "

  ;;; ケース変換の例
  (format nil "~(~A~)" "FOO BAR")  ;全て小文字
  =&gt; "foo bar"
  (format nil "~:(~A~)" "foo bar") ;単語の先頭の文字を大文字
  =&gt; "Foo Bar"
  (format nil "~@(~A~)" "foo bar") ;先頭の文字を大文字
  =&gt; "Foo bar"
  (format nil "~:@(~A~)" "foo bar");全て大文字
  =&gt; "FOO BAR"

  ;;; 間接指示の例
  (format nil "~? ~D" "[~A ~D]" '("foo" 2) 3)
  =&gt; "[foo 2] 3"
  (format nil "~@? ~D" "[~A ~D]" "foo" 2 3)
  =&gt; "[foo 2] 3"

  ;;; 条件選択指示の例
  (format nil "Windows ~[NT~;98~;95~]" 0)
  =&gt; "Windows NT"
  (format nil "Windows ~[NT~;98~;95~]" 1)
  =&gt; "Windows 98"
  ;デフォルト値 "~:;"
  (format nil "Windows ~[NT~;98~;95~:;3.1~]" 5)
  =&gt; "Windows 3.1"

  ;;; 反復指示の例
  ; "~{" 引数はリスト
  (format nil "~{ ~A~}" '("dog" "cat" "pig"))
  =&gt; " dog cat pig"
  ; "~:{"  引数はリストのリスト
  (format nil "~:{[~A ~D]~}" '(("a" 1) ("b" 2) ("c" 3)))
  =&gt; "[a 1][b 2][c 3]"
  ; "~@{" 残りの引数をリストとして用いる
  (format nil "~@{[~A ~D]~}" "a" 1 "b" 2 "c" 3)
  =&gt; "[a 1][b 2][c 3]"
  ; "~@:{" 引数のリストをリストとして用いる
  (format nil "~:@{[~A ~D]~}" '("a" 1) '("b" 2) '("c" 3))
  =&gt; "[a 1][b 2][c 3]"

  ;;; ゼロ終了指示の例
  ;引数がなければ終了
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P.")
  =&gt; "Done."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3)
  =&gt; "Done. 3 warnings."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3 5)
  =&gt; "Done. 3 warnings. 5 errors."

  ;;; 反復指示とゼロ終了指示
  ;副リストの中の引数がもうなければ "~{" をそこで閉じる
  (format nil "~:{/~S~^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger/ice .../french ..."
  ;リストが終わりならそこで ":{" 全体を終了
  (format nil "~:{/~S~:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger .../ice .../french"
  ;副リストの中の引数がもうなければ全体を終了
  (format nil "~:{/~S~#:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger"

  ;;; 16進数のformat書式の書き方
  (format nil "~2,'0x" 10)
  =&gt; "0a"
  (format nil "~:@(~2,'0x~)" 10)
  =&gt; "0A"
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-char</title>
<type>Function</type>
<arguments>forward-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
指定された文字数だけ右に移動します。改行があれば次行に移動します。
[C-f], [Right]

互換性： 
  Emacsでは移動できない場合エラーが発生します。xyzzyではエラーは発生し
  ません。その代わり、動けたときは t、動けなければ nil を返します。
</description>
<seealso>backward-char</seealso>
<seealso>*prefix-args*</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-line</title>
<type>Function</type>
<arguments>forward-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行後に物理行に移動します。
移動の前後で goal-column を保存しません。

戻り値:
  移動した行数を返します。全く移動できなかったときは nil です。
</description>
<seealso>previous-line</seealso>
<seealso>forward-virtual-line</seealso>
<seealso>next-line</seealso>
<seealso>*prefix-args*</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-paragraph</title>
<type>Function</type>
<arguments>forward-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを段落の末尾に移動します。[ESC }]
</description>
<seealso>backward-paragraph</seealso>
<link></link>
<section>ポジション</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>forward-sexp</title>
<type>Function</type>
<arguments>forward-sexp &amp;optional ARG NO-ERRORS</arguments>
<package>editor</package>
<description>
lisp-modeでS式を1つ進めます。[ESC C-f]

使用例：
  (forward-sexp)
</description>
<seealso>backward-sexp</seealso>
<seealso>up-list</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-word</title>
<type>Function</type>
<arguments>forward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを前方の単語に移動します。[ESC f]
</description>
<seealso>backward-word</seealso>
<seealso>forward-char</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fourth</title>
<type>Function</type>
<arguments>fourth X</arguments>
<package>lisp</package>
<description>
cadddr の別名です。全く同じ動きをします。
</description>
<seealso>cadddr</seealso>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>fresh-line</title>
<type>Function</type>
<arguments>fresh-line &amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAM が行の先頭ではないときだけ改行 (#\LFD) を出力します。
</description>
<seealso>terpri</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fround</title>
<type>Function</type>
<arguments>fround NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
round と同じですが浮動小数点数を返します。
</description>
<seealso>round</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ftruncate</title>
<type>Function</type>
<arguments>ftruncate NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
truncateと同じですが浮動小数点数を返します。
</description>
<seealso>truncate</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>funcall</title>
<type>Function</type>
<arguments>funcall FN &amp;rest ARGUMENTS</arguments>
<package>lisp</package>
<description>
引数を指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が静的に定まら
ない場合にはfuncallは向いていないので、その場合にはapplyを使います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                =&gt; a
  (funcall 'car '(a b c))       =&gt; a
  (funcall #'car '(a b c))      =&gt; a

注意：
  funcallやapply等の様に関数を引数とする標準の関数は、carがlambdaの式や
  シンボルを内部的に関数に変換します。従って、関数を表すシンボルでも関数
  そのものでも構いません。
</description>
<seealso>apply</seealso>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>function</title>
<type>Special Form</type>
<arguments>function FN</arguments>
<package>lisp</package>
<description>
関数の関数定義を返します。#'と同じです。

使用例：
  ;;; #'とfunctionとsymbol-functionを比べてみる。
  (defun foo (x) (* x 3))
  =&gt; foo
  #'foo
  =&gt; #&lt;lexical-closure: foo&gt;
  (function foo)
  =&gt; #&lt;lexical-closure: foo&gt;
  (symbol-function 'foo)
  =&gt; #&lt;lexical-closure: foo&gt;
</description>
<seealso>symbol-function</seealso>
<seealso>quote</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>functionp</title>
<type>Function</type>
<arguments>functionp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが関数ならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gc</title>
<type>Function</type>
<arguments>gc &amp;optional NO-MESSAGE</arguments>
<package>lisp</package>
<description>
（多分）ゴミ集めをします。
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gcd</title>
<type>Function</type>
<arguments>gcd &amp;rest INTEGERS</arguments>
<package>lisp</package>
<description>
引数の最大公約数を返します。

使用例：
  (gcd 91 70)
  =&gt; 7
  (gcd 63 -42 35)
  =&gt; 7
  (gcd -3)
  =&gt; -3
  (gcd 35 8)
  =&gt; 1
</description>
<seealso>lcm</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-alternate-file-name</title>
<type>Function</type>
<arguments>get-buffer-alternate-file-name &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファBUFFERに設定されたファイル名の別名を取得します。
</description>
<seealso>set-buffer-alternate-file-name</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-create</title>
<type>Function</type>
<arguments>get-buffer-create NAME</arguments>
<package>editor</package>
<description>
指定した名前のバッファを返します。名前を指定しますが、同じ名前のバッファ
が既にあればそれを返します。無ければcreate-new-bufferで新しく作ります。

switch-to-bufferも良く似た動きをしますが、switch-to-bufferは
get-buffer-createを用いて実装されています。

  NAME : バッファの名前

使用例：
  ;;; *calc*がなければ作成する。
  (get-buffer-create "*calc*")
  =&gt; #&lt;buffer: *calc*&gt;
</description>
<seealso>create-new-buffer</seealso>
<seealso>find-buffer</seealso>
<seealso>new-file</seealso>
<seealso>switch-to-buffer</seealso>
<seealso>バッファの内部構造</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>get-buffer-file-name</title>
<type>Function</type>
<arguments>get-buffer-file-name &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが参照しているファイルのフルパスを返します。
ファイルを参照していなければnilを返します。

  BUFFER : ファイルのフルパスを返すバッファを指定します。

使用例：
  ;;; カレントバッファのファイルのフルパスを返します。
  (get-buffer-file-name)
  =&gt; "C:/xyzzy/site-lisp/xmldoc/reference.xml"
</description>
<seealso>set-buffer-file-name</seealso>
<seealso>get-file-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-window</title>
<type>Function</type>
<arguments>get-buffer-window BUFFER &amp;optional START-WINDOW</arguments>
<package>editor</package>
<description>
バッファを表示しているウィンドウを返します。同じバッファが複数のウィンド
ウに表示されていますので、START-WINDOWから順番に探し始めます。
現在表示されてないバッファはnilが返ります。

  BUFFER       : 検索するバッファ
  START-WINDOW : 検索をし始めるウィンドウ

使用例：
  ;;; window-bufferも使ってみる。
  (selected-buffer)
  =&gt; #&lt;buffer: *scratch*&gt;
  (window-buffer (get-buffer-window (selected-buffer)))
  =&gt; #&lt;buffer: *scratch*&gt;
</description>
<seealso>window-buffer</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-clipboard-data</title>
<type>Function</type>
<arguments>get-clipboard-data</arguments>
<package>editor</package>
<description>
クリップボードの内容を文字列として取り出します。
</description>
<seealso>copy-to-clipboard</seealso>
<seealso>clipboard-empty-p</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-decoded-time</title>
<type>Function</type>
<arguments>get-decoded-time</arguments>
<package>lisp</package>
<description>
現在の時間を多値で返します。
  
  (get-decoded-time) == (decode-universal-time (get-universal-time))
  
使用例：
  (multiple-value-list (get-decoded-time))
  =&gt; (55 35 14 17 11 1999 2 nil -9)
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-disk-usage</title>
<type>Function</type>
<arguments>get-disk-usage DIRECTORY &amp;optional RECURSIVEP</arguments>
<package>editor</package>
<description>
指定されたディレクトリの容量を取得します。

  DIRECTORY  : 情報を取得するディレクトリを指定します。
  RECURSIVEP : サブディレクトリも再帰的にチェックするかを指定します。

戻り値は多値で返します。

  1 ブロックサイズ（バイト）
  2 全ディスク容量（バイト）
  3 空きディスク容量（バイト）
  4 ブロック単位の合計（バイト）
  5 ファイルサイズを単純に加算した合計（バイト）
  6 調べたディレクトリの個数
  7 調べたファイルの個数

使用例：
  (defun my-folder-size (my-dir)
    (interactive "Dfolder name: ")
    (let (my-dir-list (my-total-size  0))
      (setq my-dir-list (directory my-dir
                                   :wile "*.*"
                                   :absolute t
                                   :file-only t
                                   :recursive t
                                   :show-dots nil))
      (dolist (f my-dir-list)
        (setq my-total-size (+ my-total-size (file-length f))))
      (msgbox (format nil "フォルダの使用容量は、~d バイトです。"
                      my-total-size))))
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-attributes</title>
<type>Function</type>
<arguments>get-file-attributes PATHNAME</arguments>
<package>editor</package>
<description>
ファイルの属性を返します。ファイルサイズや最終更新日などの情報も一括して取
得したい場合には、get-file-infoを使用しましょう。

  PATHNAME : 属性を取得するファイル名を指定します。

戻り値は以下の値の合計で表されます。

  ed::*file-attribute-readonly*   : 読み取り専用
  ed::*file-attribute-hidden*     : 隠しファイル
  ed::*file-attribute-system*     : システムファイル
  ed::*file-attribute-directory*  : ディレクトリ
  ed::*file-attribute-archive*    : アーカイブ
  ed::*file-attribute-compressed* : 圧縮

使用例：
  ;;; c:\autoexec.batの属性を取得してみる。多分アーカイブになっているので
  ;;; ed::*file-attribute-archive*との論理積が0以外になる。
  (get-file-attributes "c:/autoexec.bat")
  =&gt; 32
  (= (get-file-attributes "c:/autoexec.bat") ed::*file-attribute-archive*)
  =&gt; t
</description>
<seealso>get-file-info</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-buffer</title>
<type>Function</type>
<arguments>get-file-buffer FILENAME</arguments>
<package>editor</package>
<description>
ファイルを表示しているバッファを返します。
なければnilを返します。

使用例：  
  (get-file-buffer "not-documented.xml")
  =&gt; #&lt;buffer: not-documented.xml&gt;
</description>
<seealso>get-buffer-file-name</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-info</title>
<type>Function</type>
<arguments>get-file-info PATHNAME</arguments>
<package>editor</package>
<description>
ファイルの属性をまとめて取得します。属性・最終更新日・サイズ・短い
名前のリストの形式です。属性は以下の感じで。
  ed::*file-attribute-readonly*
  ed::*file-attribute-hidden*
  ed::*file-attribute-system*
  ed::*file-attribute-directory*
  ed::*file-attribute-archive*
  ed::*file-attribute-compressed*

使用例：
  (setq i (get-file-info (si:system-root)))
  =&gt; (16 3208385786 0 "XYZZY")
  (logand (car i) ed::*file-attribute-directory*)
  =&gt; 16
  (logand (car i) ed::*file-attribute-hidden*)
  =&gt; 0
  (format-date-string "%y/%m/%d %H:%M:%S" (cadr i))
  =&gt; "01/09/02 11:16:26"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-internal-real-time</title>
<type>Function</type>
<arguments>get-internal-real-time</arguments>
<package>lisp</package>
<description>
内部的にGetTickCountを呼び出しています。GetTickCountはMSDNによると
システムを起動した後の経過時間を、ミリ秒（ms）単位で取得します。
この時間は、システムタイマの分解能による制限を受けます。
システムを 49.7 日間連続して動作させると、経過時間は 0 に戻ります。

だそうです。

使用例：  
  ;;普通に呼び出す。整数が帰ってくる
  (get-internal-real-time)
  =&gt;984001406

  ;;書式付で起動時間を表示
  (let ((tick (get-internal-real-time))
        d h m s ms)
    (multiple-value-setq (tick ms)
        (truncate tick 1000))
    (multiple-value-setq (tick s)
        (truncate tick 60))
    (multiple-value-setq (tick m)
        (truncate tick 60))
    (multiple-value-setq (d h)
        (truncate tick 24))
    (format nil "PC起動経過時間 day ~D time ~2,'0D:~2,'0D:~2,'0D.~3,'0D" d h m s ms))
  =&gt;"PC起動経過時間 day 11 time 09:20:04.578"
</description>
<seealso>internal-time-units-per-second</seealso>
<seealso>si:performance-counter</seealso>
<link></link>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-menu-position</title>
<type>Function</type>
<arguments>get-menu-position MENU TAG</arguments>
<package>editor</package>
<description>
メニューの中からタグの位置を検索して返します。

  MENU : 検索するメニューを指定します。
  TAG  : 検索するタグを指定します。

見つからなかった場合にはnilが返されます。
見つかった場合にはその位置とそれを含むメニューを返します。
</description>
<seealso>get-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-menu</title>
<type>Function</type>
<arguments>get-menu MENU TAG-OR-POSITION &amp;optional TAG-OR-POSITION-P</arguments>
<package>editor</package>
<description>
指定されたメニューから、タグ名または位置で検索したメニューを取得します。

  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置と
                      して解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
使用例：
  (get-menu *app-menu* 3 t)
</description>
<seealso>current-menu</seealso>
<seealso>get-menu-position</seealso>
<seealso>define-menu</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-properties</title>
<type>Function</type>
<arguments>get-properties PLACE INDICATOR-LIST</arguments>
<package>lisp</package>
<description>
2番目の引数がリストになっているgetfです。
一致すると多値で値を返します。

使用例：
  ;;; get-propertiesで値を取得してみる。
  (get-properties '(ind1 10 ind2 20 ind3 30) '(ind2))
  =&gt; ind2
     20
     (ind2 20 ind3 30)
</description>
<seealso>getf</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-selection-type</title>
<type>Function</type>
<arguments>get-selection-type</arguments>
<package>editor</package>
<description>
バッファの選択状態を返します。

  nil   選択なし、
  1     行モード選択状態
  2     文字モード選択状態
  3     矩形選択状態
</description>
<seealso>set-selection-type</seealso>
<seealso>start-selection</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-short-path-name</title>
<type>Function</type>
<arguments>get-short-path-name PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEの8.3形式でのパスを返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (get-short-path-name a)
  =&gt;"C:/APPLIC~2/xyzzy/xyzzy.exe"
</description>
<seealso>truename</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-special-folder-location</title>
<type>Function</type>
<arguments>get-special-folder-location PLACE</arguments>
<package>editor</package>
<description>
いろいろなフォルダへのパスを返します。

  PLACE : フォルダの種類を指定します。
    :start-menu
    :send-to
    :desktop
    :personal
    :programs
    :recent
    :startup
    :templates

参考：
  WindowsAPIのGetSpecialFolderLocation
</description>
<seealso>get-windows-directory</seealso>
<seealso>get-system-directory</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-system-directory</title>
<type>Function</type>
<arguments>get-system-directory</arguments>
<package>editor</package>
<description>
Windowsシステムフォルダまでのパスを返す。

使用例：
  (get-system-directory)
  =&gt; "C:/WINDOWS/System32/"
</description>
<seealso>get-windows-directory</seealso>
<seealso>get-special-folder-location</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-universal-time</title>
<type>Function</type>
<arguments>get-universal-time</arguments>
<package>lisp</package>
<description>
現在の時間を返します。

使用例：
  (get-universal-time)
  =&gt; 3151806404
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<seealso>file-write-time</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-window-handle</title>
<type>Function</type>
<arguments>get-window-handle &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたウィンドウのハンドルを返します。

  WINDOW : ハンドルを返すウィンドウを指定します。

使用例：
  ;;; カーソルがあるウィンドウのハンドルを返します。
  (get-window-handle (selected-window))
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-windows-directory</title>
<type>Function</type>
<arguments>get-windows-directory</arguments>
<package>editor</package>
<description>
Windowsフォルダへのパスを返します。

使用例：
  (get-windows-directory)
  =&gt; "C:/WINDOWS/"
</description>
<seealso>get-system-directory</seealso>
<seealso>get-special-folder-location</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get</title>
<type>Function</type>
<arguments>get SYMBOL INDICATOR &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
シンボルのプロパティを返します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジケータ

使用例：
  ;;; シンボルにプロパティを設定してみる。
  (get 'clyde 'species)                         =&gt; nil 
  (setf (get 'clyde 'species) 'elephant)        =&gt; elephant 
  (get 'clyde 'species)                         =&gt; elephant

  ;;; 関数の説明を取得してみる。
  (defun foo (x) "increment" (1+ x))            =&gt; foo
  (get 'foo 'lisp::function-documentation)      =&gt; "increment"
</description>
<seealso>symbol-plist</seealso>
<seealso>remprop</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>getf</title>
<type>Function</type>
<arguments>getf PLACE INDICATOR &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
インジケータと値のリストから、インジケータに一致する値を取得します。

  (get x y) == (getf (symbol-plist x) y)

使用例：
  ;;; 実用性は無いけれどgetfを使って取得してみる。
  (getf '(ind1 10 ind2 20 ind3 30) 'ind2)
  =&gt; 20
</description>
<seealso>get-properties</seealso>
<seealso>symbol-plist</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gethash-region</title>
<type>Function</type>
<arguments>gethash-region FROM TO HASHTABLE &amp;optional DEFAULT</arguments>
<package>editor</package>
<description>
リージョンの文字列をハッシュテーブルから取得します。
(buffer-substring FROM TO)してから(gethash ... HASHTABLE)するようなものです。
</description>
<seealso>gethash</seealso>
<link></link>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gethash</title>
<type>Function</type>
<arguments>gethash KEY HASH-TABLE &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの中からキーが一致するものを返します。

  KEY        : 検索するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setq hash-table (make-hash-table))
  =&gt; #&lt;hashtable :test eql :size 0/17 9900500&gt;
  (gethash 'a hash-table)
  =&gt; nil
  (setf (gethash 'a hash-table) 1)
  =&gt; 1
  (gethash 'a hash-table)
  =&gt; 1

  (setq h (make-hash-table :test #'equalp))
  (setf (gethash "body" h) '(a b c))
  (gethash "BODY" h)
</description>
<seealso>gethash-region</seealso>
<seealso>maphash</seealso>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>global-set-key</title>
<type>Function</type>
<arguments>global-set-key KEY COMMAND</arguments>
<package>editor</package>
<description>
グローバルなキーマップにキーを登録します。

使用例：
 (global-set-key #\C-r          'previous-page)
 (global-set-key #\S-Left       'selection-backward-char)
 (global-set-key #\S-C-Left     'selection-backward-word)
</description>
<seealso>global-unset-key</seealso>
<seealso>define-key</seealso>
<seealso>local-set-key</seealso>
<seealso>undefined</seealso>
<seealso>*global-keymap*</seealso>
<seealso>キー表現使用可能文字</seealso>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>global-unset-key</title>
<type>Function</type>
<arguments>global-unset-key KEY</arguments>
<package>editor</package>
<description>
グローバルなキーマップのキーの割り当てを解除します。

使用例：
  ;;; global-set-keyで割り当てたキーを解除してみる。
  (global-set-key #\C-r 'previous-page)
  =&gt; t
  (global-unset-key #\C-r)
  =&gt; t
</description>
<seealso>global-set-key</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>goal-column</title>
<type>Function</type>
<arguments>goal-column</arguments>
<package>editor</package>
<description>
現在のゴールカラムを取得します。
[xyzzy:06371] あたりのスレッドを見ると、save-excursionでゴールカラムが保
存されないのは仕様のようです。
</description>
<seealso>set-goal-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-bol</title>
<type>Function</type>
<arguments>goto-bol</arguments>
<package>editor</package>
<description>
行頭に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。
</description>
<seealso>goto-eol</seealso>
<seealso>goto-virtual-bol</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-char</title>
<type>Function</type>
<arguments>goto-char POINT</arguments>
<package>editor</package>
<description>
指定された位置にカレントバッファのカーソルを移動します。
この位置はpoint, point-min, point-max等のポイントを返す関数を
使用することで得ることが可能です。

  POINT: バッファ上の位置です。整数またはマーカーを利用できます。
         移動できる最小の位置は point-min で取得でき、これよりも小さい
         値を指定した時は point-min の位置に移動します。
         移動できる最大の位置は point-max で取得でき、これよりも大きい
         値を指定した時は point-max の位置に移動します。

戻り値：
  mule では、POINT が返されますが、 xyzzy では常に t です。 
</description>
<seealso>point-min</seealso>
<seealso>point-max</seealso>
<seealso>what-cursor-position</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-column</title>
<type>Function</type>
<arguments>goto-column COLUMN &amp;optional EXCEED-P</arguments>
<package>editor</package>
<description>
指定された桁位置に移動します。移動した後の桁位置を返します。
current-line-columns が返す値よりも大きな値を指定した場合には、行の終端に
位置します。負の数を指定した場合には、行の先頭に位置します。

  COLUMN : 桁数
</description>
<seealso>goto-virtual-column</seealso>
<seealso>current-virtual-column</seealso>
<seealso>current-line-columns</seealso>
<seealso>goto-line</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-eol</title>
<type>Function</type>
<arguments>goto-eol</arguments>
<package>editor</package>
<description>
行末に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。
</description>
<seealso>goto-bol</seealso>
<seealso>goto-virtual-line</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-line</title>
<type>Function</type>
<arguments>goto-line LINE</arguments>
<package>editor</package>
<description>
指定された行番号にジャンプします。折り返しを有効にしていて表示行にジャン
プしたい場合には、goto-virtual-lineを使用します。[ESC g]
</description>
<seealso>goto-virtual-line</seealso>
<seealso>goto-char</seealso>
<seealso>goto-column</seealso>
<seealso>goto-bol</seealso>
<seealso>goto-eol</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-marker</title>
<type>Function</type>
<arguments>goto-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーのポジションへポイントを移動します。
goto-char と違い、ポイント（数字）を引数として受け取ることはできません。
</description>
<seealso>set-marker</seealso>
<seealso>goto-char</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-matched-parenthesis</title>
<type>Function</type>
<arguments>goto-matched-parenthesis &amp;optional ARG</arguments>
<package>editor</package>
<description>
ポイントに存在するキャラクタが、syntax-open-pもしくはsyntax-close-pを満
たす場合に、対応するキャラクタに移動します。対応する各種括弧に移動するの
に使われます。[ESC ]]
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-virtual-bol</title>
<type>Function</type>
<arguments>goto-virtual-bol</arguments>
<package>editor</package>
<description>
表示行の行頭に移動します。
※実際の表示が表示行／物理行には依存しません。
</description>
<seealso>goto-bol</seealso>
<seealso>goto-virtual-eol</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-virtual-column</title>
<type>Function</type>
<arguments>goto-virtual-column COLUMN &amp;optional EXCEED-P</arguments>
<package>editor</package>
<description>
指定された表示桁へ移動します。

  COLUMN   : 移動する表示桁位置を指定します。
  EXCEED-P : （詳細不明）

表示桁が折り返しの桁位置よりも大きいときは、折り返しの桁位置で止まります。
※実際の表示が表示行／物理行には依存しません。
</description>
<seealso>goto-column</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-virtual-eol</title>
<type>Function</type>
<arguments>goto-virtual-eol</arguments>
<package>editor</package>
<description>
表示行の行末に移動します。
※実際の表示が表示行／物理行には依存しません。
</description>
<seealso>goto-eol</seealso>
<seealso>goto-virtual-bol</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-virtual-line</title>
<type>Function</type>
<arguments>goto-virtual-line LINE</arguments>
<package>editor</package>
<description>
表示行での指定行に移動します。
ウィンドウの表示行／物理行の切替は、「共通設定」−「表示」−「行番号は表示行(D)」
で行います。

参考：
  ファイルイメージ： 
    001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRSTU
    005| ABCDEFGHIJKLMNOPQRSTUV

                    │
      ┌──────┴──────┐
      ↓                          ↓

  物理行：                        表示行：                      
    001| ABCDEFGHIJKLMNOPQR         001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS        002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST       003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRST       004| ABCDEFGHIJKLMNOPQRST
       | U                          005| U
    005| ABCDEFGHIJKLMNOPQRST       006| ABCDEFGHIJKLMNOPQRST
       | UV                         007| UV
</description>
<seealso>goto-line</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>handler-case</title>
<type>Macro</type>
<arguments>handler-case FORM &amp;rest CASES</arguments>
<package>lisp</package>
<description>
例外をキャッチします。
詳細はエラー処理関連を参照してください。キャッチした例外は
si:*condition-stringで対応する文字列を取得できるようです。

  (handler-case
    例外が発生しそうな処理
    (エラーのシンボル1 (仮引数1) エラー処理1)     
    (エラーのシンボル2 (仮引数2) エラー処理2)     
    (エラーのシンボル3 (仮引数3) エラー処理3))

例えば、例外が発生しそうな処理で(error エラーシンボル2)が起きると、途中
の処理をすっとばして、エラー処理2が実行されます。そこで対応出来れば処理
を継続しますが、対応できなければ(error 仮引数2)を実行して、より上位の
handler-caseに対応をお願いします。どこまでいっても対応できなければ、
xyzzyがエラーダイアログを出して処理を終了します。

使用例：
  ;;; 例外が出ても、個々に対応しつつ処理を継続する場合
  ;;; with-output-to-stringを使ってるのは変数が煩わしいから
  (with-output-to-string (out)
    (dolist (i '((6 3) (6 0) (6 "a")))
      (handler-case
          (/ (car i) (cadr i))
        (division-by-zero (c)
          (format out "division-by-zero: ~a~%" (si:*condition-string c)))
        (error (c)
          (format out "error:\t ~a~%" (si:*condition-string c))))))
  =&gt; "division-by-zero: 0で除算しました: /: (6 0)
      error:     不正なデータ型です: \"a\": number"
</description>
<seealso>ignore-errors</seealso>
<seealso>trap-errors</seealso>
<seealso>unwind-protect</seealso>
<seealso>error</seealso>
<seealso>エラー処理関係</seealso>
<section>エラー</section>
<file>handler.l</file>
</chapter>

<chapter>
<title>hash-table-count</title>
<type>Function</type>
<arguments>hash-table-count HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの要素数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<seealso>hash-table-size</seealso>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-p</title>
<type>Function</type>
<arguments>hash-table-p OBJECT</arguments>
<package>lisp</package>
<description>
オブジェクトがハッシュテーブルかどうかを返します。

  OBJECT : 判定するオブジェクトを指定します。

  (hash-table-p x) == (typep x 'hash-table)
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-rehash-size</title>
<type>Function</type>
<arguments>hash-table-rehash-size HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの現在のrehash-sizeを返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-rehash-threshold</title>
<type>Function</type>
<arguments>hash-table-rehash-threshold HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの現在のrehash-thresholdを返します。

  HASH-TABLE : ハッシュテーブルを指定します。

補足：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-size</title>
<type>Function</type>
<arguments>hash-table-size HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの現在の大きさを返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<seealso>hash-table-count</seealso>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-test</title>
<type>Function</type>
<arguments>hash-table-test HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルのキーを比較する関数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (hash-table-test hash-table)
  =&gt; eql
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hide-command-bar</title>
<type>Function</type>
<arguments>hide-command-bar SYM</arguments>
<package>editor</package>
<description>
define-command-barで定義したコマンドバーを非表示にします。
</description>
<seealso>show-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>hide-restricted-region</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
narrow-to-regionした領域を非表示にするか薄く表示するかを制御します。

  t   : 非表示にします。
  nil : 薄く表示します。
</description>
<seealso>narrow-to-region</seealso>
<link></link>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>hide-tool-bar</title>
<type>Function</type>
<arguments>hide-tool-bar NAME</arguments>
<package>editor</package>
<description>
ツールバーNAMEを非表示にします。
</description>
<seealso>show-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>if</title>
<type>Special Form</type>
<arguments>if TEST THEN [ELSE]</arguments>
<package>lisp</package>
<description>
いわゆるIF文を実行します。
TESTがnon nilならTHENを実行。nilならELSEを実行します。

構文：
  (if TEST THEN [ELSE])
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ignore-errors</title>
<type>Macro</type>
<arguments>ignore-errors &amp;body BODY</arguments>
<package>lisp</package>
<description>
本体を評価したときに発生するエラーを全て無視します。
エラーが発生した場合には、ignore-errorsはnilとそのコンディションを多値で
返します。

C++の場合：
  try {
    return resolve_shortcut("c:\\autoexec.bat");
  } catch (...) {
    return nil;
  }

xyzzyの場合：
  (ignore-errors  (resolve-shortcut "c:/autoexec.bat"))
  =&gt;nil
  =&gt;#S(file-error pathname "c:/autoexec.bat" datum ショートカットではありません)
</description>
<seealso>trap-errors</seealso>
<seealso>handler-case</seealso>
<seealso>unwind-protect</seealso>
<seealso>エラー処理関係</seealso>
<section>エラー</section>
<file>handler.l</file>
</chapter>

<chapter>
<title>ignored-extensions</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファでの入力補完において、ignored-extensionsの拡張子がついたファ
イルは補完の対象になりません。

使用例：
  ; exeとdllは入力補完しない
  (setq ignored-extensions '("exe" "dll"))
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>cosh</title>
<type>Function</type>
<arguments>cosh Z</arguments>
<package>lisp</package>
<description>
双曲線余弦関数を計算します。 
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>imagpart</title>
<type>Function</type>
<arguments>imagpart NUMBER</arguments>
<package>lisp</package>
<description>
複素数の虚数部を取得します。

使用例：
  (setq a (complex 1 3))
  =&gt;#C(1 3)

  (imagpart a)
  =&gt;3
</description>
<seealso>realpart</seealso>
<seealso>complex</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ime-push-composition-string</title>
<type>Function</type>
<arguments>ime-push-composition-string &amp;optional NODELETE</arguments>
<package>editor</package>
<description>
セレクションの確定済仮名文字を非確定状態にします。[C-c C-p]
</description>
<seealso>rewind-ime-composition</seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>ime-register-word-dialog</title>
<type>Function</type>
<arguments>ime-register-word-dialog</arguments>
<package>editor</package>
<description>
単語/用例登録ダイアログを表示します。[C-c C-r]
セレクションがあれば、セレクションの文字列を語句とします。
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>import</title>
<type>Function</type>
<arguments>import SYMBOLS &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
シンボルのリストを指定して、その全てのシンボルをパッケージ内でパッケージ
名指定なしでアクセスできるようにします。シンボルが既にパッケージ内に存在
する場合は例外を発生します。
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>in-package</title>
<type>Macro</type>
<arguments>in-package NAME</arguments>
<package>lisp</package>
<description>
どのパッケージで実行するかを変更します。変更した後に作られたシンボルは、
指定されたパッケージに登録されます。

使用例：
    ;;; これ以降新しく作られるシンボルは、"editor"パッケージに登録さ
    ;;; れるようになる。
    (in-package "editor")
</description>
<seealso>use-package</seealso>
<seealso>パッケージ</seealso>
<seealso>*package*</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>incf</title>
<type>Macro</type>
<arguments>incf PLACE &amp;optional (DELTA 1)</arguments>
<package>lisp</package>
<description>
変数をインクリメントします。

使用例：
  ;;; 変数xの値をインクリメントする。
  (setq x 1)    =&gt; 1
  (incf x)      =&gt; 2
  x             =&gt; 2
</description>
<seealso>decf</seealso>
<section>数値</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>indent-region</title>
<type>Function</type>
<arguments>indent-region FROM TO</arguments>
<package>editor</package>
<description>
mode-specific-indent-commandがnon-nilならば、指定のリージョンを
mode-specific-indent-commandで一行ずつインデントします。
行末はdelete-trailing-spacesで空白を削除されます。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>indent-to</title>
<type>Function</type>
<arguments>indent-to COLUMN</arguments>
<package>editor</package>
<description>
指定された桁数までインデントします。現在のカーソル位置が引数より小さけれ
ばスペースを挿入します。そうでなければ何もしません。

  COLUMN : インデントする桁数を指定します。

戻り値は以下のとおりです。

  t   インデントした場合
  nil 何もしなかった場合
</description>
<seealso>indent-relative</seealso>
<seealso>smart-indentation</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-buffer-substring</title>
<type>Function</type>
<arguments>insert-buffer-substring BUFFER &amp;optional FROM TO</arguments>
<package>editor</package>
<description>
指定されたバッファの内容を現在のバッファに挿入します。
リージョンが指定されていればその領域を挿入します。
</description>
<seealso>insert-buffer</seealso>
<seealso>insert</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>insert-buffer</title>
<type>Function</type>
<arguments>insert-buffer BUFFER</arguments>
<package>editor</package>
<description>
指定されたバッファの内容を現在のバッファに挿入します。
</description>
<seealso>insert-buffer-substring</seealso>
<seealso>insert-file</seealso>
<seealso>insert-file-contents</seealso>
<seealso>insert</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>insert-file-contents</title>
<type>Function</type>
<arguments>insert-file-contents FILENAME &amp;optional VISIT-P OFFSET SIZE</arguments>
<package>editor</package>
<description>
ファイルの内容をカーソル位置に挿入します。

  FILENAME : 挿入するファイル名
  VISIT-P  : ファイルを挿入後の動作を指定します。
        t       変更フラグ・UNDO情報のクリア、ファイルの日付の変更等を行います。
        nil     特に何もしません。
  OFFSET   : 挿入するオフセット
  SIZE     : 挿入する長さ

使用例：
  ;;; 簡単なテンプレートの挿入例
  ;;; site-lisp/template.lを用意しておくこと
  (defun insert-template ()
    (and (get-buffer-file-name)
         (not (file-exist-p (get-buffer-file-name)))
         (insert-file-contents (merge-pathnames "site-lisp/template.l" (si:system-root)) t)
         (message "template inserted")))
  =&gt; insert-template
  (add-hook '*lisp-mode-hook* 'insert-template)
  =&gt; (insert-template lisp-load-keyword-file)
</description>
<seealso>insert-file</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-file</title>
<type>Function</type>
<arguments>insert-file FILENAME &amp;optional ENCODING</arguments>
<package>editor</package>
<description>
指定されたファイルをカーソルの位置に読み込みます。[C-x i]
</description>
<seealso>insert-file-contents</seealso>
<seealso>insert-buffer</seealso>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>insert-menu-item</title>
<type>Function</type>
<arguments>insert-menu-item MENU POSITION TAG ITEM &amp;optional COMMAND INIT</arguments>
<package>editor</package>
<description>
メニュー項目を作成しメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。必要なければnilを指定します。
  ITEM     : メニューに表示される名前を指定します。
  COMMAND  : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT     : メニューが開く直前に評価し返される値によってメニューの状態
             を設定します。詳細はadd-menu-itemを参照して下さい。
</description>
<seealso>add-menu-item</seealso>
<seealso>get-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-menu-separator</title>
<type>Function</type>
<arguments>insert-menu-separator MENU POSITION &amp;optional TAG</arguments>
<package>editor</package>
<description>
セパレータをメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。
</description>
<seealso>add-menu-separator</seealso>
<seealso>define-menu</seealso>
<seealso>define-popup-menu</seealso>
<seealso>get-menu</seealso>
<seealso>get-menu-position</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-popup-menu</title>
<type>Function</type>
<arguments>insert-popup-menu MENU POSITION POPUP-MENU MENU-NAME</arguments>
<package>editor</package>
<description>
ポップアップメニューをメニューの所定の位置に挿入します。

  MENU       : 追加先のメニューを指定します。
  POSITION   : 挿入する位置を指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (insert-popup-menu *app-menu* 2 *app-popup-menu* "編集2(&amp;E)")
  =&gt; #&lt;menu 48701736&gt;
</description>
<seealso>add-popup-menu</seealso>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert</title>
<type>Function</type>
<arguments>insert &amp;rest STRING-OR-CHAR</arguments>
<package>editor</package>
<description>
文字列をバッファに挿入します。

  STRING-OR-CHAR : 挿入する文字列を指定します。
                   &amp;restで受けられているので何個でもOKです。

履歴：
  xyzzyのバージョン0.0.0.45.1よりまえのバージョンでは
  Emacsとinsertの仕様が、やや異なっていました。

  ;;; Emacsの場合
  (insert "abc" "def" "ghi")
  =&gt; "abcdefghi"が挿入される

  ;;; xyzzyの場合
  (insert "ab" 4)
  =&gt; "abababab"が挿入される

  xyzzyのバージョン0.0.0.45.1以降、Emacsとのinsert互換性が高まって
  います。

  (insert "foo")         =&gt; foo          ; 今までと同じ
  (insert "foo" 2)       =&gt; foofoo       ; 今までと同じ
  (insert "foo" "bar")   =&gt; foobar       ; Emacsと同じ
  (insert "foo" "bar" 2) =&gt; foobarfoobar
  (insert #\f "o" #\o)   =&gt; foo          ; Emacsと同じ
  (insert #\f "o" #\o 2) =&gt; foofoo
  (insert 2)             =&gt; エラー
  (insert "foo" 2 "bar") =&gt; エラー
  (insert 102 111 111)   =&gt; エラー       ; Emacsは  =&gt; foo
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>integerp</title>
<type>Function</type>
<arguments>integerp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがintegerならt、それ以外ならnilを返します。

  (integerp x) == (typep x 'integer)
</description>
<seealso>numberp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>interactive-p</title>
<type>Function</type>
<arguments>interactive-p</arguments>
<package>editor</package>
<description>
実行中の関数が interactive に呼ばれていればt、そうでなければnilを返します。

使用例：
  ;;; fooとbarという関数を定義して、fooをinteractiveに呼び出してみる。
  ;;; fooはinteractive扱いされているが、barはそうでない。
  (defun foo () (interactive) (msgbox "foo: ~A" (interactive-p)) (bar))
  =&gt; foo
  (defun bar () (interactive) (msgbox "bar: ~A" (interactive-p)))
  =&gt; bar
  M-x: foo
  =&gt; [foo: t]
     [bar: nil]
</description>
<seealso>commandp</seealso>
<seealso>interactive</seealso>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>interactive</title>
<type>Special Form</type>
<arguments>interactive {INTERACTIVE-STRING {PARAMETER}*|LIST}</arguments>
<package>editor</package>
<description>
関数が対話的に実行可能であること、すなわちコマンドであることを宣言します。
このフォームを定義に含む関数は対話的に実行できます。
対話的に実行とは具体的には
・キーバインドでの実行
・M-x (execute-extended-command) での実行
・ツールバーでの実行
などです。

実行に引数が必要でない関数では必要ありませんが、引数を与えなければならな
い関数の場合は、INTERACTIVE-STRINGによって対話的に実行したときに関数に渡
す引数の値やその与え方を制御する必要があります。
INTERACTIVE-STRINGの構成は以下のようになります。
  *             任意。書込み禁止バッファでの実行を禁止します。
  0             任意。プロンプトに数引数がつきます。
  指定子        引数に与えるデータとその与え方の指定になります。
  任意の文字列  ミニバッファで引数を与えるときのプロンプトになります。
  \n            区切り文字です。続けて次の引数についての記述ができます。

PARAMETERでは指定子に対する設定を記述できます。
 :defaultN      初期表示
 :historyN      履歴情報
 :titleN        ダイアログのタイトル
Nの部分には何番目の指定子に対する設定かという数値が入ります。
例えば最初の指定子に対する初期表示の指定は:default0で行います。
:defaultNと:titleNで指定するのは文字列、
:historyNで指定するのはminibuffer-history-variableプロパティを持つシンボルです。
履歴のデータはそのプロパティ値が使用されます。minibuf.l参照。

以下、指定子とその動作です。

  {属性}
   P: Prompt       ミニバッファでユーザー入力
   M: Must Match   正しく入力されるまで繰り返す
   C: Completion   入力候補表示・補完あり
   D: Default      :defaultN使用可能
   H: History      :historyN使用可能
   T: Title        :titleN使用可能

  [最終変換値]
  {xx}    - 関数には xxx 型の値がくる
  {xx/yy} - 入力値が省略又は未定義値だと、yy型がくる
  {xx|yy} - 入力値が多重値だと、yy の型でくる
  {*****} - なんでもあり

        {PMCDHT}
  a     {PMCDH }[symbol]        関数名
  B     {P CDH }[buffer/string] バッファ名
  b     {PMCDH }[buffer]        既存のバッファ名
  c     {P     }[character]     文字
  C     {PMCDH }[symbol]        コマンド名
  d     {      }[integer]       ポイント位置
  D     {PMCDHT}[string]        ディレクトリ名
  e     {P CDH }[string]        実行ファイル
  F     {P CDHT}[string]        ファイル名
  f     {PMCDHT}[string]        既存のファイル名
  l     {P CDHT}[string|cons]   ファイル名(複数可)
  M     {      }[integer]       セレクション開始位置
  m     {      }[integer]       マーク位置
  n     {PM    }[integer]       整数
  N     {PM    }[integer]       整数(前置引数を優先)
  p     {      }[integer]       前置引数の値
  P     {      }[symbol/nil]    生の前置引数
  R     {      }[integer]       セレクション範囲(一つ目がセレクションの始点、二つ目がセレクションの終点)
  r     {      }[integer]       リージョン(一つ目がマーク位置、二つ目がポイント位置)
  s     {P  DH }[string]        文字列
  S     {PMCDH }[symbol]        シンボル
  v     {PMCDH }[symbol]        変数名
  X     {P     }[*****]         S式(引数には評価した値が渡される)
  x     {P     }[*****]         S式そのもの
  z     {PMC H }[encoding]      文字エンコーディング
  Z     {PMC H }[encoding]      文字エンコーディング(自動判定を除く)
 
新たに任意の指定子を作成することもできます。
*interactive-specifier-alist*に指定子にあたる文字と処理の関数シンボルを
登録します。keymap.lを参照。

また、LISTにて指定子に依らない任意の動作をさせることもできます。
cmds.lのrepeat-complex-commandの定義などを参照。

備考:
・0zと0Zという指定は特別に、前置引数が与えられたときのみミニバッファで入
  力待ちになるという動作になります。
・PARAMETERで:emacsにnon-nilを指定するとemacsとの互換性を考慮した動作に
  なります。
</description>
<seealso>commandp</seealso>
<seealso>long-operation</seealso>
<seealso>*prefix-args*</seealso>
<seealso>read-buffer-name</seealso>
<seealso>read-char-encoding</seealso>
<seealso>read-command-name</seealso>
<seealso>read-directory-name</seealso>
<seealso>read-exist-buffer-name</seealso>
<seealso>read-exist-file-name</seealso>
<seealso>read-file-name-list</seealso>
<seealso>read-file-name</seealso>
<seealso>read-function-name</seealso>
<seealso>read-integer</seealso>
<seealso>read-sexp</seealso>
<seealso>read-string</seealso>
<seealso>read-symbol-name</seealso>
<seealso>read-variable-name</seealso>
<link></link>
<section>関数</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>intern</title>
<type>Function</type>
<arguments>intern STRING &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
文字列からシンボルを作成します。作成したシンボルは指定されたパッケージに
internされます。make-symbolも文字列からシンボルを作り出しますが、パッケ
ージにinternされません。

  STRING  : 文字列
  PACKAGE : 作成したシンボルを登録するパッケージ

使用例：
  ;;; foobarというシンボルが*package*に登録される
  (intern "foobar")
  =&gt; foobar

  ;;; foobazというシンボルがlispパッケージに登録される。
  (intern "foobaz" (find-package "lisp"))
  =&gt; foobaz
</description>
<seealso>find-symbol</seealso>
<seealso>symbol-name</seealso>
<seealso>unintern</seealso>
<seealso>make-symbol</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>isqrt</title>
<type>Function</type>
<arguments>isqrt INTEGER</arguments>
<package>lisp</package>
<description>
整数の平方根を整数で返します。

 (isqrt INTEGER) == (floor (sqrt INTEGER))

使用例：
  ;;; 143と144のisqrtを計算する。
  (isqrt 143)
  =&gt; 11
  (isqrt 144)
  =&gt; 12
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kana-char-p</title>
<type>Function</type>
<arguments>kana-char-p CHAR</arguments>
<package>editor</package>
<description>
文字が半角カナ文字かを返します。

  t    半角カナ文字である。
  nil  半角カナ文字でない。

カナ文字は以下の範囲です。
  Code          Char
  ----          ----
  0xa1 .. 0xb0  #\｡ .. #\ｰ
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ
  0xde          #\ﾞ
  0xdf          #\ﾟ
</description>
<seealso>kanji-char-p</seealso>
<seealso>characterp</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kanji-char-p</title>
<type>Function</type>
<arguments>kanji-char-p CHAR</arguments>
<package>editor</package>
<description>
文字CHARが漢字かを返します。
（詳細不明）
</description>
<seealso>kana-char-p</seealso>
<seealso>characterp</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kept-undo-information</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
undo 可能回数を指定する変数です。

  &lt;integer&gt; : 指定回数分の undo 情報を保持します。
  上記以外  : undo 情報を保持しません。(undo できません。)

使用例：
  ;;; 現在開いているファイルではundoできないようにします。
  (make-local-variable 'kept-undo-information)
  =&gt; t
  (setq kept-undo-information nil)
  =&gt; nil
</description>
<seealso>undo</seealso>
<seealso>undo-boundary</seealso>
<seealso>clear-undo-boundary</seealso>
<seealso>setup-temp-buffer</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>keymapp</title>
<type>Function</type>
<arguments>keymapp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがキーマップかを返します。

  non-nil   OBJECTはキーマップ
  nil       OBJECTはキーマップではない
</description>
<seealso>make-keymap</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>keywordp</title>
<type>Function</type>
<arguments>keywordp OBJECT</arguments>
<package>lisp</package>
<description>
与えられたオブジェクト OBJECT がキーワードか否かを返します。 OBJECT がシ
ンボルであり、かつ keyword パッケージに所属するときに t を返しているよう
です。

  (symbol-package 'a)
  =&gt;#&lt;package: user&gt;
  (symbol-package :a)
  =&gt;#&lt;package: keyword&gt;
  
  (symbolp 'a)
  =&gt;t
  (keywordp 'a)
  =&gt;nil
  
  (symbolp :a)
  =&gt;t
  (keywordp :a)
  =&gt;t
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-all-buffers</title>
<type>Function</type>
<arguments>kill-all-buffers &amp;optional NOT-VERBOSE</arguments>
<package>editor</package>
<description>
全バッファをkill-bufferします。
NOT-VERBOSEで保存するか否かを指定できます。

  NOT-VERBOSE :
        t       何も確認せずに保存しようとします。
        nil     変更があるバッファは確認のダイアログ表示されます。
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>kill-all-local-variables</title>
<type>Function</type>
<arguments>kill-all-local-variables</arguments>
<package>editor</package>
<description>
全てのローカル変数が現在のバッファで独自の値を持てないようにします。
setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        =&gt; abc
  (setq abc 456)                =&gt; 456
  abc                           =&gt; 456
  (kill-all-local-variables)    =&gt; t
  abc                           =&gt; 123
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-buffer</title>
<type>Function</type>
<arguments>kill-buffer BUFFER</arguments>
<package>editor</package>
<description>
バッファを削除します。[C-x k]
ただし、kill-bufferはバッファが変更されていると削除していいかどうか聞
いてきます。マクロ中で使う際には、delete-bufferを使ったほうがいいでし
ょう。(ユーザに聞かずにいきなり削除します）

また、*query-kill-buffer-hook*にフック関数を設定すると、独自の用件でバ
ッファの破棄を確認できます。

使用例：
  ;;; 現在のバッファを削除する。
  (kill-buffer (selected-buffer))
  =&gt; t
</description>
<seealso>delete-buffer</seealso>
<seealso>deleted-buffer-p</seealso>
<seealso>kill-selected-buffer</seealso>
<seealso>*query-kill-buffer-hook*</seealso>
<seealso>*kill-buffer-kills-scratch*</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>kill-line</title>
<type>Function</type>
<arguments>kill-line &amp;optional LINES</arguments>
<package>editor</package>
<description>
行をkillします。 killした行は *kill-ring* へ追加されます。 [C-k]
連続して kill-line を実行することで、複数行を一括して
*kill-ring* へ追加することができます。

  LINES 
     nil  : ポイントが行末ならば、その位置の改行コードをkillします。
            ポイントが行末でなければ、その行の行末までkillします。
       0  : ポイントが行頭ならば、前行の行頭までkillします。
            ポイントが行頭でなければ、その行の行頭までkillします。
     その他の整数 : 指定された行数 kill します。 
</description>
<seealso>*kill-ring*</seealso>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>kill-local-variable</title>
<type>Function</type>
<arguments>kill-local-variable SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLが現在のバッファで独自の値を持てない様にします。
kill-local-variableを実行した後では、SYMBOLの値はグローバルなSYMBOLの値
になります。setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        =&gt; abc
  (setq abc 456)                =&gt; 456
  abc                           =&gt; 456
  (kill-local-variable 'abc)    =&gt; t
  abc                           =&gt; 123
</description>
<seealso>kill-all-local-variables</seealso>
<seealso>make-local-variable</seealso>
<seealso>make-variable-buffer-local</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-paragraph</title>
<type>Function</type>
<arguments>kill-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
現在のパラグラフの最後までkillします。
</description>
<seealso>kill-region</seealso>
<seealso>backward-kill-paragraph</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>kill-process</title>
<type>Function</type>
<arguments>kill-process PROCESS</arguments>
<package>editor</package>
<description>
プロセスを強制的に終了させます。
</description>
<seealso>kill-subprocess</seealso>
<seealso>signal-process</seealso>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-rectangle-selection-to-clipboard</title>
<type>Function</type>
<arguments>kill-rectangle-selection-to-clipboard</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域を削除した後、クリップボードにコ
ピーします。
</description>
<seealso>kill-rectangle-selection</seealso>
<seealso>copy-rectangle-selection-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-rectangle-selection</title>
<type>Function</type>
<arguments>kill-rectangle-selection</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をkillします。
yankにはyank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
killした内容は*kill-ring*ともクリップボードとも違う領域に格納されているようです。
</description>
<seealso>copy-rectangle-selection</seealso>
<seealso>kill-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso><link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-rectangle</title>
<type>Function</type>
<arguments>kill-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1とP2で指定される矩形領域をkillします。
killした矩形領域のyankには、yank-rectangleを使います。
通常の*kill-ring*とは別の領域に格納されているようです。
</description>
<seealso>delete-rectangle</seealso>
<seealso>kill-region</seealso>
<seealso>kill-rectangle-selection</seealso>
<seealso>*rectangle-kill-buffer*</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>kill-region-to-clipboard</title>
<type>Function</type>
<arguments>kill-region-to-clipboard FROM TO</arguments>
<package>editor</package>
<description>
FROMとTOで指定される領域を削除したのち、クリップボードにコピーします。
</description>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>kill-region</title>
<type>Function</type>
<arguments>kill-region FROM TO</arguments>
<package>editor</package>
<description>
リージョンをkill ringに入れます。 [C-w]

--- kill ringのいい加減な説明 ---
kill-regionした文字列は、*kill-ring*の先頭に追加されます。*kill-ring*は
最大で*kill-ring-max*（標準で16）まで保持できます。最大を越えたら古いも
のから破棄されます。

        *kill-ring*
        ┌─────┐  ─┐
        │"defun"   ←─── kill-regionした内容
        ├──↓──┤    │
        │"length"  │    │
        ├──↓──┤    ├最大*kill-ring-max*個
        │"test"    │    │
        ├──↓──┤    │
        │...       │    │
        └─────┘  ─┘

普通はkill[C-k]してyank[C-y]したら、*kill-ring*の先頭のものしか貼り付け
られませんが、killした直後にyank-pop[M-y]を繰り返すと、*kill-ring*の要素
を順次貼り付けてくれます。
</description>
<seealso>copy-region-as-kill</seealso>
<seealso>kill-selection</seealso>
<seealso>zap-to-char</seealso>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>kill-selected-buffer</title>
<type>Function</type>
<arguments>kill-selected-buffer</arguments>
<package>editor</package>
<description>
名前のとおりselected-bufferをkill-bufferします。

参考：
  ;;; buffer.l
  (defun kill-selected-buffer ()
    (interactive)
    (kill-buffer (selected-buffer)))
</description>
<seealso>kill-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>kill-selection-to-clipboard</title>
<type>Function</type>
<arguments>kill-selection-to-clipboard</arguments>
<package>editor</package>
<description>
セレクションを削除し、クリップボードに転送します。[C-Delete]
矩形選択状態であれば、 kill-rectangle-selection-to-clipboard
を実行します。
</description>
<seealso>kill-region-to-clipboard</seealso>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-selection</title>
<type>Function</type>
<arguments>kill-selection</arguments>
<package>editor</package>
<description>
選択された領域を切り取り、*selection-ring*の先頭に追加します。 [F7]
追加した内容はyank-selectionで貼り付けられます。
</description>
<seealso>yank-selection</seealso>
<seealso>copy-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-subprocess</title>
<type>Function</type>
<arguments>kill-subprocess</arguments>
<package>editor</package>
<description>
バッファに結び付けられているプロセスを停止させます。[C-c C-k]
</description>
<seealso>kill-process</seealso>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>kill-word</title>
<type>Function</type>
<arguments>kill-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から前方の単語の末尾までを切り取り、キルリングに追加します。
[ESC d] または [ESC h]
カーソルが単語の途中にある場合は、カーソル位置からその単語の末尾までが、
対象となります。
</description>
<seealso>backward-kill-word</seealso>
<seealso>kill-region</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>lambda</title>
<type>Misc</type>
<arguments>lambda LAMBDA-LIST [[{DECLARATION}* | DOCUMENTATION]] {FORM}*</arguments>
<package>lisp</package>
<description>
関数に名前を付ける必要がなく、手続きだけを記述したい場合にラムダ式
を用います。ラムダ式の二番目の引数はラムダリストと呼ばれ、関数の
パラメータの名前を与えます。lambda式のより完全な構文は以下です。

(lambda ({var}*
         [&amp;optional {var | (var [initform [svar]])}*]
         [&amp;rest var]
         [&amp;key {var | ({var | (keyword var)} [initform [svar]])}*]
         [&amp;aux {var | (var [initform])}*])
   [[{declaration}* | documentation-string]]
   {form}*)

引数がラムダ式によって表される関数に適用されると、form が評価
されて最後の form の結果が返されます。form は順に評価されます。

((lambda (x y) (+ x y)) 10 20)        =&gt; 30

ラムダリストの各要素は、パラメータ指定子や、記号&amp;（アンパサンド）
で始まるラムダリストキーワードからなる。ラムダリストは５つの部分で
構成されます。

・必須パラメータの記述
    ラムダリストキーワードよりも前に現れる var を必須パラメータという。

・オプショナルパラメータの記述
    &amp;optionalから次のラムダリストキーワードまでか、ラムダリストの
    終わりまで。関数呼び出し時に、オプショナルパラメータに対応する
    引数はあっても無くてもよい。引数が省略された場合、initform が
    あれば initform に初期化され、無ければ nil で初期化される。
    svar は引数が与えられたかどうかを示す。

  ((lambda (x &amp;optional (y 0 given))
       (if given (+ x y) x))
    10 20)
  =&gt; 30

・レストパラメータの記述
    &amp;restとそれに続く一つのパラメータ指定子。関数への引数のうち、
    必須パラメータとオプショナルパラメータに対応するもの以外
    からなるリストに束縛される。

  ((lambda (x &amp;optional (y 1) (z 2) &amp;rest args)
       (list x y z args))
    'a 'b 'c 'd 'e 'f)
  =&gt; (a b c (d e f))

・キーワードパラメタの記述
    &amp;keyから次のラムダリストキーワードまでか、ラムダリストの
    終わりまで。関数が呼ばれたときに対応する keyword に対応する
    パラメータ指定子 var が値に束縛される。

  ((lambda (x &amp;key ((:test f) #'eq))
       (if (funcall f x "word") 'True 'False))
   "word" :test #'equal)
  =&gt; True

  ((lambda (x &amp;key (test #'eq))
       (if (funcall test x "word") 'True 'False))
    "word" :test #'eql)
  =&gt; False

・補助変数の記述
    ラムダリストに &amp;aux が含まれるなら、この後の全ての指定は
    補助変数の指定子である。次に示す二つの例は同じ結果を与える。
    これらの使用については純粋にスタイルの問題である。
  
  ((lambda (x &amp;aux (l (length x)))
       (list x l))
    '(a b c))
  =&gt; ((a b c) 3)
  
  ((lambda (x)
       (let ((l (length x))) (list x l)))
    '(a b c))
  =&gt; ((a b c) 3)
</description>
<seealso>defun</seealso>
<seealso>si:closure-variable</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>last</title>
<type>Function</type>
<arguments>last LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの末尾からN個分のリストを返します。

使用例：
  ;;; 末尾を取得してみる。
  (last '(a b c d))     =&gt; (d)
  (last '(a b c d) 2)   =&gt; (c d)
  (last '(a b c d) 5)   =&gt; (a b c d)
</description>
<seealso>butlast</seealso>
<seealso>subseq</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>lcm</title>
<type>Function</type>
<arguments>lcm INTEGER &amp;rest MORE-INTEGERS</arguments>
<package>lisp</package>
<description>
引数の最小公倍数を返します。

使用例：  
  (lcm 14 35)
  =&gt; 70
  (lcm 0 5)
  =&gt; 0
  (lcm 1 2 3 4 5 6)
  =&gt; 60
</description>
<seealso>gcd</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>length</title>
<type>Function</type>
<arguments>length SEQUENCE</arguments>
<package>lisp</package>
<description>
sequence(文字列や、リスト、配列)の長さを求めます。
配列にfill-pointerがある場合は、そこまでの長さになります。

使用例：
  (length "abcd")               =&gt; 4
  (length (list 1 2 3))         =&gt; 3
  (length (make-array 7))       =&gt; 7
  (length (make-array 7 :fill-pointer 4))
                                =&gt; 4
</description>
<seealso>list-length</seealso>
<seealso>fill-pointer</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>let*</title>
<type>Special Form</type>
<arguments>let* ({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*</arguments>
<package>lisp</package>
<description>
letとよく似ています。letと異なり、VARの初期化に先に定義した他のVARを参照
することが可能です。

使用例：
  ;;; letとlet*の違い
  (setq Y 2)
  =&gt; 2
  (let (X (Y 1) (Z Y)) (list X Y Z))
  =&gt; (nil 1 2)
  (let* (X (Y 1) (Z Y)) (list X Y Z))
  =&gt; (nil 1 1)
</description>
<seealso>let</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>let</title>
<type>Special Form</type>
<arguments>let ({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*</arguments>
<package>lisp</package>
<description>
ローカルな変数を定義してフォームを評価します。
</description>
<seealso>let*</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lisp-complete-symbol</title>
<type>Function</type>
<arguments>lisp-complete-symbol</arguments>
<package>editor</package>
<description>
Lisp のシンボル名を補完します。[ESC TAB]
</description>
<seealso>*lisp-popup-completion-list*</seealso>
<link></link>
<section>シンボル</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>list-all-packages</title>
<type>Function</type>
<arguments>list-all-packages</arguments>
<package>lisp</package>
<description>
xyzzy内に存在するパッケージ一覧をリストで返します。

使用例：
  (list-all-packages)
  =&gt;  (#&lt;package: win-user&gt; #&lt;package: winapi&gt; #&lt;package: 
     foreign&gt;  #&lt;package: lisp&gt; #&lt;package: system&gt; #&lt;package: 
     keyword&gt; #&lt;package: user&gt; #&lt;package: editor&gt;)
</description>
<seealso>defpackage</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-archive</title>
<type>Function</type>
<arguments>list-archive ARCHIVE-FILE &amp;optional FILE-NAME-ONLY</arguments>
<package>editor</package>
<description>
アーカイブのファイル名一覧を取り出します。

  ARCHIVE-FILE   : 一覧を取得するアーカイブを指定します。
  FILE-NAME-ONLY : 戻り値の形式を指定します。
        t   ファイル名(ディレクトリ名)のみを返します。
        nil ファイル名(ディレクトリ名)、属性、サイズ、タイムスタンプを
            返します。

使用例：
  (list-archive "foo.lzh")
</description>
<seealso>create-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-function</title>
<type>Function</type>
<arguments>list-function &amp;rest ARGS</arguments>
<package>editor</package>
<description>
バッファ中の関数の一覧をダイアログで表示します。選択することで定
義位置にジャンプすることが可能です。バッファ中の関数の一覧は、バ
ッファローカル変数build-summary-functionから取得しています。
</description>
<seealso>ed::build-summary-function</seealso>
<link></link>
<section>関数</section>
<file>listfn.l</file>
</chapter>

<chapter>
<title>list-length</title>
<type>Function</type>
<arguments>list-length LIST</arguments>
<package>lisp</package>
<description>
リストの長さを返します。
リストが循環している場合、length は結果を返さないかもしれませんが、
list-length は nil を返します。

使用例：
  ;;; リストの長さを比べてみる。
  (list-length '())             =&gt; 0 
  (list-length '(a b c d))      =&gt; 4 
  (list-length '(a (b c) d))    =&gt; 3 
  (let ((a '(x)))
    (setf (cdr a) a)
    (list-length a))            =&gt; nil
</description>
<seealso>length</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-server-resources</title>
<type>Function</type>
<arguments>list-server-resources SERVER-NAME &amp;optional COMMENT-P</arguments>
<package>editor</package>
<description>
指定されたコンピュータの共有資源の一覧を取得します。
同時に資源のコメントも取得可能です。

使用例：
  (list-server-resources "SAMURAI")
  =&gt; ("SPOOL" "E" "D" "A")
  (list-server-resources "SAMURAI" t)
  =&gt; (("SPOOL" "") ("E" "CD-ROM Drive") ("D" "Backup Storage") ("A" "FD Drive"))
</description>
<seealso>list-servers</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-servers</title>
<type>Function</type>
<arguments>list-servers &amp;optional COMMENT-P</arguments>
<package>editor</package>
<description>
ネットワークコンピュータの一覧が取得できます。
同時にコンピュータに設定されているコメントも取得可能です。

使用例：
  (list-servers)
  =&gt; ("SAMURAI" "ROUNIN")
  (list-servers t)
  =&gt; (("SAMURAI" "Main Machine") ("ROUNIN" "Sub Machine"))
</description>
<seealso>list-server-resources</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-tool-bars</title>
<type>Function</type>
<arguments>list-tool-bars</arguments>
<package>editor</package>
<description>
ツールバーの状態を取得します。状態は以下の形式で返されます。

形式：
  (((左側のツールバー1 横位置1 縦位置1 横幅1)
    (左側のツールバー2 横位置2 縦位置2 横幅2)
    (左側のツールバー3 横位置3 縦位置3 横幅3) ... )
   ((上側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((右側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((下側のツールバー1 横位置1 縦位置1 横幅1) ... )
   (非表示のツールバー1 非表示のツールバー2 ... ))

タブバーの場合だけ横幅に数字が返されます。ツールバーの場合には、必ずnil
が返されます。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list</title>
<type>Function</type>
<arguments>list &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
この関数は、 ARGS を要素とするリストを作ります。結果として返されるリ
ストは(常に) nil でターミネート(訳注：終端)されています。 ARGS が与え
られない場合、 empty リストを返します。 

  (list 1 2 3 4 5)
  =&gt; (1 2 3 4 5)
  (list)
  =&gt; nil
</description>
<seealso>list*</seealso>
<seealso>make-list</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>listen</title>
<type>Function</type>
<arguments>listen &amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
指定された入力ストリームに何か入力がある状態ならばt、ないならばnilを返します。
</description>
<seealso>read-char-no-hang</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>listp</title>
<type>Function</type>
<arguments>listp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsか空リスト()ならt、それ以外ならnilを返します。

  (listp x) == (typep x 'list) == (typep x '(or cons null))
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>load-keyword-file</title>
<type>Function</type>
<arguments>load-keyword-file NAME &amp;optional ICASE TABLE CONDITION</arguments>
<package>editor</package>
<description>
キーワードファイルをロードします。

使用例：
  (and *xmldoc-keyword-file*
       (null *xmldoc-keyword-hash-table*)
       (setq *xmldoc-keyword-hash-table*
             (load-keyword-file *xmldoc-keyword-file* t)))
  (when *xmldoc-keyword-hash-table*
    (make-local-variable 'keyword-hash-table)
    (setq keyword-hash-table *xmldoc-keyword-hash-table*))

補足：
  xyzzy 0.2.2.236 から NAME には複数のキーワードファイルを
  リストで指定可能です。
</description>
<seealso>キーワードファイルの書き方</seealso>
<seealso>キーワードファイルのカスタマイズ</seealso>
<seealso>*keyword-load-path*</seealso>
<seealso>make-list-from-keyword-table</seealso>
<section>その他</section>
<file>kwd.l</file>
</chapter>

<chapter>
<title>load-library</title>
<type>Function</type>
<arguments>load-library FILENAME &amp;rest REST</arguments>
<package>lisp</package>
<description>
ライブラリを対話的に読み込みます。
requireと異なり、一度読んでいてももう一度読み込みます。

内部的には、si:*load-libraryをinteractiveで宣言したものです。

| また、si:*load-library中で失敗したら、メッセージ等を出力して、処理を続けると
| いうのは可能でしょうか？

  (handler-case
      (si:*load-library "foo")
    (error (c) (si:*print-condition c)))
      (si:*load-library "bar")
</description>
<seealso>si:*load-library</seealso>
<seealso>load-file</seealso>
<seealso>*load-path*</seealso>
<seealso>mc-load-library</seealso>
<seealso>各種ロード関係の関数の違い</seealso>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>local-unset-key</title>
<type>Function</type>
<arguments>local-unset-key KEY</arguments>
<package>editor</package>
<description>
ローカルキーマップのキー割り当てを解除します。

使用例：
  ;;; lisp-modeのTABのローカルキーマップを外す。
  (lookup-key-command #\TAB)
  =&gt; lisp-indent-line
  (local-unset-key #\TAB)
  =&gt; t
  (lookup-key-command #\TAB)
  =&gt; self-insert-command
</description>
<seealso>local-set-key</seealso>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>local-variable-p</title>
<type>Function</type>
<arguments>local-variable-p SYMBOL &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
指定されたシンボルがバッファローカル変数かどうかを判定します。

使用例：
  ;;; buffer: foo
  (local-variable-p 'abc)
  =&gt; nil
  (make-local-variable 'abc)
  =&gt; t
  (local-variable-p 'abc)
  =&gt; t

  ;;; buffer: bar
  (local-variable-p 'abc)
  =&gt; nil
</description>
<seealso>make-local-variable</seealso>
<seealso>defvar-local</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lock-file</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
ロックファイルを作るかどうかを指定する変数です。

  t   : ロックファイルを作る。
  nil : ロックファイルを作らない。

使用例：
  ;;; 現在開いているファイルではロックファイルを作らないようにする。
  (make-local-variable 'lock-file)
  =&gt; t
  (setq lock-file nil)
  =&gt; nil 
</description>
<seealso>unlock-file</seealso>
<seealso>file-locked-p</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>log</title>
<type>Function</type>
<arguments>log NUMBER &amp;optional BASE</arguments>
<package>lisp</package>
<description>
BASE を底とする NUMBER の対数を返します。

使用例：
  (log 2.718282)
  =&gt; 1.0
  (log 7.389056)
  =&gt; 2.0
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>logand</title>
<type>Function</type>
<arguments>logand &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎のANDを取ります。C言語でいう&amp;です。

使用例：
  ;;; 2進数で#b11110000と#b00110011のビットの積を取る。
  (format nil "~8,'0b" (logand #b11110000 #b00110011))
  =&gt; "00110000"
<!-- (logand x #xf) -->
</description>
<seealso>logior</seealso>
<seealso>logandc1</seealso>
<seealso>logandc2</seealso>
<seealso>lognand</seealso>
<seealso>lognot</seealso>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logior</title>
<type>Function</type>
<arguments>logior &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎のORを取ります。C言語でいう|です。

使用例：
  ;;; 2進数で#b00110000と#b00000011のビットの和を取る。
  (format nil "~8,'0b" (logior #b00110000 #b00000011))
  =&gt; "00110011"
</description>
<seealso>logand</seealso>
<seealso>lognor</seealso>
<seealso>logorc1</seealso>
<seealso>logorc2</seealso>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>long-float-p</title>
<type>Function</type>
<arguments>long-float-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがlong-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>long-operation</title>
<type>Macro</type>
<arguments>long-operation &amp;rest BODY</arguments>
<package>editor</package>
<description>
カーソルを砂時計にします。明らかに処理時間が長いことが見込まれる場合にし
ようすると良いと思います。

使用例：
  (long-operation
     (message "start")
     ;; 何か長い処理
     (message "end"))
</description>
<seealso>begin-wait-cursor</seealso>
<seealso>end-wait-cursor</seealso>
<section>その他</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>looking-at</title>
<type>Function</type>
<arguments>looking-at REGEXP &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
現在のカーソル位置で前方向に正規表現でマッチしたらt、しなかったらnilを返します。

使用例：
  ;;; カーソル位置が行頭でかつ(とマッチするか?
  (defun rrr ()
    (interactive)
    (if (looking-at "^(")
      (message "ok") (message "bad")))

  ;;; 空白やタブや全角スペースがあれば削除する
  (if (looking-at "[ \t　]*")
      (delete-region (match-beginning 0) (match-end 0)))

参考：
  ;;; looking-at の後方版 (正規表現で後方マッチ)
  ;;; XyzzyWiki 質問箱/175 より
  (defun looking-at-backward (regexp &amp;optional case-fold)
    (save-excursion
      (save-restriction
        (narrow-to-region (point-min) (point))
        (goto-char (point-min))
        (scan-buffer (format nil "~A\\'" regexp)
                     :regexp t :case-fold case-fold))))
</description>
<seealso>looking-for</seealso>
<seealso>scan-buffer</seealso>
<seealso>string-match</seealso>
<seealso>string-looking-at</seealso>
<seealso>正規表現の表記</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>looking-back</title>
<type>Function</type>
<arguments>looking-back STRING &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
現在のカーソル位置から後方向にマッチしたらt、しなかったらnilを返します。

使用例：
  (looking-back "::")
  (looking-back "\\")
  (looking-back "#'")
</description>
<seealso>looking-for</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>looking-for</title>
<type>Function</type>
<arguments>looking-for STRING &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
現在のカーソル位置から前方向にマッチしたらt、しなかったらnilを返します。
後方向にマッチしたければlooking-backを、正規表現でマッチしたければ
looking-atを使用します。

使用例：
  (looking-for "^")
  (looking-for "define")
  (looking-for "::")
</description>
<seealso>looking-at</seealso>
<seealso>looking-back</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lookup-dictionary</title>
<type>Function</type>
<arguments>lookup-dictionary DIRECTORY DIC-FILE INDEX-FILE WORD</arguments>
<package>editor</package>
<description>
辞書引き機能
（詳細不明）

使用例：
  (lookup-dictionary *edict-dictionary-path* "xyzzydic" "xyzzye2j" s)
</description>
<seealso></seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>loop</title>
<type>Macro</type>
<arguments>loop &amp;body BODY</arguments>
<package>lisp</package>
<description>
無限ループします。
脱出するには以下の様にreturnを使います。

 (loop
   処理
   (if 条件 (return 値))
   処理)

使用例：
  ;;; 「はい」と答えるまで繰り返し
  (loop (if (yes-or-no-p "quit?") (return 123)))
  =&gt; 123
</description>
<seealso></seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>lower-case-p</title>
<type>Function</type>
<arguments>lower-case-p CHAR</arguments>
<package>lisp</package>
<description>
CHAR が小文字なら t 、そうでなければ nil を返します。

使用例：
  (lower-case-p #\a)
  =&gt; t
  (lower-case-p #\A)
  =&gt; nil
  (lower-case-p #\RET)
  =&gt; nil
</description>
<seealso>upper-case-p</seealso>
<seealso>both-case-p</seealso>
<seealso>char-downcase</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>machine-name</title>
<type>Function</type>
<arguments>machine-name</arguments>
<package>editor</package>
<description>
マシン名を返します。

使用例：
  ;;; マシン名を返します。
  (machine-name)
  =&gt; "WS4849"

  ;;; PCによって、den8やdiffのインストールディレクトリが違っているので、
  ;;; 切り替えたりできます。
  (defun my-directory-setup ()
    (let ((x (machine-name)))
      (setq *diff-command-name*
            (cond ((string= x "TOMOYO") "c:/Cygnus/diff")
                   (t "c:/z/tools/diff")))
      (setq *den8-directory*
            (cond ((string= x "KANA") "D:/1gou-ki/den8_321")
                   (t "c:/z/den8_321")))))
</description>
<seealso>user-name</seealso>
<seealso>si:getenv</seealso>
<seealso>machine-type</seealso>
<seealso>machine-instance</seealso>
<seealso>machine-version</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>machine-instance</title>
<type>Function</type>
<arguments>machine-instance</arguments>
<package>lisp</package>
<description>
マシン名を返します。

使用例：
  (machine-instance)
  =&gt; "WS4849"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>machine-name</seealso>
<seealso>machine-type</seealso>
<seealso>machine-version</seealso>
<seealso>*features*</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>machine-type</title>
<type>Function</type>
<arguments>machine-type</arguments>
<package>lisp</package>
<description>
マシンのアーキテクチャを返します。

使用例：
  (machine-type)
  =&gt; "x64"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>machine-name</seealso>
<seealso>machine-instance</seealso>
<seealso>machine-version</seealso>
<seealso>*features*</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>machine-version</title>
<type>Function</type>
<arguments>machine-version</arguments>
<package>lisp</package>
<description>
CPU のバージョンを返します。

使用例：
  (machine-version)
  =&gt; "Intel64 Family 6 Model 23 Stepping 10, GenuineIntel"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>machine-name</seealso>
<seealso>machine-instance</seealso>
<seealso>machine-type</seealso>
<seealso>*features*</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macro-function</title>
<type>Function</type>
<arguments>macro-function SYMBOL</arguments>
<package>lisp</package>
<description>
SYMBOLがマクロか否かを返します。マクロの場合にはその内容を返します。
使用例：
  (macro-function 'car)
  =&gt;nil

  (macro-function 'when)
  =&gt;(macro (lisp::test &amp;body lisp::body)
         (block when (list 'if lisp::test (cons 'progn lisp::body))))
</description>
<seealso>fboundp</seealso>
<seealso>boundp</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macroexpand-1</title>
<type>Function</type>
<arguments>macroexpand-1 FORM &amp;optional ENV</arguments>
<package>lisp</package>
<description>
macroexpandに似ていますが、展開されるレベルが1レベルで終わるところが違います。
自作のマクロなどがどう展開されるのか調べるときに便利です。

使用例:
  (defmacro my-macro ()
    `(dotimes (x 10)))
  というマクロがあるとき
  
  (macroexpand '(my-macro))
  =&gt; (block nil (let* ((x 0) (#1=#:count 10)) (lisp::*loop (if (&gt;= x #1#) (return (progn 'nil))) (tagbody) (setq x (+ x 1)))))
  とmy-macro展開後のdotimesまで(実際はdotimesを展開後さらにdo*を展開)が
  再帰的に展開されますが、

  (macroexpand-1 '(my-macro))
  =&gt; (dotimes (x 10))
  と、my-macroだけが展開されます。
</description>
<seealso>macroexpand</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macroexpand</title>
<type>Function</type>
<arguments>macroexpand FORM &amp;optional ENV</arguments>
<package>lisp</package>
<description>
フォームがどのようにマクロ展開されるかを返します。
マクロの展開され方を確認するのに役立ちます。

使用例：
  ;;; マクロM2を定義してどのように展開
  (defmacro M2 (&amp;rest args)
      `(progn
         (m-setup) ,@args (m-cleanup)))
  (macroexpand '(M2 (insert "Begin") (insert "End")))
  =&gt; (progn (m-setup) (insert "Begin") (insert "End") (m-cleanup)) 
</description>
<seealso>defmacro</seealso>
<seealso>macroexpand-1</seealso>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macrolet</title>
<type>Special Form</type>
<arguments>macrolet ({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*</arguments>
<package>lisp</package>
<description>
defmacroの局所版です。
</description>
<seealso>defmacro</seealso>
<seealso>flet</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-array</title>
<type>Function</type>
<arguments>make-array DIMENSIONS &amp;rest REST &amp;key (:element-type t) (:initial-element () ies-p) (:initial-contents () ics-p) :fill-pointer :adjustable :displaced-to (:displaced-index-offset 0)</arguments>
<package>lisp</package>
<description>
DIMENSIONS で示される大きさ・次元の配列をつくり、それを値として返します。
もし、DIMENSIONS が nil なら、ゼロ次元配列がつくられます。
たとえば、変数 hoge をサイズ4の一次元配列(=サイズ4のベクタ)にするためには、

  (setf hoge (make-array 4))
  =&gt; #(nil nil nil nil)

変数 foo をサイズ2x4の二次元配列とするためには、

  (setf foo (make-array '(2 4)))
  =&gt; #2A((nil nil nil nil) (nil nil nil nil))

とします。
:element-type は、新しい配列の各要素の型を規定します。
:initial-element が与えられている場合、新しい配列の全要素はすべて
:initial-element に初期化されます。これに対して、:initial-contents が与えら
れている場合、新しい配列の各要素が :initial-contents で初期化されます。
たとえば、

  (make-array '(2 4) :initial-element 10); 2x4の配列をつくる。:initial-elementで初期化
  =&gt; #2A((10 10 10 10) (10 10 10 10))
  (setq a (make-array '(2 4) 
  :initial-contents '((0 1 2 3) (3 2 1 0))); 2x4の配列をつくる。:initial-contentsで初期化
  =&gt; #2A((0 1 2 3) (3 2 1 0))

なお、配列の要素にアクセスするためには、 aref が使われます。

:displaced-to, :displaced-index-offset 指定は、元の配列の一部からなる共有配列
を生成するために使われます。 copy-seq による複製とは違い、配列自体を共有しています。

  (setq b (make-array '(2 3) :displaced-to a :displaced-index-offset 2))
  =&gt; #2A((2 3 3) (2 1 0))

  (setq c (make-array 5 :displaced-to a :displaced-index-offset 1))
  =&gt; #(1 2 3 3 2)

  (setf (aref b 1 0) 10)
  a
  =&gt; #2A((0 1 2 3) (3 10 1 0))
  b
  =&gt; #2A((2 3 3) (10 1 0))
  c
  =&gt; #(1 2 3 3 10)
</description>
<seealso>make-sequence</seealso>
<seealso>aref</seealso>
<seealso>setf</seealso>
<seealso>make-vector</seealso>
<seealso>length</seealso>
<seealso>array-dimensions</seealso>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>make-backup-files</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
バックアップファイルを作るかどうかを指定する変数です。

  t   : バックアップファイルを作る
  nil : バックアップファイルを作らない

使用例：
  ;;; 現在開いているファイルをバックアップとらないようにする。
  (make-local-variable 'make-backup-files)
  =&gt; t
  (setq make-backup-files nil)
  =&gt; nil
</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>make-broadcast-stream</title>
<type>Function</type>
<arguments>make-broadcast-stream &amp;rest STREAMS</arguments>
<package>lisp</package>
<description>
ブロードキャスト用の出力ストリームを作成します。
STREAMS に指定した複数のストリームに対して同時に出力することができます。

参考：
                        OUTPUT━━┓
                    ┌→┃STREAM1 ┠→
                    │  ┗━━━━┛
        BROADCAST ┓│  OUTPUT━━┓
    ─→┃STREAM  ┠┼→┃STREAM2 ┠→
        ┗━━━━┛│  ┗━━━━┛
                    │  OUTPUT━━┓
                    └→┃STREAM3 ┠→
                        ┗━━━━┛
使用例：
  ;;; fooとbarという出力ストリームを作ってから、
  ;;; hogeというブロードキャスト用ストリームを作り一括して出力
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (princ "abc" hoge))))
  =&gt; "abc"
</description>
<seealso>broadcast-stream-streams</seealso>
<seealso>broadcast-stream-p</seealso>
<seealso>make-concatenated-stream</seealso>
<seealso>make-echo-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-buffer-stream</title>
<type>Function</type>
<arguments>make-buffer-stream BUFFER &amp;optional POINT EOB</arguments>
<package>editor</package>
<description>
バッファ上にbuffer-streamを作成します。

  BUFFER : buffer-streamを作成するバッファを指定します。
  POINT  : 入出力を開始するポイントを指定します。
        nil     バッファの先頭が開始位置
        nil以外 指定されたポイントが開始位置
  EOB    : 終端のポイントを指定します。
        nil     バッファの最後が終端
        nil以外 指定されたポイントが終端
</description>
<seealso>buffer-stream-buffer</seealso>
<seealso>buffer-stream-point</seealso>
<seealso>buffer-stream-set-point</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-concatenated-stream</title>
<type>Function</type>
<arguments>make-concatenated-stream &amp;rest STREAMS</arguments>
<package>lisp</package>
<description>
STREAMS に指定した複数の入力ストリームをくっつけて、順番に読み出すための
一つの入力ストリームを作ります。

参考：
                        INPUT ━━┓    
                      ┌┨STREAM1 ┃←─
                      │┗━━━━┛    
        CONCAT━━┓  │INPUT ━━┓    
    ←─┨STREAM  ┃←┼┨STREAM2 ┃←─
        ┗━━━━┛  │┗━━━━┛    
                      │INPUT ━━┓    
                      └┨STREAM3 ┃←─
                        ┗━━━━┛    

使用例：
  ;;; 文字列の入力ストリームを二本作った後、一本に連接してみる。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (while (setq in (read-char hoge nil))
          (write-char in)))))
</description>
<seealso>make-broadcast-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-echo-stream</title>
<type>Function</type>
<arguments>make-echo-stream INPUT-STREAM OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
INPUT-STREAM からの入力を OUTPUT-STREAM に出力するストリームを作成します。
make-two-way-stream と異なり、 INPUT-STREAM から入力された内容は、全て
OUTPUT-STREAM にエコーされます。

参考：

     ECHO STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃    ┌─┨    ┗━━━━┛
        ┃    └→┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛
</description>
<seealso>echo-stream-input-stream</seealso>
<seealso>echo-stream-output-stream</seealso>
<seealso>echo-stream-p</seealso>
<seealso>make-two-way-stream</seealso>
<seealso>make-broadcast-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-hash-table</title>
<type>Function</type>
<arguments>make-hash-table &amp;key :test :size :rehash-size :rehash-threshold</arguments>
<package>lisp</package>
<description>
ハッシュテーブルを作成して返します。

  :test        : ハッシュテーブルのキーの等価関係。デフォルトは eql です。
                 指定可能な関数は、eq, eql, equal, equalp に限られます。
  :size        : ハッシュテーブルの初期サイズの目安。
                 この値よりも大きい素数、または 2, 3, 5, 7 で割れない値
                 に設定されます。
  :rehash-size : ハッシュテーブルのテーブルサイズを増加させる量の目安。
                 デフォルトは 1.5。
                 整数値を指定すると指定した数を増加量の目安とします。
                 小数値を指定すると現在のサイズ * rehash-size で増加量の
                 目安を計算します。現在のサイズと :rehash-size を参考に、
                 より大きい素数、または 2, 3, 5, 7 で割れないサイズに設定されます。
  :rehash-threshold
               : ハッシュテーブルのテーブルサイズを増加させる使用率の目安。
                 デフォルトでは使用率が 80% を超えるとテーブルを伸長します。

とりうる素数は以下の通りです。
      17, 47, 101, 149, 199, 307, 401, 499, 599, 701, 797, 907, 997,
      1103, 1499, 1999, 2999, 4001, 4999, 6007, 7001, 8009, 8999,
      10007, 19997, 29989, 39989, 49999, 59999, 70001, 79999, 90001, 99991

使用例:
  (setq hash (make-hash-table :size 20))
  =&gt; #&lt;hashtable :test eql :size 0/47 9900416&gt;

  (progn
    (setf (gethash #\C-0 hash) 0)
    (setf (gethash #\C-1 hash) 1)
    (setf (gethash #\C-2 hash) 2))
  =&gt; 2
  
  (gethash #\C-1 hash)
  =&gt; 1
      t

  (hash-table-size hash)
  =&gt; 17

  (hash-table-rehash-size hash)
  =&gt; 1

  (hash-table-rehash-threshold hash)
  =&gt; 0.8

  (hash-table-test hash)
  =&gt; eql

備考：
  :rehash-size パラメータの小数指定は xyzzy 0.2.2.238 から利用可能です。
  :rehash-threshold パラメータの指定は xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>gethash</seealso>
<seealso>hash-table-count</seealso>
<seealso>hash-table-p</seealso>
<seealso>hash-table-rehash-size</seealso>
<seealso>hash-table-rehash-threshold</seealso>
<seealso>hash-table-size</seealso>
<seealso>hash-table-test</seealso>
<seealso>remhash</seealso>
<seealso>clrhash</seealso>
<seealso>maphash</seealso>
<seealso>eql</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-keymap</title>
<type>Function</type>
<arguments>make-keymap</arguments>
<package>editor</package>
<description>
空のキーマップを作成します。
</description>
<seealso>make-sparse-keymap</seealso>
<seealso>keymapp</seealso>
<seealso>use-keymap</seealso>
<seealso>define-key</seealso>
<seealso>lookup-keymap</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-list-from-keyword-table</title>
<type>Function</type>
<arguments>make-list-from-keyword-table HASH</arguments>
<package>editor</package>
<description>
キーワードハッシュテーブルから補完用のリストを作成します。

  HASH：キーワードハッシュテーブル(*xxxx-keyword-hash-table*)を指定

使用例：
  ;;; CSSのキーワードハッシュテーブルを元に
  ;;; 補完用リストを作成して、do-completionする。
  (defun css-completion ()
    (interactive)
    (or *css-completion-list*
        (setq *css-completion-list* (make-list-from-keyword-table *css-keyword-hash-table*))
        (return-from css-completion nil))
    (let ((opoint (point)))
      (when (skip-syntax-spec-backward "w_")
        (let ((from (point)))
          (goto-char opoint)
          (do-completion from opoint :list-ignore-case *css-completion-list*)))))
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>kwd.l</file>
</chapter>

<chapter>
<title>make-list</title>
<type>Function</type>
<arguments>make-list SIZE &amp;key :initial-element</arguments>
<package>lisp</package>
<description>
指定された長さのリストを作成して返します。

  SIZE             : リストの長さ
  :initial-element : リストの要素

使用例：
  (make-list 3)
  =&gt; (nil nil nil)
  (make-list 0)
  =&gt; nil
  (make-list 2 :initial-element 'x)
  =&gt; (x x)
</description>
<seealso>list</seealso>
<seealso>make-sequence</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-local-variable</title>
<type>Function</type>
<arguments>make-local-variable SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLを現在のバッファで独自の値を持てるようにローカル変数にします。
make-variable-buffer-localとは異なり、現在のバッファだけです。

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  =&gt; t  
  (setq auto-save nil)
  =&gt; nil
</description>
<seealso>make-variable-buffer-local</seealso>
<seealso>defvar-local</seealso>
<seealso>local-variable-p</seealso>
<seealso>kill-local-variable</seealso>
<seealso>kill-all-local-variables</seealso>
<seealso>buffer-local-value</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-marker</title>
<type>Function</type>
<arguments>make-marker &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
空のマーカーを作って返します。
バッファを編集することで、マーカーの位置もそれに追随して変わります。
マーカーは、 goto-char や buffer-substring、delete-region などのバッ
ファ上の位置を引数にとる関数の引数として使用できます。

  BUFFER : マーカーを作るバッファを指定します。
           指定しなければ、現在のバッファになります。

使用例：
  ;; スクラッチでマーカーを作る
  (setq marker (make-marker (find-buffer "*scratch*")))
  =&gt; #&lt;marker: *scratch*: -&gt;

  ;; マーカーに位置を設定する
  (set-marker marker 3)
  =&gt; #&lt;marker: *scratch*: 3&gt;

  ;; マーカー位置に移動する
  (goto-char marker)
  =&gt; t

  ;; マーカーより手前の内容を削除する
  (goto-char (point-max))
  (delete-region 0 1)
  (marker-point marker)
  =&gt; 2

  ;; マーカーより手前に文字列を挿入する
  (goto-char 0)
  (insert "abc")
  (marker-point marker)
  =&gt; 5

  ;; マーカー位置に文字列を挿入する
  (goto-char marker)
  (insert "xyz")
  (marker-point marker)
  =&gt; 5
</description>
<seealso>point-marker</seealso>
<seealso>markerp</seealso>
<seealso>set-marker</seealso>
<seealso>mark</seealso>
<seealso>marker-point</seealso>
<seealso>goto-char</seealso>
<seealso>process-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-package</title>
<type>Function</type>
<arguments>make-package PACKAGE-NAME &amp;key :nicknames :use :internal-size :external-size</arguments>
<package>lisp</package>
<description>
パッケージを作成します。defpackageとの違いは？（詳細不明）

使用例：
  (make-package name :external-size 0)
</description>
<seealso>defpackage</seealso>
<seealso>delete-package</seealso>
<seealso>in-package</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-process</title>
<type>Function</type>
<arguments>make-process COMMAND-LINE &amp;key :environ :output :exec-directory :incode :outcode :eol-code :show</arguments>
<package>editor</package>
<description>
プロセスを起動します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :environ        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :output         : プロセスの標準出力を出力するバッファを指定します。
  :exec-directory : 実行するディレクトリを指定します。
  :incode         : プロセスの入力の文字コードを指定します。
  :outcode        : プロセスの出力の文字コードを指定します。
  :eol-code       : 改行コードを指定します。
  :show           : 外部プログラムの実行時の表示を指定します。
                    :show      通常のウィンドウ
                    :no-active 非アクティブ
                    :minimize  最小化
                    :maximize  最大化
                    :hide      非表示
                    上記以外   通常のウィンドウ

プロセスへの入力はprocess-send-stringを使用します。
プロセスはバッファに関連付けられ、プロセスの出力がバッファにそのまま出力されます。
バッファに関連付けられたプロセスの状態は，モードライン上に :Run や :Exit と
表示されます。また、環境変数や出力先等を変更できます。

戻り値は，バッファに関連付けられたプロセスです。

参考:
  [xyzzy:02210]山本真二さん
  call-process または別の組み込み関数で、標準入力、標準出力、標準エラー
  出力を直接バッファに繋ぐようにした方が早くてかっこいいと思うのですが、
  難しいですか？

  (make-process *eshell* :output (selected-buffer))
  (process-send-string (buffer-process (selected-buffer))
                       (concatenate 'string cmd *shell-ret*))

補足：
  :show パラメータの指定は xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>call-process</seealso>
<seealso>execute-subprocess</seealso>
<seealso>filter-region</seealso>
<seealso>buffer-process</seealso>
<seealso>process-send-string</seealso>
<seealso>set-process-sentinel</seealso>
<seealso>set-process-filter</seealso>
<seealso>kill-subprocess</seealso>
<seealso>shell-execute</seealso>
<seealso>open-network-stream</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-sequence</title>
<type>Function</type>
<arguments>make-sequence TYPE SIZE &amp;key :initial-element</arguments>
<package>lisp</package>
<description>
要素のタイプが TYPE でサイズが SIZE なシーケンスを作成して返します。
:initial-element が与えられた場合はそれぞれの項目はそれで初期化されます。
  
TYPE の値と返されるシーケンスは以下の通りです。
  'list          ──→ リスト
  'vector        ─┬→ ベクタ
  'simple-vector ─┘
  'string        ─┬→ 文字列
  'simple-string ─┘

TYPE にはリストを与えることもでき、その場合は最初の要素でシーケンスが決まります。
  '(list ...)         ──→ リスト
  '(array ...)        ─┬→ 配列
  '(simple-array ...) ─┘
最初の要素が list の場合、二番目以降の引数は無視されます。
最初の要素が array または simple-array の場合は三番目の要素まで意味を持ちます。
二番目の要素は値によって以下のように変化します。リストの場合はその最初の要素で判断されます。
  t                  ─┬→ 配列
  nil                ─┘
  character          ─┬→ 文字列
  base-character     ─┤
  standard-char      ─┤
  extended-character ─┘
三番目の要素は 1 または (*) または (SIZE に等しい数値) でなければなりませんが、
どれを選んでも動作に違いはないようです。
  
使用例：
  ;;; #\a が 8 文字の文字列を作ってみる
  (make-sequence 'string 8 :initial-element #\a)
  =&gt; "aaaaaaaa"
  (make-sequence 'list 4 :initial-element "abc")
  =&gt; (#1="abc" #1# #1# #1#)
  (make-sequence 'vector 4 :initial-element 'a)
  =&gt; #(a a a a)
  ;;; あえて TYPE に array を与えてみる
  (make-sequence '(array t (*)) 4 :initial-element 'a)
  =&gt; #(a a a a)
  (make-sequence '(array character 1) 8 :initial-element #\a)
  =&gt; "aaaaaaaa"
</description>
<seealso>make-vector</seealso>
<seealso>make-array</seealso>
<seealso>make-list</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>make-sparse-keymap</title>
<type>Function</type>
<arguments>make-sparse-keymap</arguments>
<package>editor</package>
<description>
空のキーマップを作成します。
キー定義の数が少ない時に使うとメモリを節約できます。

使用例：
  ;;; lispmode.lより
  (unless *lisp-mode-map*
    (setq *lisp-mode-map* (make-sparse-keymap))
    (define-key *lisp-mode-map* #\C-M-x 'eval-defun)
    ...
    (define-key *lisp-mode-map* #\) 'lisp-electric-close))
</description>
<seealso>make-keymap</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-string-input-stream</title>
<type>Function</type>
<arguments>make-string-input-stream STRING &amp;optional START END</arguments>
<package>lisp</package>
<description>
文字列からの入力用ストリームを作成します。
以後、このストリームからは文字列の内容を順番に取得可能です。

  STRING : 対象の文字列を指定します。
  START  : 入力ストリームとする開始位置です。
  END    : 入力ストリームとする終了位置です。

複数の入力ストリームを使用するのでなければ、with-input-from-string を使
用する方が簡単です。

使用例：
  ;;; 文字列の入力用ストリームからひとつ読み出してみる。
  (with-open-stream (foo (make-string-input-stream "abc def"))
    (read foo))
  =&gt; abc  

  ;;; with-input-from-stringを使って同じ事をしてみる。
  (with-input-from-string (foo "abc def")
    (read foo))
  =&gt; abc  
</description>
<seealso>make-string-output-stream</seealso>
<seealso>with-input-from-string</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-symbol</title>
<type>Function</type>
<arguments>make-symbol PRINT-NAME</arguments>
<package>lisp</package>
<description>
印字名がPRINT-NAMEであるuninternedなシンボルを返します。

参考：
  evalmacs.l
</description>
<seealso>intern</seealso>
<seealso>gensym</seealso>
<seealso>symbol-package</seealso>
<seealso>uninterned</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-syntax-table</title>
<type>Function</type>
<arguments>make-syntax-table</arguments>
<package>editor</package>
<description>
シンタックステーブルを作成します。基本的に各文字にシンタックスコードを割
り振りますが、他にも目的の構文に応じて以下の設定を行います。

  ・文字列中のエスケープ文字の設定
  ・タグや括弧などの対応付けのある文字の設定
  ・単なる対になった区切り文字の設定
  ・コメントの設定
      ・開始終了を一文字で行うコメント
      ・開始終了を文字列で行うコメント
      ・C++スタイルのコメント
  ・特定行に文字があった場合のコメントの設定

これらの設定は set-syntax-... 系の関数を使って行います。設定に応じて、画
面の色付けや skip-syntax-spec-forward / skip-syntax-spec-backward での動作
が変わったりします。

デフォルト値：
  Num           Char            SyntaxCode
  ---           ----            ----------
  0x00          #\NUL           SCjunk
  0x01 .. 0x08  #\C-a .. #\C-h  SCjunk
  0x09          #\TAB           SCwhite
  0x0a          #\LFD           SCwhite
  0x0b          #\C-k           SCjunk
  0x0c          #\C-l           SCwhite
  0x0d          #\RET           SCwhite
  0x0e .. 0x1a  #\C-n .. #\C-z  SCjunk
  0x1b          #\ESC           SCjunk
  0x1c          #\C-\\          SCjunk
  0x1d          #\C-]           SCjunk
  0x1e          #\C-^           SCjunk
  0x1f          #\C-_           SCjunk
  0x20          #\SPC           SCwhite
  0x21 .. 0x2f  #\! .. #\/      SCpunct
  0x30 .. 0x39  #\0 .. #\9      SCword
  0x3a          #\:             SCpunct
  0x3b          #\;             SCpunct
  0x3c          #\&lt;             SCpunct
  0x3d          #\=             SCpunct
  0x3e          #\&gt;             SCpunct
  0x3f          #\?             SCpunct
  0x40          #\@             SCpunct
  0x41 .. 0x5a  #\A .. #\Z      SCword
  0x5b          #\[             SCpunct
  0x5c          #\\             SCpunct
  0x5d          #\]             SCpunct
  0x5e          #\^             SCpunct
  0x5f          #\_             SCpunct
  0x60          #\`             SCpunct
  0x61 .. 0x7a  #\a .. #\z      SCword
  0x7b          #\{             SCpunct
  0x7c          #\|             SCpunct
  0x7d          #\}             SCpunct
  0x7e          #\~             SCpunct
  0x7f          #\DEL           SCjunk
  0x80                          SCjunk
  0x81 ..0x9f   #\x81 .. #\x9f  SCkanji
  0xa0                          SCkanji
  0xa1 .. 0xb0  #\｡ .. #\ｰ      SCkana
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ      SCkana
  0xde          #\ﾞ             SCkana
  0xdf          #\ﾟ             SCkana
  0xe0 .. 0xfc  #\xe0 .. #\xfc  SCkanji
  0xfd                          SCjunk
  0xfe                          SCjunk
  0xff                          SCjunk
</description>
<seealso>copy-syntax-table</seealso>
<seealso>syntax-table-p</seealso>
<seealso>use-syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-temp-file-name</title>
<type>Function</type>
<arguments>make-temp-file-name &amp;optional PREFIX SUFFIX DIRECTORY DIRECTORY-P</arguments>
<package>editor</package>
<description>
一時作業用のファイルを作成しそのパスを返します。
ファイルは即時に作成されます。同じようにディレクトリを作成することも可能です。

  PREFIX      : 一時作業用のファイルの接頭子
  SUFFIX      : 一時作業用のファイルの拡張子
                指定が無ければ".tmp"となります。
  DIRECTORY   : 一時作業用のファイルを作成するディレクトリ
                指定が無ければ環境変数TMPに作成されます。
  DIRECTORY-P : ファイルではなくディレクトリを作成する場合
        t       ディレクトリを作成します。
        nil     ファイルを作成します。

使用例：
  ;;; C:\spoolに一時作業用ファイルを作成します。 
  (make-temp-file-name "_den" "tmp" "c:/spool")
  =&gt; "c:/spool/_denc0dc.tmp"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-two-way-stream</title>
<type>Function</type>
<arguments>make-two-way-stream INPUT-STREAM OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力をINPUT-STREAM、出力をOUTPUT-STREAMにする入出力ストリームを作成します。

参考：
        TWO WAY
          STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃        ┃    ┗━━━━┛
        ┃        ┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛
</description>
<seealso>two-way-stream-input-stream</seealso>
<seealso>two-way-stream-output-stream</seealso>
<seealso>make-echo-stream</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-variable-buffer-local</title>
<type>Function</type>
<arguments>make-variable-buffer-local SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLを個々のバッファで独自の値を持てるようにローカル変数にします。
make-local-variableとは異なり、全てのバッファが対象です。
余程のことが無い限りdefvar-localを使えば良いと思います。
</description>
<seealso>make-local-variable</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-vector</title>
<type>Function</type>
<arguments>make-vector LENGTH &amp;key (:element-type t) (:initial-element () ies-p) (:initial-contents () ics-p) :fill-pointer :adjustable :displaced-to (:displaced-index-offset 0)</arguments>
<package>lisp</package>
<description>
指定した長さのベクタを返します。

使用例：
  ;;; 長さが10のベクタを作ります。
  (make-vector 10)
  =&gt; #(nil nil nil nil nil nil nil nil nil nil)

  ;;; :element-typeにcharacterを指定すると文字列が作成できる
  (make-vector 10 :element-type 'character)
  =&gt; "^@^@^@^@^@^@^@^@^@^@"
</description>
<seealso>vector</seealso>
<seealso>make-array</seealso>
<seealso>copy-seq</seealso>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>makunbound</title>
<type>Function</type>
<arguments>makunbound SYMBOL</arguments>
<package>lisp</package>
<description>
指定されたシンボルの値からの束縛を解消します。
これ以降boundpはnilを返すようになります。値と関数定義の束縛は独立してい
るので、makunboundをしてもfboundpの結果は変わりません。

使用例：
  ;;; 束縛を解消してみる。
  (set 'foo 2)          =&gt; 2
  (boundp 'foo)         =&gt; t
  (makunbound 'foo)     =&gt; foo
  (boundp 'foo)         =&gt; nil
</description>
<seealso>boundp</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>map-backslash-to-slash</title>
<type>Function</type>
<arguments>map-backslash-to-slash STRING</arguments>
<package>editor</package>
<description>
文字列のバックスラッシュをスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-backslash-to-slash "C:\\xyzzy\\xyzzy.exe")
  =&gt; "C:/xyzzy/xyzzy.exe"
</description>
<seealso>map-slash-to-backslash</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>map-slash-to-backslash</title>
<type>Function</type>
<arguments>map-slash-to-backslash STRING</arguments>
<package>editor</package>
<description>
文字列のスラッシュをバックスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-slash-to-backslash "C:/xyzzy/xyzzy.exe")
  =&gt; "C:\\xyzzy\\xyzzy.exe"
</description>
<seealso>map-backslash-to-slash</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mapc</title>
<type>Function</type>
<arguments>mapc FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方はmapcarとよく似ていますが、戻り値には与えられたリストをその
まま返します。
</description>
<seealso>mapcar</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mapcan</title>
<type>Function</type>
<arguments>mapcan FN LISTS &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方は mapcar によく似ていますが、関数 FN の呼び出し結果をくっつ
けたリストを返します。

  (mapcan f x1 ... xn) == (apply #'nconc (mapcar f x1 ... xn))

使用例：
  ;;; mapcanとmapcarとの違い
  (mapcan #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  =&gt; ("latin_capital_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  (mapcar #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  =&gt; (nil ("latin_capital_letter_a") nil ("latin_small_letter_b") ("latin_small_letter_c") nil)
</description>
<seealso>mapcar</seealso>
<seealso>mapcon</seealso>
<seealso>nconc</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>mapcar</title>
<type>Function</type>
<arguments>mapcar FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストのcarを、二回目はcadrを、三回目はcaddrを関数に渡します。
リストが複数の場合が分かりにくいので図示します。

  ;;; リストが一つ      ┌──┐┌──┐┌──┐
  (mapcar #'char-name '(│ #\a││ #\b││ #\c│))
                        └─┬┘└─┬┘└─┬┘
                    ┌───┘      │      └───┐
                    ↓              ↓              ↓
  == (list (char-name #\a) (char-name #\b) (char-name #\c))
  == (list "latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  =&gt; ("latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")

  ;;; リストが複数   ┌─┐┌─┐┌─┐
  (mapcar #'+      '(│ 1││ 2││ 3│ 4)
                   '(│ 1││ 3││ 5│  )
                   '(│ 1││ 4││ 9│16)
                   '(│ 1││ 8││27│  )) 
                     └┬┘└┬┘└┬┘
             ┌────┘┌─┘    │   
             ↓          ↓        ↓         
  == (list (+ 1 1 1 1) (+ 2 3 4 8) (+ 3 5 9 27))
  == (list 4 17 44)
  =&gt; (4 17 44)

使用例：
  (mapcar #'+ '(1 2 3 4) 
              '(1 3 5) 
              '(1 4 9 16) 
              '(1 8 27)) 
  =&gt; (4 17 44)
</description>
<seealso>mapcan</seealso>
<seealso>mapcon</seealso>
<seealso>maplist</seealso>
<seealso>mapc</seealso>
<seealso>mapl</seealso>
<seealso>map</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mapcon</title>
<type>Function</type>
<arguments>mapcon FN LISTS &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方は maplist によく似ていますが、関数 FN の呼び出し結果をくっ
つけたリストを返します。

  (mapcon f x1 ... xn) == (apply #'nconc (maplist f x1 ... xn))

使用例：
  (mapcon #'(lambda (x) (if (find 2 x) (list x))) '(1 a 2 b 3))
  =&gt; ((1 a 2 b 3) (a 2 b 3) (2 b 3))
  
  (mapcon #'(lambda (x) (if (find 2 x) x)) '(1 a 2 b 3)) ; 無限ループ?
  
  (mapcon #'(lambda (x) (if (find 2 x) (copy-list x))) '(1 a 2 b 3))
  =&gt; (1 a 2 b 3 a 2 b 3 2 b 3)
</description>
<seealso>maplist</seealso>
<seealso>mapcan</seealso>
<seealso>nconc</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>maphash</title>
<type>Function</type>
<arguments>maphash FUNCTION HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの各要素を関数に渡します。

  FUNCTION   : キーと値を受け取る関数
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setf hsh (make-hash-table))
  (setf (gethash #\a hsh) "Apple")  =&gt; "Apple"
  (setf (gethash #\b hsh) "Banana") =&gt; "Banana"
  (setf (gethash #\c hsh) "Cake")   =&gt; "Cake"
  (let ((alist nil))
    (maphash #'(lambda (x y) (pushnew (cons x y) alist)) hsh)
    alist)
  =&gt;((#\c . "Cake") (#\b . "Banana") (#\a . "Apple"))
</description>
<seealso>with-hash-table-iterator</seealso>
<seealso>gethash</seealso>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>hash.l</file>
</chapter>

<chapter>
<title>mapl</title>
<type>Function</type>
<arguments>mapl FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方はmaplistとよく似ていますが、戻り値には与えられたリストをそ
のまま返します。
</description>
<seealso>maplist</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>maplist</title>
<type>Function</type>
<arguments>maplist FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストを、二回目はcdrを、三回目はcddrを関数に渡します。

使用例：
  (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
  =&gt; ((foo a . #1=(b . #2=(c . #3=(d)))) (foo . #1#) (foo . #2#) (foo . #3#))
</description>
<seealso>mapcar</seealso>
<seealso>mapcon</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mark-dialog-box</title>
<type>Function</type>
<arguments>mark-dialog-box</arguments>
<package>editor</package>
<description>
マークダイアログを表示します。[C-F2]

マークダイアログからは、グローバルマークを設定することができ、複数のポイ
ント間を移動することができます。

  移動   : 選択したマークに移動します。
  追加   : マークを追加します。
  削除   : 選択したマークを削除します。
  全削除 : 全てのマークを削除します。
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>gmark.l</file>
</chapter>

<chapter>
<title>mark-paragraph</title>
<type>Function</type>
<arguments>mark-paragraph</arguments>
<package>editor</package>
<description>
段落の末尾にマークを、先頭にポイントを設定します。[ESC h]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>mark-sexp</title>
<type>Function</type>
<arguments>mark-sexp &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方のS式の末尾にマークを設定します。[ESC NUL]
</description>
<seealso>set-mark-command</seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>mark-word</title>
<type>Function</type>
<arguments>mark-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置前方の単語の末尾にマークを設定します。[ESC @]
カーソルが単語の途中にある場合は、その単語の末尾にマークを設定します。
</description>
<seealso>set-mark-command</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>mark</title>
<type>Function</type>
<arguments>mark &amp;optional FORCE</arguments>
<package>editor</package>
<description>
マークの位置を数値で返します。

  FORCE：マークが設定されていない場合に処理を継続するか？
        t       エラーとしない、関数はnilを返す
        nil     エラーとする
</description>
<seealso>marker-point</seealso>
<seealso>make-marker</seealso>
<seealso>set-mark</seealso>
<seealso>exchange-point-and-mark</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>marker-buffer</title>
<type>Function</type>
<arguments>marker-buffer MARKER</arguments>
<package>editor</package>
<description>
マーカーが設定されているバッファを返します。

使用例：
  (marker-buffer m)
  =&gt; #&lt;buffer: *scratch*&gt;
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>marker-point</title>
<type>Function</type>
<arguments>marker-point MARKER</arguments>
<package>editor</package>
<description>
マーカーの位置を数値で返します。
マーカーの位置が設定されていなかったり削除されていたりした場合は nil を返します。

使用例：
  (marker-point m)
  =&gt; 62
</description>
<seealso>mark</seealso>
<seealso>set-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>markerp</title>
<type>Function</type>
<arguments>markerp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがマーカーかを返します。

  t     OBJECTはマーカー
  nil   OBJECTはマーカーではない
</description>
<seealso>make-marker</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-beginning</title>
<type>Function</type>
<arguments>match-beginning REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した先頭のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得
</description>
<seealso>match-end</seealso>
<seealso>match-string</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-data</title>
<type>Function</type>
<arguments>match-data &amp;optional DATA</arguments>
<package>editor</package>
<description>
scan-buffer で検索時点の状態を保持します。複数の検索をした後で、元の
検索の結果で match-string / match-beginning / match-end / replace-match 
を行うことが可能です。

使用例：
  ;;; カーソルより後ろにabcdefと文字列があった場合
  ;;; 検索を2回してからその結果をそれぞれ取得する。
  (let (1st 2nd)
    ; 検索
    (scan-buffer "a\\(\\w*\\)" :regexp t)
    (setq 1st (match-data))
    (scan-buffer "abc\\(\\w*\\)" :regexp t)
    (setq 2nd (match-data))
    ; 結果参照
    (store-match-data 1st)
    (msgbox "~A" (match-string 1))
    (store-match-data 2nd)
    (msgbox "~A" (match-string 1)))
</description>
<seealso>store-match-data</seealso>
<seealso>scan-buffer</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-end</title>
<type>Function</type>
<arguments>match-end REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した最後のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得
</description>
<seealso>match-beginning</seealso>
<seealso>match-string</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-string</title>
<type>Function</type>
<arguments>match-string REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した文字列を取得することができます。
(buffer-substring (match-beginning REGNUM) (match-end REGNUM))に一致します。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得

使用例：
  ;;; 次に現れるLispのコメントを取得する。
  (progn
    (scan-buffer ";\\([^;\n]+\\)" :regexp t :no-dup nil)
    (match-string 1))
</description>
<seealso>match-beginning</seealso>
<seealso>match-end</seealso>
<seealso>match-data</seealso>
<seealso>store-match-data</seealso>
<seealso>scan-buffer</seealso>
<seealso>正規表現の表記</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>max</title>
<type>Function</type>
<arguments>max NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数の中で最大の数値を返します。

使用例：  
  (max 3)
  =&gt; 3
  (max -3 0 2)
  =&gt; 2
  (max 2.5 1)
  =&gt; 2.5
  (max 3 2.5)
  =&gt; 3
</description>
<seealso>min</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member-if-not</title>
<type>Function</type>
<arguments>member-if-not PREDICATE LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
LIST の中で条件 PREDICATE を満たさないものがあれば、そこからのリストを返します。
なければ nil を返します。

使用例：
  (member-if-not #'numberp '(1 2 3))
  =&gt; nil
  (member-if-not #'numberp '(1 2 a 3))
  =&gt; (a 3)
</description>
<seealso>member</seealso>
<seealso>member-if</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member-if</title>
<type>Function</type>
<arguments>member-if PREDICATE LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
LIST の中で条件 PREDICATE を満たすものがあれば、そこからのリストを返します。
なければ nil を返します。

使用例：
  (member-if #'numberp '(a b c))
  =&gt; nil
  (member-if #'numberp '(a b 3 c))
  =&gt; (3 c)
</description>
<seealso>member</seealso>
<seealso>member-if-not</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member</title>
<type>Function</type>
<arguments>member ITEM LIST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST の中で ITEM との :test を満たすものがあれば一致したところからのリストを返します。
なければ nil を返します。

使用例：
  (member 'e '(a b c d))
  =&gt; nil
  (member 'b '(a b c d))
  =&gt; (b c d)
</description>
<seealso>member-if</seealso>
<seealso>member-if-not</seealso>
<seealso>find</seealso>
<seealso>position</seealso>
<seealso>getf</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>menup</title>
<type>Function</type>
<arguments>menup OBJECT</arguments>
<package>editor</package>
<description>
オブジェクトがメニューかどうかを返します。

  OBJECT : 判定するオブジェクト

  t   オブジェクトはメニュー
  nil オブジェクトはメニューではない
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>merge-pathnames</title>
<type>Function</type>
<arguments>merge-pathnames PATHNAME &amp;optional DEFAULTS</arguments>
<package>lisp</package>
<description>
パスとファイル名をくっつけます。

  PATHNAME : ファイル名の部分を指定します。
  DEFUALTS : パスの部分を指定します。
             指定しないと(default-directory)のパスが使用されます。

使用例：
  ;;; "c:/foo"と"bar.l"をくっつける。
  (merge-pathnames "bar.l" "c:/foo")
  =&gt; "c:/foo/bar.l"

  (merge-pathnames "bar.l" "c:/foo/") &lt;--ディレクトリの末尾に/がつい
  =&gt; "c:/foo/bar.l"                      ているかとか気にしなくていい。
</description>
<seealso>file-namestring</seealso>
<seealso>directory-namestring</seealso>
<seealso>namestring</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>merge</title>
<type>Function</type>
<arguments>merge RESULT-TYPE SEQUENCE1 SEQUENCE2 PREDICATE &amp;key :key</arguments>
<package>lisp</package>
<description>
SEQUENCE1とSEQUENCE2を併合します。SEQUENCE1とSEQUENCE2は破壊されません。
PREDICATEによりSEQUENCE1とSEQUENCE2の値を比較し、非nilならば SEQUENCE1の値を 
nil ならば SEQUENCE2の値を順にマージしていきます。

  RESULT-TYPE : 結果となるシーケンスの型を指定します。
  PREDICATE   : シーケンス同士を比較する関数を指定します。
  :key        : 比較対照を取得する関数を指定します。

例
  (merge 'list '(1 2 3 5 8) '(2 4 6) #'&lt;) =&gt; (1 2 2 3 4 5 6 8)
  (merge 'string "AbCF" "aBcd" #'char-lessp) =&gt; "AabBCcdF"
</description>
<seealso>union</seealso>
<seealso>concatenate</seealso>
<seealso>stable-sort</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>message-box</title>
<type>Function</type>
<arguments>message-box MESSAGE &amp;optional TITLE STYLES &amp;key :button1 :button2 :button3 :button4 :button5 :no-wrap</arguments>
<package>editor</package>
<description>
yes-or-no-p 系よりも柔軟なダイアログを表示します。

  MESSAGE  : ダイアログに表示するメッセージを指定します。
  TITLE    : ダイアログのタイトルを指定します。
  STYLES   : ダイアログのスタイルをリストで指定します。
        :ok                     [OK] を表示します。
        :ok-cancel              [OK][キャンセル] を表示します。
        :yes-no                 [はい][いいえ] を表示します。
        :yes-no-cancel          [はい][いいえ][キャンセル] を表示します。
        :abort-retry-ignore     [中止][再試行][無視] を表示します。
        :information            (i) インフォメーションマークを表示します。
        :exclamation            (!) 感嘆符を表示します。
        :question               (?) 疑問符を表示します。
        :button1                ボタン 1 をデフォルト選択にします。
        :button2                ボタン 2 をデフォルト選択にします。
        :button3                ボタン 3 をデフォルト選択にします。
        :button4                ボタン 4 をデフォルト選択にします。
        :button5                ボタン 5 をデフォルト選択にします。
  :BUTTON1 : ボタン 1 のテキストを変更します。
  :BUTTON2 : ボタン 2 のテキストを変更します。
  :BUTTON3 : ボタン 3 のテキストを変更します。
  :BUTTON4 : ボタン 4 のテキストを変更します。
  :BUTTON5 : ボタン 5 のテキストを変更します。
  :NO-WRAP : MESSAGE が長すぎるときに折り返すかを制御します。
        t       長くとも折り返さない。
        nil     長ければ折り返す。

ボタンを押したときの戻り値は、それぞれ以下のとおりです。

  :ok     [OK] を選択
  :cancel [キャンセル] を選択
  :yes    [はい] を選択
  :no     [いいえ] を選択
  :abort  [中止] を選択
  :retry  [再試行] を選択
  :ignore [無視] を選択

使用例：
  ;;; [はい][いいえ][キャンセル] を表示し選択させます。
  (message-box "メールを送信しますか?" nil
    '(:yes-no-cancel :question :button1))
  =&gt; :yes

  ;;; ダイアログの結果を case で場合わけしてみる
  (case (message-box "メールを送信しますか?" nil
                     '(:yes-no-cancel :question :button1))
    (:yes (den8-draft-send t))
    (:no t)
    (t nil))
</description>
<seealso>yes-or-no-p</seealso>
<seealso>msgbox</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>message</title>
<type>Function</type>
<arguments>message FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
メッセージをステータスバーに出力します。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。
</description>
<seealso>clear-message</seealso>
<seealso>msgbox</seealso>
<seealso>message-box</seealso>
<seealso>minibuffer-message</seealso>
<seealso>with-interval-message</seealso>
<seealso>format</seealso>
<seealso>*status-window*</seealso>
<seealso>status-window-stream-p</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>min</title>
<type>Function</type>
<arguments>min NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数の中で最小の数値を返します。

使用例：
  (min 3)
  =&gt; 3
  (min -2 0 3)
  =&gt; -2
  (min 2.5 1)
  =&gt; 1
</description>
<seealso>max</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minibuffer-prompt</title>
<type>Function</type>
<arguments>minibuffer-prompt FMT &amp;rest ARGS</arguments>
<package>editor</package>
<description>
書式に従ってミニバッファにメッセージを表示します。
その後read-charを使ってキーボードから文字を読み込めば、
凝ったミニバッファからの入力が可能になります。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

使用例：
  ;;; 以下のようにすると、パスワード入力のようにエコーバックしない。
  minibuffer入力が可能
  (defun test1 ()
    (interactive)
    (let ((ans ""))
      (loop
        (minibuffer-prompt "From ~d: " 12)
        (let ((c (read-char *keyboard*)))
          (case c
            (#\RET (return ans))
            (#\C-g (quit))
            (t (setq ans (format nil "~a~c" ans c))))))))  

参考：
  wip/ftp.lのgetpass
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>minibuffer-window-p</title>
<type>Function</type>
<arguments>minibuffer-window-p WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウがミニバッファかどうかを返します。

  WINDOW：ミニバッファかどうかを調べるウィンドウ 

  t     ミニバッファである
  nil   ミニバッファではない

使用例：
  ;;; ミニバッファでは別のバッファに変更できないので別のウィンドウに移動する。
  (if (minibuffer-window-p (selected-window))
      (other-window))
  =&gt; t
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minibuffer-window</title>
<type>Function</type>
<arguments>minibuffer-window</arguments>
<package>editor</package>
<description>
ミニバッファのウインドウを取得します。

使用例：
  ;;; ミニバッファに移動する。
  (set-window (minibuffer-window))
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minor-mode-map</title>
<type>Function</type>
<arguments>minor-mode-map &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
set-minor-mode-mapで設定したキーマップを取得します。
</description>
<seealso>set-minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minusp</title>
<type>Function</type>
<arguments>minusp NUMBER</arguments>
<package>lisp</package>
<description>
NUMBER がゼロより小さければ t 、そうでなければ nil を返します。

使用例：
  (minusp 0)
  =&gt; nil
  (minusp -1)
  =&gt; t
  (minusp -0.00001)
  =&gt; t
</description>
<seealso>plusp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mod</title>
<type>Function</type>
<arguments>mod NUMBER DIVISOR</arguments>
<package>lisp</package>
<description>
(floor NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：
  (mod 13 4)
  =&gt; 1
  (mod -13 4)
  =&gt; 3
</description>
<seealso>floor</seealso>
<seealso>rem</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mode-line-format</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
モードラインのフォーマットを設定します。

使用例：
  (setq mode-line-format "--%*- %b (%M) [%k:%l] %P %f")

パラメタ：
  %*    変更あり          : **
        書込禁止          : %-
        変更あり・書込禁止: %*
        それ以外          : --
  %#*   変更あり: *
        変更なし: (空白)
  %r    書込可  : (空白)
        書込禁止: %
  %#r   書込可        : (空白)
        書込禁止      : %
        不完全バッファ: #
  %p    プログラム名
  %v    バージョン
  %$    プロセスID
  %h    ホスト名
  %#h   @ホスト名
  %b    バッファ名
  %f    File: ファイル名
  %#f   ファイル名
  %F    File: ファイル名。ファイル名がなければバッファ名
  %#F   ファイル名。ファイル名がなければバッファ名
  %M    モード(マイナーモード含む)
  %m    モード
  %k    エンコーディング
  %l    改行コード
  %i    IMEの状態
  %P    カーソル位置
  %/    カーソル位置がバッファ全体の何%の位置にあるか

備考：
  タイトルバーのフォーマットとほぼ同様ですが、
  %i, %P, %/ はモードラインのフォーマットでしか設定できません。

  %/, %$ は xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>update-mode-line</seealso>
<seealso>title-bar-format</seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>mode-name</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
モードの名前を格納しているローカル変数です。
？mode-nameとbuffer-modeは必ずローカル変数になるのでしょうか？
</description>
<seealso>buffer-mode</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>mode-specific-indent-command</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
indent-regionを参照のこと

使用例：
  ;;; 適当なモードで以下をevalしてみると、
  ;;; "ラベル:" のような行は行頭からになり、それ以外の行は8桁目からになる。
  (progn
    (make-local-variable 'mode-specific-indent-command)
    (setq mode-specific-indent-command
        #'(lambda () (save-excursion
                       (goto-bol)
                       (delete-horizontal-spaces)
                       (or (looking-at "^\\w+:") (indent-to 8))))))
</description>
<seealso>indent-region</seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>modify-text-attributes</title>
<type>Function</type>
<arguments>modify-text-attributes TAG &amp;key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :test :test-not :key</arguments>
<package>editor</package>
<description>
set-text-attribute で付けた領域の属性を変更します。
属性は引き継がれません。
例えば、set-text-attribute では :underline t としてから、
modify-text-attributes で :strike-out t としても、
下線と取り消し線の両方が表示される訳ではありません。

  TAG           set-text-attributeで指定したタグ
  :bold         ボールドで表示するかどうか
  :underline    下線付きで表示するかどうか
  :strike-out   取り消し線を表示するかどうか
  :foreground   文字色を整数で指定
  :background   背景色を整数で指定
  :prefix       使い方は不明
  :extend       行末の改行文字以降も変えるかどうか

使用例：
  ;;; バッファ全体をに下線を付けてから取り消し線にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  =&gt; t
  (modify-text-attributes 'all :strike-out t)
  =&gt; t
  (delete-text-attributes 'all)
  =&gt; t
</description>
<seealso>set-text-attribute</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>msgbox</title>
<type>Function</type>
<arguments>msgbox FMT &amp;rest ARGS</arguments>
<package>editor</package>
<description>
メッセージボックスを表示します。
[OK] ボタンとインフォメーションアイコンが表示されます。

  FMT  : format の出力書式と同じものを指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は :ok となります。

使用例：
  ;;; 出力書式で整形してみる。
  (msgbox "このバッファは ~A です。" buffer-mode)
  =&gt; :ok
</description>
<seealso>message-box</seealso>
<seealso>format</seealso>
<link></link>
<section>ダイアログ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>multiple-value-bind</title>
<type>Special Form</type>
<arguments>multiple-value-bind ({VAR}*) VALUES-FORM {declaration}* {FORM}*</arguments>
<package>lisp</package>
<description>
フォームが返す多値を受け取ります。広井さんの"xyzzy Lisp Programming"の
解説が分かり易いので掲載の許可を頂きました。以下を参照して下さい。

--- 引用開始  ---
複数の値を受け取るには、マクロ multiple-value-bind を使うと簡単です。 

multiple-value-bind (&amp;rest vars) values-form &amp;rest form

multiple-value-bind は、多値を返す関数 values-form を評価し、その結果を 
vars で定義した変数にセットします。変数は局所変数として設定されるので、
multiple-value-bind を実行している間だけ有効です。簡単な例を示しましょう。
Common Lisp には、整数でない値を整数に変換する関数 floor, ceiling, 
truncate, round が定義されています。これらの関数は２つの値（多値）を返します。

  (truncate 10 3)
  =&gt; 3

  (multiple-value-bind
  (q r)
  (truncate 10 3)
  (format nil "商 ~D, 余り ~D~%" q r))
  =&gt; "商 3, 余り 1"

関数 truncate は割り算を行って商と余りを返します。ふつうに truncate を呼
び出すと商を返すだけですが、multiple-value-bind を使うと、商のほかに余り
も受け取ることができます。q と r は truncate が返す値を受け取る変数です。
次に、truncate を評価して結果を変数にセットします。あとは、残りの form 
を順番に評価していきます。 multiple-value-bind は最後に評価した form の
値を返します。

もしも、返される値よりも変数の個数が多い場合、残りの変数には nil がセッ
トされます。逆に、返される値が変数よりも多い場合、余分な値は捨てられます。
次の例を見てください。

  (multiple-value-bind (q)
  (truncate 10 3)
  (list q))
  =&gt; (3)
  
  (multiple-value-bind (q r s)
  (truncate 10 3)
  (list q r s))
  =&gt; (3 1 nil)

最初の例では、変数 q しか定義されていないので、 q には商がセットされます
が余りは捨てられます。次の例では、変数 s が定義されていますが、truncate 
は２つの値しか返さないので、 s には nil がセットされます。
--- 引用終了 ---
</description>
<seealso>values</seealso>
<seealso>multiple-value-list</seealso>
<seealso>multiple-value-setq</seealso>
<link>http://www.geocities.jp/m_hiroi/</link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>multiple-value-list</title>
<type>Macro</type>
<arguments>multiple-value-list FORM</arguments>
<package>lisp</package>
<description>
関数が返した多値をリストで返します。

使用例：
  (defun foo () (values 1 2 3))
  =&gt; foo
  (foo)
  =&gt; 1
     2
     3
  (multiple-value-list (foo))
  =&gt; (1 2 3)
</description>
<seealso>values</seealso>
<seealso>multiple-value-call</seealso>
<seealso>multiple-value-bind</seealso>
<seealso>multiple-value-setq</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>multiple-value-setq</title>
<type>Special Form</type>
<arguments>multiple-value-setq VARIABLES FORM</arguments>
<package>lisp</package>
<description>
返された多値を個々の変数に設定します。
変数の個数よりもフォームが返した値の数が多いときには余った分は捨てられま
す。少ない場合には、足りない分だけnilが設定されます。

  VARIABLES : 変数のリスト
  FORM      : 評価するフォーム

使用例：
  ;;; valuesで多値を返した場合
  (setq a (values 1 2)) =&gt; 1
  a                     =&gt; 1
  (multiple-value-setq (a b) (values 1 2))
                        =&gt; 1
  a                     =&gt; 1
  b                     =&gt; 2
</description>
<seealso>multiple-value-bind</seealso>
<seealso>multiple-value-list</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>namestring</title>
<type>Function</type>
<arguments>namestring PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEの内容に応じて適切なフルパスを返すような動きをする。与えたのがフ
ルパスでなければ、先頭に(default-directory)を補ってフルパスらしくします。
使用例：
  (default-directory)
  =&gt;"C:/Applications/xyzzy/"

  (namestring "abc.txt")
  =&gt;"C:/Applications/xyzzy/abc.txt"

  (namestring "Z:/zzz.txt")
  =&gt;"Z:/zzz.txt"
</description>
<seealso>file-namestring</seealso>
<seealso>merge-pathnames</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>narrow-to-region</title>
<type>Function</type>
<arguments>narrow-to-region FROM TO</arguments>
<package>editor</package>
<description>
指定した範囲以外を移動・編集できないようにします。[C-x n]
save-restrictionのブロックが終了するか、widenすると元に戻ります。
point-min, point-maxの値も変わります。

使用例：
  C-SPCでマークを付けて、どっかに移動して、C-x n(narrow-to-region)とする
  と、指定したリージョンの外には移動できなくなります。私は置換のときに置き
  換える範囲を制限したり、キーボードマクロの範囲を制限したりするのによく使
  います。あとは、Lispコードの中で特定の範囲だけいじるときなんかにも使いま
  す。
</description>
<seealso>hide-restricted-region</seealso>
<seealso>save-restriction</seealso>
<seealso>widen</seealso>
<seealso>point-min</seealso>
<seealso>point-max</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nbutlast</title>
<type>Function</type>
<arguments>nbutlast LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの最後のN要素分を除いたリストを返します。
引数 LIST は破壊されます。

使用例：
  ;;; 最後の要素を取り除きます。
  (setq foo '(1 2 3))
  =&gt; (1 2 3)
  (nbutlast foo)
  =&gt; (1 2)
  foo
  =&gt; (1 2)
</description>
<seealso>butlast</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nconc</title>
<type>Function</type>
<arguments>nconc &amp;rest LISTS</arguments>
<package>lisp</package>
<description>
複数のリストを引数にとってそれらを結合したリストを返します。
引数は破壊されます。

使用例：
  ;;; リストをくっつけてみる。
  (setq x '(a b c))
  (setq y '(d e f))
  (nconc x y)
  =&gt; (a b c d e f) 
  x
  =&gt; (a b c d e f)
  y
  =&gt; (d e f)
</description>
<seealso>append</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>need-buffer-save-p</title>
<type>Function</type>
<arguments>need-buffer-save-p BUFFER</arguments>
<package>editor</package>
<description>
バッファが保存が必要かを返します。
need-not-saveと関連しています。

  t     バッファの保存が必要
  nil   バッファの保存が必要ではない
</description>
<seealso>need-not-save</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>need-not-save</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
保存する必要があるかどうかを設定します。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。例えば、*scratch*の様に書き捨てたりするバッファでは、
保存の必要はないので、tになっています。

  t     保存の必要はない
  nil   保存する

使用例：
  ;;; 現在のバッファは保存の必要はなし。
  (make-local-variable 'need-not-save)
  =&gt; t
  (setq need-not-save t)
  =&gt; t
</description>
<seealso>need-buffer-save-p</seealso>
<seealso>setup-temp-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>newline-and-indent</title>
<type>Function</type>
<arguments>newline-and-indent &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
改行後、文字が存在する直前の行と同じ桁数だけインデントをします。
モードに依存したインデントコマンドは使用しません。[LFD], [C-j]
</description>
<seealso>newline</seealso>
<seealso>indent-relative</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>newline</title>
<type>Function</type>
<arguments>newline &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
改行を挿入します。[RET], [C-m]
</description>
<seealso>newline-and-indent</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>next-buffer</title>
<type>Function</type>
<arguments>next-buffer</arguments>
<package>editor</package>
<description>
次のバッファに切替えます。 [Home]
エディタ上で現在選択されているウィンドウの中のバッファが変わるだけです。

バッファタブの順番にそってnext-bufferしたいのならば、
*next-buffer-in-tab-order*を参照して下さい。
</description>
<seealso>previous-buffer</seealso>
<seealso>*next-buffer-in-tab-order*</seealso>
<seealso>other-buffer</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>next-error</title>
<type>Function</type>
<arguments>next-error &amp;optional ARG</arguments>
<package>editor</package>
<description>
次のエラーの該当行にジャンプします。[F11], [C-x `]
</description>
<seealso>*error-regexp-list*</seealso>
<seealso>first-error</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>next-line-add-newlines</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファの最後尾でnext-line系の移動をしたときの動作を設定します。

  t   空行を挿入します
  nil 何もしません

使用例：
  (setq next-line-add-newlines t)
</description>
<seealso>next-line</seealso>
<link></link>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>next-line</title>
<type>Function</type>
<arguments>next-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行後の物理行に移動します。 
移動の前後で goal-column を保存します。

戻り値:
  1行でも移動できたときは t 、それ以外は nil です。
</description>
<seealso>next-virtual-line</seealso>
<seealso>previous-line</seealso>
<seealso>forward-line</seealso>
<seealso>goal-column</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>next-page</title>
<type>Function</type>
<arguments>next-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
指定ページ分画面を下スクロールします。[C-v], [PageDown]
*page-scroll-half-window* が non nil なら半画面ずつスクロールします。
</description>
<seealso>previous-page</seealso>
<seealso>*page-scroll-half-window*</seealso>
<seealso>*page-scroll-keep-window-position*</seealso>
<seealso>*next-screen-context-lines*</seealso>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>next-virtual-line</title>
<type>Function</type>
<arguments>next-virtual-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行後の表示行に移動します。 [C-n], [Down]
  t    最終行以外の場合
  nil  最終行の場合
</description>
<seealso>next-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>nil</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
偽を表す定数です。
</description>
<seealso>t</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>ninth</title>
<type>Function</type>
<arguments>ninth X</arguments>
<package>lisp</package>
<description>
list の 9 番目の要素を返します。

  (ninth X) = (nth 8 X)

使用例：
  (ninth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 9
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>no-or-yes-p</title>
<type>Function</type>
<arguments>no-or-yes-p FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」のボタン付メッセージボックスを表示します。
デフォルトは「いいえ」です。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (no-or-yes-p "foo")
  =&gt; t          ; 「はい」を選択
</description>
<seealso>yes-or-no-p</seealso>
<seealso>y-or-n-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<section>ダイアログ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>not-modified</title>
<type>Function</type>
<arguments>not-modified</arguments>
<package>editor</package>
<description>
バッファの変更フラグをクリアします。[ESC ~]
つまり変更されてないことになります。
(set-buffer-modified-p nil)のinteractive版です。
</description>
<seealso>set-buffer-modified-p</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>not</title>
<type>Function</type>
<arguments>not X</arguments>
<package>lisp</package>
<description>
否定を返します。
non nilならばnilを返し、nilならばtを返します。機能としてはnullと同じです。
</description>
<seealso>null</seealso>
<section>その他</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>notany</title>
<type>Function</type>
<arguments>notany PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、 nil をすぐに返します。
PREDICATEを満たす要素が見つからない時は t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>notevery</seealso>
<seealso>some</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>notevery</title>
<type>Function</type>
<arguments>notevery PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、t をすぐに返します。
全ての要素がPREDICATEを満たす場合、 nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>notany</seealso>
<seealso>every</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nreconc</title>
<type>Function</type>
<arguments>nreconc X Y</arguments>
<package>lisp</package>
<description>
X を反転させて Y を結合したリストを返します。
引数 X は破壊されます。

  (nreconc x y) == (nconc (nreverse x) y)

nreconcの方が効率が良いようです。
</description>
<seealso>revappend</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nreverse</title>
<type>Function</type>
<arguments>nreverse SEQUENCE</arguments>
<package>lisp</package>
<description>
SEQUENCE を逆順にした新しいシーケンスを作成して返します。
引数 SEQUENCE は破壊されます。

使用例：
  (setq lst '(a b c))
  =&gt; (a b c)
  (nreverse lst)
  =&gt; (c b a)
  lst
  =&gt; (a)
</description>
<seealso>reverse</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-capitalize</title>
<type>Function</type>
<arguments>nstring-capitalize STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING の内部の単語の先頭を大文字に、それ以外を小文字にした文字列を返します。
引数 STRING は破壊されます。

使用例：  
  (setq foo "tHis iS a pEn.")
  =&gt; "tHis iS a pEn."
  (nstring-capitalize foo)
  =&gt; "This Is A Pen."
  foo
  =&gt; "This Is A Pen."
</description>
<seealso>string-capitalize</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-downcase</title>
<type>Function</type>
<arguments>nstring-downcase STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING を小文字にした文字列を返します。引数 STRING は破壊されます。

使用例：  
  (setq foo "XyZzY")
  =&gt; "XyZzY"
  (nstring-downcase foo)
  =&gt; "xyzzy"
  foo
  =&gt; "xyzzy"  
</description>
<seealso>string-downcase</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-upcase</title>
<type>Function</type>
<arguments>nstring-upcase STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING を大文字にした文字列を返します。引数 STRING は破壊されます。

使用例：
  (setq foo "xyzzy")
  =&gt; "xyzzy"
  (nstring-upcase foo)
  =&gt; "XYZZY"
  foo
  =&gt; "XYZZY"
</description>
<seealso>string-upcase</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsublis</title>
<type>Function</type>
<arguments>nsublis ALIST TREE &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
TREE の中で ALIST の :key との :test を満たすものを VALUE に置き換えたリストを返します。
引数 TREE は破壊されます。

使用例：
  ;;; fooの変換テーブルの内容に基づいてbarを変換します。
  (setq foo '((1 . #\a) (2 . #\b) (3 . #\c)))
  =&gt; ((1 . #\a) (2 . #\b) (3 . #\c))
  (setq bar '(1 (2 3) ((4 5 6) (7 8 9))))
  =&gt; (1 (2 3) ((4 5 6) (7 8 9)))
  (nsublis foo bar)
  =&gt; (#\a (#\b #\c) ((4 5 6) (7 8 9)))
  bar
  =&gt; (#\a (#\b #\c) ((4 5 6) (7 8 9)))
</description>
<seealso>sublis</seealso>
<seealso>nsubst</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsubst-if-not</title>
<type>Function</type>
<arguments>nsubst-if-not NEW TEST TREE &amp;key :key</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TREEが破壊される点を除いてsubst-if-notと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  =&gt; ((123 "abc") '(456 "123") (789 #\a))
  (nsubst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  =&gt; ((123 0) (0 (456 0)) (789 0))
  a
  =&gt; ((123 0) (0 (456 0)) (789 0))
</description>
<seealso>subst-if</seealso>
<seealso>nsubst-if</seealso>
<seealso>nsubst</seealso>
<seealso>nsubstitute-if-not</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsubst-if</title>
<type>Function</type>
<arguments>nsubst-if NEW TEST TREE &amp;key :key</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たすものがあればNEWに置き換えたものを返します。
TREEが破壊される点を除いてsubst-ifと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  =&gt; ((1 2) ((1 3) (1 (1 3))))
  (nsubst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  =&gt; ((0 2) ((0 0) (0 (0 0))))
  a
  =&gt; ((0 2) ((0 0) (0 (0 0))))
</description>
<seealso>subst-if</seealso>
<seealso>nsubst-if-not</seealso>
<seealso>nsubst</seealso>
<seealso>nsubstitute-if</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsubst</title>
<type>Function</type>
<arguments>nsubst NEW OLD TREE &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
TREE の中で OLD を NEW に置き換えたTREEを返します。
引数 TREE は破壊されます。

使用例：
  ;;; 階層のあるツリーをnsubstしてみる。aは破壊される。
  (setq a '((1 2) ((1 3) (1 4))))       =&gt; ((1 2) ((1 3) (1 4)))
  (nsubst 5 1 a)                        =&gt; ((5 2) ((5 3) (5 4)))
  a                                     =&gt; ((5 2) ((5 3) (5 4)))
</description>
<seealso>subst</seealso>
<seealso>nsublis</seealso>
<seealso>nsubst-if</seealso>
<seealso>nsubst-if-not</seealso>
<seealso>nsubstitute</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsubstitute-if-not</title>
<type>Function</type>
<arguments>nsubstitute-if-not NEWITEM TEST SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、 non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>nsubst-if-not</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if</seealso>
<seealso>substitute-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nsubstitute-if</title>
<type>Function</type>
<arguments>nsubstitute-if NEWITEM TEST SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、 non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>nsubst-if</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if-not</seealso>
<seealso>substitute-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nsubstitute</title>
<type>Function</type>
<arguments>nsubstitute NEWITEM OLDITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCE に対して OLDITEM との :test を満足する要素を NEWITEM に置き換えたシーケンスを返します。
引数 SEQUENCE は破壊されます。

  :test     : テストを行う2項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>nsubst</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if</seealso>
<seealso>nsubstitute-if-not</seealso>
<seealso>substitute</seealso>
<seealso>nsbulis</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nth</title>
<type>Function</type>
<arguments>nth N LIST</arguments>
<package>lisp</package>
<description>
リストの N 番目の要素を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

  (nth n x) == (car (nthcdr n x))

使用例：
  (nth 2 '(1 2 3 4))
  =&gt; 3
  (nth 10 '(1 2 3 4))
  =&gt; nil
  (nth -3 '(1 2 3 4))
  =&gt; 範囲外の値です: -3
</description>
<seealso>nthcdr</seealso>
<seealso>elt</seealso>
<seealso>first</seealso>
<seealso>second</seealso>
<seealso>third</seealso>
<seealso>fourth</seealso>
<seealso>fifth</seealso>
<seealso>sixth</seealso>
<seealso>seventh</seealso>
<seealso>eighth</seealso>
<seealso>ninth</seealso>
<seealso>tenth</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nthcdr</title>
<type>Function</type>
<arguments>nthcdr N LIST</arguments>
<package>lisp</package>
<description>
リストの N 番目の cdr を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

使用例：
  (nthcdr 1 '(1 2 3 4))
  =&gt; (2 3 4)
  (nthcdr 10 '(1 2 3 4))
  =&gt; nil
  (nthcdr -3 '(1 2 3 4))
  =&gt; 範囲外の値です: -3
</description>
<seealso>nth</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>null</title>
<type>Function</type>
<arguments>null OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが()ならば t 、それ以外なら nil を返します。

  (null x) == (typep x 'null) == (eq x '())
</description>
<seealso>not</seealso>
<seealso>endp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>number-of-function-bar-labels</title>
<type>Function</type>
<arguments>number-of-function-bar-labels</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルの数を返します。非表示の場合でも数値を返します。
</description>
<seealso>set-number-of-function-bar-labels</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>numberp</title>
<type>Function</type>
<arguments>numberp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが数値ならばt、それ以外ならnilを返します。

  (numberp x) == (typep x 'number)
</description>
<seealso>integerp</seealso>
<seealso>floatp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>numerator</title>
<type>Function</type>
<arguments>numerator RATIONAL</arguments>
<package>lisp</package>
<description>
分数の分子を返します。
</description>
<seealso>denominator</seealso>
<seealso>/</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>oddp</title>
<type>Function</type>
<arguments>oddp INTEGER</arguments>
<package>lisp</package>
<description>
INTEGERが奇数ならばt、そうでなければnilを返します。

使用例：  
  (oddp 1)
  =&gt; t
  (oddp 0)
  =&gt; nil
  (oddp -35)
  =&gt; t
</description>
<seealso>evenp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>OLEオートメーションの使用例</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
; 意味もなく全部のシートに「東西南北」を書き込む
(setq application (ole-create-object "Excel.Application"))
(ole-putprop application 'visible 1)
(setq workbook (ole-method (ole-getprop application 'Workbooks) 'Add))
(setq numbers-of-worksheets
      (ole-getprop
       (ole-getprop workbook 'worksheets)
       'count))
(setq worksheet-index 1)
(while (&lt;= worksheet-index numbers-of-worksheets)
  (setq worksheet
 (ole-getprop workbook 'Worksheets worksheet-index))
  (ole-putprop (ole-method worksheet 'Range "A1:D1")
        'value #("東" "西" "南" "北"))
  (setq worksheet-index (+ worksheet-index 1)))


こんな小細工をしてみたんですけどどうでしょう?

(defmacro $ (obj prop &amp;rest args)
  `(ole-method ,obj ',prop ,@args))

(defsetf $ (obj prop &amp;rest args) (x)
  `(progn
     (ole-putprop ,obj ',prop ,x ,@args)
     ,x))

(let (app workbook worksheet range)
  (setq app (ole-create-object "Excel.Application"))
  (setf ($ app Visible) t)
  (setq workbook ($ ($ app Workbooks) Add))
  (setq worksheet ($ workbook Worksheets 1))
  (setf ($ ($ worksheet Range "A1:D1") Value) '("North" "South" "East" "West"))
  (setf ($ ($ worksheet Range "A2:B2") Value) #(5.2 10))
  (setf ($ ($ worksheet Range "C2") Value) 8)
  (setf ($ ($ worksheet Range "D2") Value) 20)

  (setq range ($ worksheet Range "A1:D2"))
  ($ range Select)
  ($ ($ workbook Charts) Add)
  (sit-for 5)

  (setf ($ workbook saved) t)
  ($ ($ app ActiveWorkbook) Close 0)
  ($ app Quit))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>open-filer</title>
<type>Function</type>
<arguments>open-filer</arguments>
<package>editor</package>
<description>
ファイラを開きます。[C-c C-f]
filerのinteractive版です。
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>open-line</title>
<type>Function</type>
<arguments>open-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置を変えないで改行を挿入します。[C-o]
</description>
<seealso>split-line</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>open-network-stream</title>
<type>Function</type>
<arguments>open-network-stream BUFFER HOSTNAME SERVICE &amp;key :incode :outcode :eol-code</arguments>
<package>editor</package>
<description>
ホストのポートとのTCP接続を開きます。
成功すれば接続をBUFFERのサブプロセスとして返します。

使用例：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (progn
    (defun filter (proc in) (insert in))
    (setq proc (open-network-stream (selected-buffer) "www.yahoo.co.jp" 80))
    (process-send-string proc "GET / HTTP/1.0\n\n")
    (set-process-filter proc 'filter))
  =&gt; HTTP/1.1 200 OK
     Server: ...
</description>
<seealso>connect</seealso>
<seealso>make-process</seealso>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>open</title>
<type>Function</type>
<arguments>open FILENAME &amp;key :direction :if-exists :if-does-not-exist :encoding :share</arguments>
<package>lisp</package>
<description>
ファイルへのストリームを作成して返します。ストリームのクローズには close 
を使いますが、 with-open-stream を使えば close の手間が省ける上に安全です。

  FILENAME           : ストリームを作成するファイル名を指定します。
  :direction         : ストリームの入出力の方向を指定します。
        :input          入力（省略時）
        :output         出力
        :io             入出力
        :probe          ファイルテスト？
                        戻り値のストリームは無効になっています。
  :if-exists         : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :skip           エラーは出力せず、nilを返します。
        :append         既存ファイルに追加します。
                        ストリームの位置はファイル終端になります。
        :overwrite      上書きします。
        :new-version    ファイルを作成します。
                        既にあれば上書きされます。
        ---- 以下詳細不明 ----
        :supersede      更新？
        :rename         リネーム用にストリームを開く？
        :rename-and-delete  リネーム用にストリームを開く？
  :if-does-not-exist : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :create         エラーは出力せず、入力ファイルを作成します。
  :encoding          : エンコーディングのモードを指定します。
        :binary         バイナリモードです。
        :text           テキストモードです。（省略時は:text）
        :canonical      :text と同じ意味になります。
        :raw            改行コードの扱いが、LF のみになります。
                        それ以外は :text と同じです。
  :share             : ファイルの共有モードを指定します。
        省略時　　　　　:direction が :input または :probe なら :read に、
                        それ以外は共有不可になります。
        :read           読み取りの共有が可能になります。
        :write          書き込みの共有が可能になります。
        :read-write     読み書きの共有が可能になります。

使用例：
  ;;; ストリーム経由でファイルに書き出してみる。
  (setq foo (open "abc.txt" :direction :output))
  =&gt; #&lt;file-output stream: C:/applications/xyzzy/abc.txt&gt;
  (princ "test" foo)
  =&gt; "test"
  (close foo)
  =&gt; t
</description>
<seealso>close</seealso>
<seealso>clear-input</seealso>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<seealso>with-open-file</seealso>
<seealso>with-open-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>or</title>
<type>Macro</type>
<arguments>or &amp;rest FORMS</arguments>
<package>lisp</package>
<description>
フォームがnilの間だけ順番に評価します。
フォームが一つでもnon-nilならば、そこで評価を中断してフォームの値を返し
て終了します。全てのフォームがnilならば、nilを返します。

  ;;; exp1 がnilならexp2を実行し、
  ;;; exp2 がnilならexp3を実行し、
  ;;; exp3 がnilなら......
  ;;; 最後に実行したexpの値を返す。
  (or exp1 exp2 exp3 ...)

ルールに従って一つだけ値を定める場合に向いていると思います。

  (or (get-buffer-file-name) ; バッファにファイル名があればそれを使う。
      *foo*                  ; ファイル名がなければ、変数*foo*の値を使う。
      (read-string "foo: ")) ; *foo*にも値が無ければ入力してもらう。
</description>
<seealso>and</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>pairlis</title>
<type>Function</type>
<arguments>pairlis KEYS DATA &amp;optional A-LIST</arguments>
<package>lisp</package>
<description>
二つのリスト KEYS と DATA から要素を一つずつ組み合わせた連想リストを作って返します。
A-LIST が与えられればそれに加えて返します。

  '(1 2 3 4 5) ─┬→ '((5 . e) (4 . d) (3 . c) (2 . b) (1 . a))
  '(a b c d e) ─┘

使用例：
  (pairlis '(one two) '(1 2) '((three . 3)))
  =&gt; ((two . 2) (one . 1) (three . 3))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-build-number</title>
<type>Function</type>
<arguments>os-build-number</arguments>
<package>editor</package>
<description>
Windows NT 4.00.13811 + Service Pack 3 の場合

使用例：  
  (os-build-number)
  =&gt; 1381
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-csd-version</title>
<type>Function</type>
<arguments>os-csd-version</arguments>
<package>editor</package>
<description>
Windows NT 4.00.1381 + Service Pack 3 の場合

使用例：
  (os-csd-version)
  =&gt; "Service Pack 3"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-major-version</title>
<type>Function</type>
<arguments>os-major-version</arguments>
<package>editor</package>
<description>
OSのメジャーバージョンを返します。

使用例：
  (os-major-version)
  =&gt; 4
</description>
<seealso>machine-name</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-minor-version</title>
<type>Function</type>
<arguments>os-minor-version</arguments>
<package>editor</package>
<description>
OSのマイナーバージョンを返します。

使用例：
  (os-minor-version)
  =&gt; 0
</description>
<seealso>machine-name</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-platform</title>
<type>Function</type>
<arguments>os-platform</arguments>
<package>editor</package>
<description>
OSの種類を返します。OSが95とNTで動作を変えたいときなどに使います。返され
る値は文字列ではなくシンボルです。

参考：
  OS            シンボル
  ----          ----
  Windows???    win32s
  Windows95     windows-95
  Windows98     windows-98
  WindowsMe     windows-me
  WindowsNT     windows-nt
  Windows2000   windows-2000
  WindowsXP     windows-xp
  WindowsVista  windows-vista
  Windows7      windows-7
  Windows8      windows-8

使用例：
  (os-platform)
  =&gt; windows-nt
</description>
<seealso>machine-name</seealso>
<seealso>si:getenv</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>other-buffer</title>
<type>Function</type>
<arguments>other-buffer &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
最近、表示されていたバッファを返します。
</description>
<seealso>bury-buffer</seealso>
<seealso>next-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>other-window</title>
<type>Function</type>
<arguments>other-window &amp;optional (ARG 1 F) NO-ERROR</arguments>
<package>editor</package>
<description>
分割されたウィンドウの中を移動します。[C-x o]

  ARG      : ARG番目のウィンドウに移動します。
             負数であれば、ARG番前のウィンドウに移動します。
  NO-ERROR : (count-windows)以上の数値を指定した場合の動作を制御します。
        nil     (count-windows)以上の数値を指定するとエラーを発生します。
        t       (count-windows)以上の数値を指定してもtを返す。
</description>
<seealso>move-previous-window</seealso>
<seealso>selected-window</seealso>
<seealso>count-windows</seealso>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>overwrite-char</title>
<type>Function</type>
<arguments>overwrite-char C &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
文字を上書きします。

使用例：
  ;;; 半角空白で上書きする。
  (overwrite-char #\SPC)
  =&gt; t
</description>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>package-name</title>
<type>Function</type>
<arguments>package-name PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージの名称を取得します。

使用例：
  (package-name (find-package "ed"))
  =&gt; "editor"
</description>
<seealso>package-nicknames</seealso>
<seealso>find-package</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>packagep</title>
<type>Function</type>
<arguments>packagep OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがpackageならt、それ以外ならnilを返します。

使用例：
  ;;; 指定された文字列のパッケージがあるかを調べる。
  (setq pkg (find-package "win32"))     =&gt; nil
  (packagep pkg)                        =&gt; nil
  (setq pkg (find-package "winapi"))    =&gt; #&lt;package: winapi&gt;
  (packagep pkg)                        =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>parse-integer</title>
<type>Function</type>
<arguments>parse-integer STRING &amp;key :start :end :radix :junk-allowed</arguments>
<package>lisp</package>
<description>
文字列から整数を読み取ります。
C言語のatoiに相当します。

  STRING  : 対象の文字列
  :start  : 読み取り開始位置
  :end    : 読み取り終了位置
  :radix  : 基数
  :junk-allowed
          : non-nilなら前後の空白を無視します

多値で二つの値を返します。
一つ目は読み込んだ整数値です。読み込めなかった場合はnilを返します。
二つ目は読んだ最後の文字の次の文字のインデックスです。文字列の最後まで読
んだ場合は文字列の長さになります。

例:
  (parse-integer "16")
  =&gt;16
  =&gt;2
  (parse-integer "016")
  =&gt;16
  =&gt;3
  (parse-integer " 16 ")
  =&gt;不正な数値の形式です: " 16 "
  (parse-integer " 16 " :junk-allowed t)
  =&gt;16
  =&gt;3

備考:
  Common Lispの同名の関数と動作が異なります。
  Common Lispのparse-integerは:junk-allowedがnilでも前後の空白を無視し、
  non-nilのときは前後の空白のみならず数字以外の文字も無視します。
</description>
<seealso></seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>parse-point-syntax</title>
<type>Function</type>
<arguments>parse-point-syntax &amp;optional POINT</arguments>
<package>editor</package>
<description>
指定された位置のシンタックスを返します。

  :string  set-syntax-string で指定されたキャラクタに囲まれた領域           
  :comment set-syntax-comment-column
           set-syntax-start-c++-comment
           set-syntax-end-c++-comment
           set-syntax-start-comment
           set-syntax-end-comment
           set-syntax-start-multi-comment
           set-syntax-end-multi-comment
           set-syntax-start-column-comment
           で指定された領域
  :tag     set-syntax-tag で指定されたキャラクタに囲まれた領域
           (ただし html-highlight-mode がnon-nilのときのみ)
  nil      上記以外の領域
</description>
<seealso>syntax-table</seealso>
<seealso>html-highlight-mode</seealso>
<seealso>set-syntax-string</seealso>
<seealso>set-syntax-comment-column</seealso>
<seealso>set-syntax-start-c++-comment</seealso>
<seealso>set-syntax-end-c++-comment</seealso>
<seealso>set-syntax-start-comment</seealso>
<seealso>set-syntax-end-comment</seealso>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>set-syntax-start-column-comment</seealso>
<seealso>set-syntax-tag</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>paste-from-clipboard</title>
<type>Function</type>
<arguments>paste-from-clipboard</arguments>
<package>editor</package>
<description>
クリップボードの内容を貼り付けます。[S-Insert]
</description>
<seealso>paste-rectangle-from-clipboard</seealso>
<seealso>si:*paste-hook*</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>paste-rectangle-from-clipboard</title>
<type>Function</type>
<arguments>paste-rectangle-from-clipboard</arguments>
<package>editor</package>
<description>
paste-from-clipboardとは異なり、クリップボードの内容を矩形で貼り付けます。
[S-C-Insert]
</description>
<seealso>paste-from-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>path-equal</title>
<type>Function</type>
<arguments>path-equal PATHNAME1 PATHNAME2</arguments>
<package>lisp</package>
<description>
PATHNAME1とPATHNAME2が同じパスを指していればt、そうでなければnilを返します。

使用例：
  (path-equal "C:/Windows/" "c:/windows")
  =&gt; t
</description>
<seealso>sub-directory-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-device</title>
<type>Function</type>
<arguments>pathname-device PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのドライブ名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  =&gt; "//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  =&gt; nil

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt; "C:/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  "C"
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-host</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-directory</title>
<type>Function</type>
<arguments>pathname-directory PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのディレクトリ名を返します。各階層ごとの名前を要素とするリスト形
式で返されます。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-directory a)
  =&gt;("Applications" "xyzzy")
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-device</seealso>
<seealso>pathname-host</seealso>
<seealso>directory-namestring</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-host</title>
<type>Function</type>
<arguments>pathname-host PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのホスト名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  =&gt;"//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =&gt;"SAMURAI"

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =&gt;nil
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-device</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-match-p</title>
<type>Function</type>
<arguments>pathname-match-p PATHNAME WILDNAME</arguments>
<package>lisp</package>
<description>
PATHNAME が WILDNAME で指定されたワイルドカードにマッチするかどうかを
返します。

  PATHNAME : 検査対象のパス文字列
  WILDNAME : ワイルドカード文字列
             先頭文字が | の場合は否定の意味となる。
             *brackets-is-wildcard-character* の値が non-nil の場合は
             文字列中の [...] をワイルドカードと見なす。

戻り値：
  t    PATHNAME が WILDNAME にマッチする。
  nil  PATHNAME が WILDNAME にマッチしない。

使用例：
  (setq p (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (setq w (merge-pathnames "xyzzy.*" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.*"

  (wild-pathname-p p)
  =&gt;nil

  (wild-pathname-p w)
  =&gt;t

  (pathname-match-p p w)
  =&gt;t

  (pathname-match-p p (concat "|" w))
  =&gt;nil

  (setq w "*/xyzzy.ini")
  =&gt;"*/xyzzy.ini"

  (pathname-match-p p w)
  =&gt;nil

  (pathname-match-p p (concat "|" w))
  =&gt;t
</description>
<seealso>wild-pathname-p</seealso>
<seealso>*brackets-is-wildcard-character*</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-name</title>
<type>Function</type>
<arguments>pathname-name PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのファイル名（拡張子無し）を返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-name a)
  =&gt;"xyzzy"
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-device</seealso>
<seealso>pathname-host</seealso>
<seealso>file-namestring</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-type</title>
<type>Function</type>
<arguments>pathname-type PATHNAME</arguments>
<package>lisp</package>
<description>
ファイル名の拡張子を取り出します。拡張子がなければnilを返します。

  PATHNAME : 拡張子を取り出すファイル名を指定します。

使用例：
  ;;; foo.lzh
  (pathname-type "foo.lzh")
  =&gt;"lzh"
  (pathname-type "foo/bar/zzz.txt")
  =&gt;"txt"
</description>
<seealso>pathname-name</seealso>
<seealso>file-namestring</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>peek-char</title>
<type>Function</type>
<arguments>peek-char &amp;optional PEEK-TYPE INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
ストリームから文字を覗き見ます。read-charしてunread-charするようなもんです。

  PEEK_TYPE      : 覗き見る文字の種類を指定します。
        nil        全ての種類の文字を受け付けます。
        文字       指定された文字とEOFのみを受け付けます。
        上記以外   空白以外を受け付けます。
                   空白には 水平タブ 改行 垂直タブ 改ページ 行頭復帰 スペース が該当します。
                   キーでは TAB C-i LFD C-j RET C-m SPC が該当します。
  INPUT-STREAM   : 入力元のストリームを指定します。
  EOF-ERROR-P    : EOFをエラーとするかどうかを指定します。
        t          エラーとします。
        nil        エラーとせず、nilを返します。
  EOF-VALUE      : EOFのときにnilの代わりに返す文字を指定します。
  RECURSIVE-P    : 結果に影響しません。

戻り値は文字です。

使用例：
  ;;; 標準入力の文字を除き見る。
  (peek-char nil *standard-input* nil nil)
</description>
<seealso>read-char</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>perform-replace</title>
<type>Function</type>
<arguments>perform-replace PATTERN REPLACEMENT QUERY REGEXP INTERACTIVE-P NOERROR</arguments>
<package>editor</package>
<description>
バッファを検索して文字列を置換します。特に判断がいらないのならば
scan-bufferするよりも簡単です。replace-bufferを使って実装されています。
  
  PATTERN       : 置換前文字列です。
  REPLACEMENT   : 置換後文字列です。\1, \2 ... \9も使用できます。
  QUERY         : 確認あり？
  REGEXP        : 正規表現？
  INTERACTIVE-P : 対話的かどうか？
                  undoの記録の仕方と、メッセージの出し方が違うだけ
  NOERROR       : 文字列が見つからないときエラーを出す？

互換性：
  muleにはなさそう。
</description>
<seealso>replace-buffer</seealso>
<seealso>replace-string</seealso>
<seealso>substitute-string</seealso>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>phase</title>
<type>Function</type>
<arguments>phase Z</arguments>
<package>lisp</package>
<description>
複素数の偏角を求めます。
戻り値はラジアン単位です。

  (phase -1)
  =&gt;3.141593
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>plain-error</title>
<type>Function</type>
<arguments>plain-error &amp;rest REST</arguments>
<package>lisp</package>
<description>
（詳細不明）
</description>
<section>エラー</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>plusp</title>
<type>Function</type>
<arguments>plusp NUMBER</arguments>
<package>lisp</package>
<description>
NUMBERがゼロより大きければt、そうでなければnilを返します。

使用例：
  (plusp 0)
  =&gt; nil
  (plusp 1)
  =&gt; t
  (plusp 0.00001)
  =&gt; t
</description>
<seealso>minusp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>point-max</title>
<type>Function</type>
<arguments>point-max</arguments>
<package>editor</package>
<description>
カレントバッファの一番大きなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り、カレントバッファの大きさになります。 

使用例：
  (point-max)
  =&gt; 189568
</description>
<seealso>point-min</seealso>
<seealso>narrow-to-region</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>point-min</title>
<type>Function</type>
<arguments>point-min</arguments>
<package>editor</package>
<description>
カレントバッファの一番小さなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り 0 になります。 

使用例：
  (point-min)
  =&gt; 0
</description>
<seealso>point-max</seealso>
<seealso>narrow-to-region</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>point</title>
<type>Function</type>
<arguments>point</arguments>
<package>editor</package>
<description>
この関数は、ポイントの位置を integer として返します。 
goto-char でその位置に飛ぶことが出来ます。バッファの先頭ではpoint-minに
等しく、バッファの最後ではpoint-maxに等しいです。

使用例：
  (point)
  =&gt; 175
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pop-to-buffer</title>
<type>Function</type>
<arguments>pop-to-buffer BUFFER &amp;optional POPUP-WINDOWS VERT-P</arguments>
<package>editor</package>
<description>
指定されたバッファを表示します。POPUP-WINDOWS が指定された場合画面を分割
してバッファを表示します。ウィンドウが既に分割されていたら、新たに分割せ
ずにそのウィンドウに移動し表示します。

表示幅が指定された場合には、縦分割が指定されていない場合、モード行を表示
している状態で、およそ指定された数値分の行数が表示できる大きさのウィンド
ウができます。
縦分割が指定された場合には、上下ではなく左右に分割し、行番号を表示してい
ない状態で、およそ指定された数値分の列数が表示できる大きさのウインドウが
できます。

  BUFFER        : バッファ、または、バッファの名前を指定します。
  POPUP-WINDOWS : 分割する行数／列数を指定します。
        t             ニ分割します。
        整数          指定行数／列数で分割します。
        nil           ウィンドウが分割されていない場合でも新たに
                      分割しません。
  VERT-P        : 縦方向に分割します。
        non-nil       左右にニ分割します。
        nil           上下にニ分割します。

使用例：
  ;;; den8の場合
  (defvar *den8-summary-window-ratio* 1/4)

  (defun den8-viewer ()
    (let ((view (switch-to-buffer "*Den8 View*")))     ; Viewを作る
      (let ((sum (switch-to-buffer "*Den8 Summary*"))) ; Summaryを作る
           &lt;初期化・省略&gt; ))
    (delete-other-windows)        ; 自分以外の全部のウインドウを消す
    (den8-popup-summary-buffer))  ; ２分割して、上下にサマリと内容を表示

  (defun den8-popup-summary-buffer ()
    (pop-to-buffer den8-summary-buffer
       (truncate (* (screen-height) *den8-summary-window-ratio*))))
</description>
<seealso>split-window</seealso>
<seealso>split-window-vertically</seealso>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>pop</title>
<type>Macro</type>
<arguments>pop PLACE</arguments>
<package>lisp</package>
<description>
リストの先頭要素を取り除きます。取り除いた要素を返します。

  PLACE : setfに適用できるものでなければなりません。

使用例：
  (setq x '(a (b c d) e f))     =&gt; (a (b c d) e f)
  (pop (cdr (second x)))        =&gt; c
  x                             =&gt; (a (b d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleはなさそう。
</description>
<section>リスト</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>popup-list</title>
<type>Function</type>
<arguments>popup-list LIST CALLBACK &amp;optional POINT</arguments>
<package>editor</package>
<description>
ポップアップリストを表示します。選択された項目を引数にコールバッ
ク関数が呼び出されます。

使用例：
  (defun func ()
    (popup-list
       '("123" "abc" "xyz")
       #'(lambda (x) (msgbox "\"~A\" selected" x))))
  =&gt; func
</description>
<seealso>dabbrev-popup</seealso>
<seealso>popup-string</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>popup-string</title>
<type>Function</type>
<arguments>popup-string STRING POINT &amp;optional TIMEOUT</arguments>
<package>editor</package>
<description>
文字列をポップアップさせます。ツールチップのポップみたいな表示です。

  STRING  : ポップアップさせる文字列を指定します。
  POINT   : 文字列を表示する位置をポイントで指定します。
  TIMEOUT : 表示を止めるまでの秒数を指定します。
</description>
<seealso>popup-list</seealso>
<seealso>continue-popup</seealso>
<seealso>track-popup-menu</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pos-not-visible-in-window-p</title>
<type>Function</type>
<arguments>pos-not-visible-in-window-p POINT &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたポイントPOINTがウィンドウの表示範囲内にないかを返します。

  t     表示範囲内にない。
  nil   表示範囲内にある。
</description>
<seealso>pos-visible-in-window-p</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pos-visible-in-window-p</title>
<type>Function</type>
<arguments>pos-visible-in-window-p POINT &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ポイントがウィンドウの表示範囲内にあるかを返します。

  t     表示範囲内にある。
  nil   表示範囲内にない。
</description>
<seealso>pos-not-visible-in-window-p</seealso>
<link></link>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>position-if-not</title>
<type>Function</type>
<arguments>position-if-not PREDICATE SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものがあればそのインデックスを返します。
なければnilを返します。
</description>
<seealso>position</seealso>
<seealso>position-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>position-if</title>
<type>Function</type>
<arguments>position-if PREDICATE SEQUENCE &amp;key :from-end :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものがあればそのインデックスを返します。
なければnilを返します。
</description>
<seealso>position</seealso>
<seealso>position-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>position</title>
<type>Function</type>
<arguments>position ITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :key</arguments>
<package>lisp</package>
<description>
SEQUENCE の中で ITEM との :test を満たすものがあればそのインデックスを返します。
なければ nil を返します。

使用例：
  ;;; リストの中から'aのインデックスを調べる
  (position 'a '(e c a b))
  =&gt; 2
</description>
<seealso>position-if</seealso>
<seealso>position-if-not</seealso>
<seealso>find</seealso>
<seealso>member</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>post-buffer-modified-hook-enabled-p</title>
<type>Function</type>
<arguments>post-buffer-modified-hook-enabled-p &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファでpost-buffer-modified-hookが有効かを判定します。
[xyzzy:06354]を参照
xyzzy 0.2.1.186〜 
</description>
<seealso>enable-post-buffer-modified-hook</seealso>
<seealso>post-buffer-modified-hook</seealso>
<link></link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>post-buffer-modified-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファが修正されたときに実行されます。

設定された関数は以下の5引数で呼び出されます。
  BUFFER    : 修正されたバッファ
  OPERATION : 修正された操作の種類
               :insert  文字の挿入
               :delete  文字の削除
               :modify  修正(downcase-wordなど)
  FROM      : 開始位置のポイント
  TO        : 終了位置のポイント
              OPERATIONが:deleteの場合はFROMとTOは同じ値になります。
  UNDO-P    : 修正された状況
               undo     undo
               redo     redo
               nil      その他

注意：
  enable-post-buffer-modified-hookでフックを有効にしないと実行されません。
  対話的でなくても実行されます。
  同じバッファに修正を行うとread-only-bufferエラーになります。
  なんらかのエラーが発生するとフックが無効になります。
  ウィンドウ・バッファを削除したり、
  戻るときにウィンドウ・バッファが切り替わってたりすると、
  きっと良くないことが起こるので、あまり無茶なことはしない方が無難です。

使用例：
  (enable-post-buffer-modified-hook t)
  (defun buffer-modified-hook (buffer operation from to undo-p)
    (message "ope:~A  undo:~A from:~d to:~d" operation undo-p from to))
  (add-hook 'post-buffer-modified-hook 'buffer-modified-hook)
</description>
<seealso>enable-post-buffer-modified-hook</seealso>
<seealso>post-buffer-modified-hook-enabled-p</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>pre-selection-p</title>
<type>Function</type>
<arguments>pre-selection-p</arguments>
<package>editor</package>
<description>
セレクションが存在すれば t しなければ nil を返します。
</description>
<seealso>selection-point</seealso>
<seealso>selection-mark</seealso>
<seealso>get-selection-type</seealso>
<seealso>start-selection</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>preceding-char</title>
<type>Function</type>
<arguments>preceding-char</arguments>
<package>editor</package>
<description>
カーソルの前の文字を返します。
バッファの先頭にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; カーソルの直前が#\LFDか？つまりカーソルは行頭にあるか？
  (char= (preceding-char) #\LFD)
  =&gt; t
</description>
<seealso>following-char</seealso>
<seealso>char-before</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>previous-buffer</title>
<type>Function</type>
<arguments>previous-buffer</arguments>
<package>editor</package>
<description>
一つ前のバッファに切替えます。next-bufferの反対です。[S-Home]
</description>
<seealso>next-buffer</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>previous-line</title>
<type>Function</type>
<arguments>previous-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行前に移動します。
移動の前後で goal-column を保存します。
(previous-line n) と (next-line (- n)) は同じです。

使用例:
  (previous-line)
</description>
<seealso>forward-line</seealso>
<seealso>next-line</seealso>
<seealso>previous-virtual-line</seealso>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>previous-page</title>
<type>Function</type>
<arguments>previous-page</arguments>
<package>editor</package>
<description>
1ページ分画面を上スクロールします。[ESC v], [PageUp], [C-z]
*page-scroll-half-window* が non nil なら半画面ずつスクロールします。
</description>
<seealso>next-page</seealso>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>previous-virtual-line</title>
<type>Function</type>
<arguments>previous-virtual-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行前の表示行に移動します。 [C-p], [Up]
  t    先頭行以外の場合
  nil  先頭行の場合
</description>
<seealso>previous-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>prin1</title>
<type>Function</type>
<arguments>prin1 OBJECT &amp;optional STREAM</arguments>
<package>lisp</package>
<description>
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。princでの出力とよく似て
いますが、エスケープ文字を出力することや文字列が引用符で囲まれる点が異な
ります。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") =&gt; abc  (prin1 "abc") =&gt; "abc"
  (princ #\a)   =&gt; a    (prin1 #\a)   =&gt; #\a
</description>
<seealso>princ</seealso>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>princ</title>
<type>Function</type>
<arguments>princ OBJECT &amp;optional STREAM</arguments>
<package>lisp</package>
<description>
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。prin1での出力とよく似て
いますが、エスケープ文字を出力しないことや文字列が引用符で囲まれない点が
異なります。
※CLtL2(Common Lisp the Language, 2nd edition)によると人間に読み易いよう
  に意図しているそうです。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") =&gt; abc  (prin1 "abc") =&gt; "abc"
  (princ #\a)   =&gt; a    (prin1 #\a)   =&gt; #\a
</description>
<seealso>prin1</seealso>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>print-buffer</title>
<type>Function</type>
<arguments>print-buffer &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファを印刷します。
</description>
<seealso>print-dialog</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>print-dialog</title>
<type>Function</type>
<arguments>print-dialog &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
指定されたバッファBUFFERの印刷用のダイアログを表示します。
</description>
<seealso>print-buffer</seealso>
<link></link>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-buffer</title>
<type>Function</type>
<arguments>process-buffer PROCESS</arguments>
<package>editor</package>
<description>
プロセスが結び付けられているバッファを返します。
</description>
<seealso>buffer-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-eol-code</title>
<type>Function</type>
<arguments>process-eol-code PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された改行コードを返します。
</description>
<seealso>set-process-eol-code</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-exit-code</title>
<type>Function</type>
<arguments>process-exit-code PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスPROCESSの終了コードを取得します。
</description>
<seealso>signal-process</seealso>
<seealso>process-status</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-filter</title>
<type>Function</type>
<arguments>process-filter PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定されたFILTER用の関数を返します。
</description>
<seealso>set-process-filter</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-incode</title>
<type>Function</type>
<arguments>process-incode PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された入力用の文字エンコーディングを指定します。
</description>
<seealso>set-process-incode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-outcode</title>
<type>Function</type>
<arguments>process-outcode PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された出力用の文字エンコーディングを指定します。
</description>
<seealso>set-process-outcode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-send-string</title>
<type>Function</type>
<arguments>process-send-string PROCESS STRING</arguments>
<package>editor</package>
<description>
プロセスに文字列を送ります。

  PROCESS : 文字列を送りつけるプロセスを指定します。 
  STRING  : 送りつける文字列を指定します。

使用例：
  ;;; sort.exeを起動して、"abc" "aab" "aac"を送りつける。
  (setq proc (make-process "sort"))
  =&gt; #&lt;process 135271372&gt;
  (process-send-string proc "abc\n") =&gt; t
  (process-send-string proc "aab\n") =&gt; t
  (process-send-string proc "aac\n") =&gt; t
  (process-send-string proc "^Z")    =&gt; t
  aab
  aac
  abc
</description>
<seealso>make-process</seealso>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-sentinel</title>
<type>Function</type>
<arguments>process-sentinel PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定されたSENTINEL用の関数を返します。
</description>
<seealso>set-process-sentinel</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-status</title>
<type>Function</type>
<arguments>process-status PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスの状態を返します。

  :run  動作中
  :exit 停止
</description>
<seealso>kill-process</seealso>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>processp</title>
<type>Function</type>
<arguments>processp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがプロセスかを返します。

  t     OBJECTはプロセス
  nil   OBJECTはプロセスではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>prog1</title>
<type>Macro</type>
<arguments>prog1 FIRST &amp;body BODY</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最初のフォームの結果を返します。

使用例：
  (prog1 (print "The first form")
         (print "The second form")
         (print "The third form"))
  -&gt; "The first form"
  -&gt; "The second form"
  -&gt; "The third form"
  =&gt; "The first form"
</description>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>progn</title>
<type>Special Form</type>
<arguments>progn {FORM}*</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最後のフォームの結果を返します。

使用例：
  (progn (print "The first form")
         (print "The second form")
         (print "The third form"))
  -&gt; "The first form"
  -&gt; "The second form"
  -&gt; "The third form"
  =&gt; "The third form"
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>provide</title>
<type>Function</type>
<arguments>provide MODULE-NAME</arguments>
<package>lisp</package>
<description>
ある機能を持ったモジュールがロードされた事を示すためにファイルの先頭に書
いておく「おまじない」です。ここに書いたモジュール名が変数*modules*に登
録されます。

requireがモジュールのロードをする際にこの変数がチェックされてロード済だ
ったらもうロードしません。汎用的なモジュールを書く場合には使うようにしま
しょう。

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  ;;; lispmode.lより
  (provide "lispmode")
</description>
<seealso>require</seealso>
<seealso>*modules*</seealso>
<section>評価</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>psetq</title>
<type>Macro</type>
<arguments>psetq {VAR FORM}*</arguments>
<package>lisp</package>
<description>
変数に値を設定します。

  (psetq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。 

setqと似ていますがsetqが頭から順に変数に値を設定していくのに対し、psetq
は値を全て評価した上で設定します。

使用例：
  ; psetq の場合
  (let ((from 1)
        (to 100))
    (psetq from to to from)
    (values from to))
  =&gt;100
  =&gt;1

  ; setq の場合
  (let ((from 1)
        (to 100))
    (setq from to to from)
    (values from to))
  =&gt;100
  =&gt;100
</description>
<seealso>setq</seealso>
<seealso>psetf</seealso>
<link></link>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>push</title>
<type>Macro</type>
<arguments>push ITEM PLACE</arguments>
<package>lisp</package>
<description>
リストの先頭に要素を追加します。

  ITEM  : リストに追加する要素です。
  PLACE : pushする場所はsetfに適用できるものでなければなりません。

使用例：
  ;;; リストの途中にpushしてみる。
  (setq x '(a (b c d) e f))     =&gt; (a (b c d) e f)
  (push 99 (cdr (second x)))    =&gt; (99 c d)
  x                             =&gt; (a (b 99 c d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。
</description>
<seealso>pushnew</seealso>
<section>リスト</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>pushnew</title>
<type>Macro</type>
<arguments>pushnew ITEM PLACE &amp;KEY :test :test-not :key</arguments>
<package>lisp</package>
<description>
push とほぼ同じですが、リストの最上位に現れている要素でなければリストの
先頭に追加されます。追加するかどうかは、 :test もしくは :test-not で指定
される比較テストを使ってリストの全要素についてチェックして決められます。

  ITEM      : 登録する内容です。
  PLACE     : 登録する場所です。
  :test     : 比較関数です。標準では#'eql？
  :test-not : 比較関数です。
  :key      : キー判定用の関数です。標準では#'identity？

使用例：
  (setq *a* nil)                ;; この時 *a* の値は nil
  (pushnew 'a *a*)  =&gt; (a)      ;; この時 *a* の値は (a)
  (pushnew 'b *a*)  =&gt; (b a)    ;; この時 *a* の値は (b a)
  (pushnew 'a *a*)  =&gt; (b a)    ;; この時 *a* の値は (b a)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。
</description>
<seealso>push</seealso>
<seealso>adjoin</seealso>
<section>リスト</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>quietly-read-abbrev-file</title>
<type>Function</type>
<arguments>quietly-read-abbrev-file &amp;optional FILE</arguments>
<package>editor</package>
<description>
Q.現在、モードを切り替えて且つ abbrev を有効にするには、
  ┌───────────────────────────────┐
  │M-x: sql-mode,                                                │
  │M-x: abbrev-mode                                              │
  │M-x: read-abbrev-file,                                        │
  │Read-abbrev-file: C:/xyzzy/.abbrev_defs                       │
  └───────────────────────────────┘
  のように４段階踏まなくてはなりません。最初の M-x: sql-mode の時か、
  ファンクションキーに割り当てて一度に行う方法はないもんでしょうか？

A.[xyzzy:02017]赤塚慶さん
  .xyzzy に
  ┌───────────────────────────────┐
  │; 起動時に abbrev file を読み込む                             │
  │(quietly-read-abbrev-file)                                    │
  └───────────────────────────────┘
  とかいておくと、  .abbrev_defs を呼んでくれます。

  [xyzzy:02020]亀井哲弥さん
  これに加えて、
  ┌───────────────────────────────┐
  │(add-hook 'ed::*sql-mode-hook* #'(lambda () (abbrev-mode t))) │
  └───────────────────────────────┘
  も書いておけば、M-x sql-mode だけでいけると思います(たぶん)。
</description>
<seealso>abbrev-mode</seealso>
<section>モード</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>quote-region</title>
<type>Function</type>
<arguments>quote-region FROM TO</arguments>
<package>editor</package>
<description>
指定されたリージョンの先頭に引用を表す接頭子を挿入します。
引用を表す接頭子として *quotation-prefix* を挿入します。
</description>
<seealso>*quotation-prefix*</seealso>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>quote-string</title>
<type>Function</type>
<arguments>quote-string STRING TARGET-CHAR QUOTE-CHAR</arguments>
<package>editor</package>
<description>
文字列中の特定文字の前にエスケープ文字をつけます。

  STRING      : 置換する文字列
  TARGET-CHAR : エスケープされる文字
  QUOTE-CHAR  : エスケープ文字

使用例：
  ;;;   スペースの前に'をつけます。
  (quote-string  "a b  c"  #\SPC #\')
  =&gt; "a' b' ' c"
</description>
<seealso>substitute-string</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>quote</title>
<type>Special Form</type>
<arguments>quote OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTを評価せずに返します。
single quoteで代用されます。

使用例：
  ;;; quoteと'を使ってみる。
  (quote x)             =&gt; x
  'x                    =&gt; x
  (eq (quote x) 'x)     =&gt; t
</description>
<seealso>``'(backquote)</seealso>
<seealso>function</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>quoted-printable-decode-region-to-file</title>
<type>Function</type>
<arguments>quoted-printable-decode-region-to-file FILENAME FROM TO</arguments>
<package>editor</package>
<description>
リージョンをQuoted-Printableデコードしてファイルに保存します。
</description>
<seealso>si:quoted-printable-decode</seealso>
<seealso>quoted-printable-decode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>quoted-printable-decode-region</title>
<type>Function</type>
<arguments>quoted-printable-decode-region FROM TO</arguments>
<package>editor</package>
<description>
リージョンをQuoted-Printableデコードします。
</description>
<seealso>si:quoted-printable-decode</seealso>
<seealso>quoted-printable-decode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>random</title>
<type>Function</type>
<arguments>random NUMBER &amp;optional STATE</arguments>
<description>
0以上NUMBER未満の乱数を返します。

  STATE: 乱数の状態変数です。破壊的に処理されます。
</description>
<seealso>*random-state*</seealso>
<seealso>make-random-state</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc-if-not</title>
<type>Function</type>
<arguments>rassoc-if-not PREDICATE A-LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で cdr 部が PREDICATE を満たさない最初のペアを返します。

使用例：
  (rassoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (a . b)
</description>
<seealso>rassoc</seealso>
<seealso>rassoc-if</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc-if</title>
<type>Function</type>
<arguments>rassoc-if PREDICATE A-LIST &amp;key :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で cdr 部が PREDICATE を満たす最初のペアを返します。

使用例：
  (rassoc-if #'numberp '((a . b) (1 . c) (2 . 4)))
  =&gt; (2 . 4)
</description>
<seealso>rassoc</seealso>
<seealso>rassoc-if-not</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc</title>
<type>Function</type>
<arguments>rassoc ITEM A-LIST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
連想リスト A-LIST の中で cdr 部が ITEM との :test を満たす最初のペアを返します。

使用例：
  (rassoc 'a '((a . b) (b . c) (c . a) (z . a)))
  =&gt; (c . a)
</description>
<seealso>rassoc-if</seealso>
<seealso>rassoc-if-not</seealso>
<seealso>assoc</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rationalp</title>
<type>Function</type>
<arguments>rationalp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがratioかintegerならt、それ以外ならnilを返します。

  (rationalp x) == (typep x 'rational)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>re-search-backward</title>
<type>Function</type>
<arguments>re-search-backward REGEXP &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
正規表現による後方検索をします。[ESC C-s]

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>re-search-forward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>re-search-forward</title>
<type>Function</type>
<arguments>re-search-forward REGEXP &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
正規表現による前方検索をします。[ESC s]

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>re-search-backward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>read-char-no-hang</title>
<type>Function</type>
<arguments>read-char-no-hang &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE</arguments>
<package>lisp</package>
<description>
read-char と同じです。ただし、入力がなければ待たずに nil を返します。
</description>
<seealso>read-char</seealso>
<seealso>listen</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-char</title>
<type>Function</type>
<arguments>read-char &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
指定された入力ストリームから一文字読み込んで、文字を返します。

  INPUT-STREAM : 入力ストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でread-charしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）

使用例：
  (read-char *keyboard*) &lt;-- "a"を入力
  =&gt; #\a

補足：
  蛇足ですが、EOFはEnd Of Fileの略です。ファイルやストリームをすっかり読
  み終わってしまった状態を指します。
</description>
<seealso>read-char-no-hang</seealso>
<seealso>write-char</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-directory-name</title>
<type>Function</type>
<arguments>read-directory-name PROMPT &amp;key :default :title :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがディレクトリ名を入力するのを
待ちます。入力中は TAB キーでディレクトリ名を補完できます。 "~" はユーザ
ーのホームディレクトリに、 ".." は親ディレクトリに変換されます。ユーザー
の入力したディレクトリ名を返します。
(interactive "D") に相当します。

  PROMPT     : プロンプト
  :default   : 初期表示するディレクトリ名
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (read-directory-name "directory: ")
  =&gt; "C:/applications/xyzzy/etc"
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-file-name</title>
<type>Function</type>
<arguments>read-file-name PROMPT &amp;key :default :title :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがファイル名を入力するのを待ち
ます。入力中は TAB キーでファイル名を補完できます。 "~" はユーザーのホー
ムディレクトリに、 ".." は親ディレクトリに変換されます。ユーザーの入力し
たファイル名を返します。
(interactive "F") に相当します。

  PROMPT     : プロンプト
  :default   : 初期表示するファイル名
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variable プロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからファイル名を読み取る。
  (read-file-name "filename: ")
  =&gt; "C:/applications/xyzzy/xyzzy.exe"
</description>
<seealso>read-exist-file-name</seealso>
<seealso>read-file-name-list</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-from-string</title>
<type>Function</type>
<arguments>read-from-string STRING &amp;optional EOF-ERROR-P EOF-VALUE &amp;key :start :end :preserve-whitespace</arguments>
<package>lisp</package>
<description>
文字列を読み、多値で2つの値を返します。1つ目の戻り値は Lisp Reader が読
み込んだオブジェクトそのもの、2つ目の戻り値は文字列中において読まなかっ
た最初の文字の位置です。文字列を最後まで読んだ場合、2つ目の戻り値はその
文字列の長さと等しくなります。

  STRING               : 読む対象である文字列
  EOF-ERROR-P          : EOFの状態でread-from-stringしたときにどうするか？
                non-nil    エラーとします。(デフォルト)
                nil        エラーとせず、nilを返します。
  EOF-VALUE            : EOFの状態でread-from-stringしたときにnilの代わ
                         りに返す文字を指定します。
  :start               : 読み始める位置(デフォルトは0)
  :end                 : 読み終わる位置(デフォルトは文字列の長さ)
  :preserve-whitespace : (詳細不明)<!-- ホワイトスペースを保持するかどうか？ -->
                non-nil    <!-- 保持する -->
                nil        <!-- 保持しない(デフォルト) -->
</description>
<seealso>parse-integer</seealso>
<link></link>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>read-integer</title>
<type>Function</type>
<arguments>read-integer PROMPT</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが整数を入力するを待ちます。
ユーザーの入力した整数を返します。
(interactive "n") に相当します。

  PROMPT     : プロンプト

使用例：
  ;;; ミニバッファから数値を読み取る。
  (read-integer "num: ")
  =&gt; 123
</description>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-line</title>
<type>Function</type>
<arguments>read-line &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
指定された入力ストリームから一行読み込んで文字列として返します。

  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : nil 以外の場合、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値

二つ目の戻り値として、改行文字を読み込んだ場合は nil を、に達した場合
は t を返します。

RECURSIVE-P は、与えることはできますが使用されません。
</description>
<seealso></seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-registry</title>
<type>Function</type>
<arguments>read-registry SECTION KEY &amp;optional ROOT</arguments>
<package>editor</package>
<description>
レジストリから読み込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  ROOT    : ルートキーを指定します。
     nil             HKEY_CURRENT_USER\Software\Free Software\Xyzzy
     :current-user   HKEY_CURRENT_USER
     :classes-root   HKEY_CLASSES_ROOT
     :local-machine  HKEY_LOCAL_MACHINE
     :users          HKEY_USERS

使用例：
  ;;; HKEY_CURRENT_USER/software/Microsoft/devstudio/5.0/Recent File List/project1 の値を読む
  (read-registry "software\\Microsoft\\devstudio\\5.0\\Recent File List" "project1"  :current-user)
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-sexp</title>
<type>Function</type>
<arguments>read-sexp PROMPT</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがS式を入力するのを待ちます。
ユーザーの入力したS式と文字数を多値で返します。
(interactive "x") に相当します。

  PROMPT     : プロンプト

使用例：
  ;;; ミニバッファからS式を入力する。
  (read-sexp "sexp: ")
  =&gt; (+ 3 3)
  =&gt; 7
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-string</title>
<type>Function</type>
<arguments>read-string PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが文字列を入力するのを待ちます。
ユーザーの入力した文字列を返します。
(interactive "s") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例：
  ;;; ミニバッファからURLを入力する。
  (read-string "URL: ")
  =&gt; "http://www.yahoo.co.jp"
</description>
<seealso>completing-read</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read</title>
<type>Function</type>
<arguments>read &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
INPUT-STREAM から Lisp のオブジェクトを読み込んで返します。

  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でreadしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>realp</title>
<type>Function</type>
<arguments>realp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が real number なら t 、それ以外なら nil を返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>realpart</title>
<type>Function</type>
<arguments>realpart NUMBER</arguments>
<package>lisp</package>
<description>
複素数の実数部を取得します。

使用例：
  (setq a (complex 1 3))
  =&gt;#C(1 3)

  (realpart a)
  =&gt;1
</description>
<seealso>imagpart</seealso>
<seealso>complex</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>recenter</title>
<type>Function</type>
<arguments>recenter &amp;optional ARG</arguments>
<package>editor</package>
<description>
バッファをスクロールして画面上の表示位置を調整します。[C-l]
引数を指定しなければ現在行が画面の中央に位置します。
(recenter 0) で現在行がウインドウの一番上に来ます。

  ARG : 調整後のカーソル位置
   nil          画面中央の行に移動。
   数字の場合   正の数なら、ウィンドウの上からの行数。
                負の数なら、ウィンドウの下からの行数。

戻り値
  カーソルが移動した時はt
            移動しなかった時はnil
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>redo</title>
<type>Function</type>
<arguments>redo</arguments>
<package>editor</package>
<description>
元に戻した処理を再度実行します。[C-_],[S-End],[F12]

buffer-can-redo-p が t の時のみ実行可能です。
</description>
<seealso>undo</seealso>
<seealso>buffer-can-redo-p</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>reduce</title>
<type>Function</type>
<arguments>reduce FUNCTION SEQUENCE &amp;key :from-end :start :end :initial-value</arguments>
<package>lisp</package>
<description>
2項演算子であるFUNCTIONで、SEQUENCEに対して畳み込みを行います。
  
  FUNCTION  : 2項演算子。
  :from-end : nil なら先頭から、non-nil なら最後の要素から畳み込みを行います。
  :start    : 畳み込みを行う SEQUENCE の開始インデックスです。デフォルトは 0 です。 
              :from-end が non-nil なら終了インデックスになります。
  :END      : 畳み込みを行う SEQUENCE の終了インデックスです。デフォルトは nil です。
              :from-end が non-nil なら開始インデックスになります。
  :INITIAL-VALUE : non-nil ならばこの値を初期値として使用します。

 (reduce #'- '(1 2 3)) = (- (- 1 2) 3)
 (reduce #'- '(1 2 3) :initial-value 10) = (- (- (- 10 1) 2) 3)
 (reduce #'- '(1 2 3) :from-end t :initial-value 10) = (- 1 (- 2 (- 3 10)))
</description>
<seealso></seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>refresh-screen</title>
<type>Function</type>
<arguments>refresh-screen &amp;optional F</arguments>
<package>editor</package>
<description>
画面をリフレッシュします。
キー入力の方が画面の再描画よりも優先されます。従って、外部プロセスから非
同期に入力される文字列をバッファに出力したり、処理の途中でダイアログを表
示すると、画面が追いついていない場合があります。そのような場合に実行します。
</description>
<seealso>do-events</seealso>
<seealso>sit-for</seealso>
<seealso>sleep-for</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>refresh-tool-bars</title>
<type>Function</type>
<arguments>refresh-tool-bars</arguments>
<package>editor</package>
<description>
ツールバーをリフレッシュします。
lisp/optprop.lの中から共通設定の変更内容を、ツールバーに反映するために用
いられています。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>regexp-keyword-list</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
正規表現を用いたキーワードの色分け機能です。キーワード長は256文
字程度らしいです。

使用例：
  (defvar *c-number-formats*
    (compile-regexp-keyword-list
     '(("\\(^\\|\\_S\\)\\(?:[0-9]+\\.[0-9]*\\|\\.[0-9]+\\)\\(?:e[-+]?[0-9]+\\)?[fl]?\\($\\|\\_S\\)"
        t (:keyword 0 :bold) nil -1 -2)
       ("\\_&lt;[0-9]+e[-+]?[0-9]+[fl]?\\_&gt;" t 1)
       ("\\_&lt;\\([1-9][0-9]*\\|0[0-7]*\\|0x[0-9a-f]+\\)\\(u?l\\|l?u\\|u?i64\\)?\\_&gt;"
        t (:color 1 2 :underline)))))
  (make-local-variable 'regexp-keyword-list)
  (setq regexp-keyword-list *c-number-formats*)

形式：
  (compile-regexp-keyword-list
   '((regexp1 case-fold color [ context [ begin [ end ] ] ] )
     (regexp2 case-fold color [ context [ begin [ end ] ] ] )
     ...
     (regexpN case-fold color [ context [ begin [ end ] ] ] )))

パラメタ：
  regexp  
      正規表現
  case-fold
      non-nil  正規表現のマッチングで大文字小文字を区別しない
      nil      正規表現のマッチングで大文字小文字を区別する
  color
      下の何れかの形式で指定します。
      keyword-color
          0-2       キーワードの1-3の色
          3-5       キーワードの1-3の色でそのキーワードだけ反転 
          6-8       キーワードの1-3の色でその行の端から端まで反転
          9         単なるbold 
          10-18     0-8と同じ色でbold
          :string   文字列の色 
          :comment  コメントの色 
          :tag      タグの色 
      (:keyword keyword-color [attributes])
          keyword-color
              keyword-colorの値
          attributes
              :bold        ボールド 
              :underline   アンダーライン 
              :strike-out  取り消し線 
              :line        一行まるごと 
      (:color foreground [background [attributes]]) 
          foreground
              0-15  前景色
          background 
              0     指定しない
              1-15  背景色
  context
      キーワードが有効な文脈を指定します。下のシンボルもしくは
      シンボルのリストを指定します。指定しない場合には、nilが指
      定されたものとして動作します。
      :string   文字列内部で有効
      :tag      タグの内部で有効
      :comment  コメントの内部で有効
      nil       上記以外で有効
      t         全ての文脈で有効
  begin
      マッチしたテキストの色を付ける部分の開始位置を指定します。
      0-9ならば(match-beginning begin)の位置からです。-1--9なら
      ば(match-end (- begin))の位置からです。指定しないかnilの場合に
      は(match-beginning 0)の位置からです。
  end
      マッチしたテキストの色を付ける部分の終了位置を指定します。
      0-9ならば(match-end end)の位置までです。-1--9ならば
      (match-beginning (- end))の位置までです。指定しないかnilの場合に
      は(match-end 0)の位置までです。
</description>
<seealso>正規表現の表記</seealso>
<link></link>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>regexp-quote</title>
<type>Function</type>
<arguments>regexp-quote REGEXP</arguments>
<package>editor</package>
<description>
REGEXPのメタ文字をエスケープした表現を返します。
例えば、「正規表現のメタ文字を含む文字列」を含む
正規表現で検索したい場合に便利です。
使用例：
  (regexp-quote "a+b*")
  =&gt;"a\\+b\\*"
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>regexpp</title>
<type>Function</type>
<arguments>regexpp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがコンパイル済み正規表現かを返します。

  t     OBJECTはコンパイル済み正規表現
  nil   OBJECTはコンパイル済み正規表現ではない
</description>
<seealso>compile-regexp</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>register-history-variable</title>
<type>Function</type>
<arguments>register-history-variable VAR</arguments>
<package>editor</package>
<description>
すでに定義された変数 VAR をヒストリ変数に登録します。
ファイルに書き込まれるため、変数の内容は readable である必要があります。
readable であるとは、具体的に言うと「文字、文字列、数値、シンボルと
それらのリストで構成されるデータ」のことです。<!-- 抜けがあったらごめんなさい -->

  VAR : ヒストリ変数に登録する変数のシンボル、もしくはそれらのリスト
</description>
<seealso>define-history-variable</seealso>
<seealso>unregister-history-variable</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>rem</title>
<type>Function</type>
<arguments>rem NUMBER DIVISOR</arguments>
<package>lisp</package>
<description>
(truncate NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：  
  (rem 13 4)
  =&gt; 1
  (rem -13 4)
  =&gt; -1
</description>
<seealso>truncate</seealso>
<seealso>mod</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remhash</title>
<type>Function</type>
<arguments>remhash KEY HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの中からキーが一致するものを削除します。

  KEY        : 削除するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

一致するキーが存在すれば削除してtを返します。
なければnilを返します。

使用例：
  (setq hash-table (make-hash-table))
  =&gt; #&lt;hashtable :test eql :size 0/17 9900444&gt;
  (setf (gethash 'a hash-table) 1)
  =&gt; 1
  (remhash 'b hash-table)
  =&gt; nil
  (remhash 'a hash-table)
  =&gt; t
</description>
<seealso>make-hash-table</seealso>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-if-not</title>
<type>Function</type>
<arguments>remove-if-not PREDICATE SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものを削除したシーケンスを返します。
元のSEQUENCEは保存されます。
</description>
<seealso>remove</seealso>
<seealso>remove-if</seealso>
<seealso>delete-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-if</title>
<type>Function</type>
<arguments>remove-if PREDICATE SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCE の中で PREDICATE を満たすものを削除したシーケンスを返します。
引数 SEQUENCE は保存されます。
</description>
<seealso>remove</seealso>
<seealso>remove-if-not</seealso>
<seealso>delete-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-trail-slash</title>
<type>Function</type>
<arguments>remove-trail-slash STRING</arguments>
<package>editor</package>
<description>
STRINGの末尾に"/"があれば削除した文字列を返します。
使用例：
  (remove-trail-slash "ffjfj")
  =&gt;"ffjfj"

  (remove-trail-slash "ffjfj/")
  =&gt;"ffjfj"
</description>
<seealso>append-trail-slash</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove</title>
<type>Function</type>
<arguments>remove ITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCE の中で ITEM と一致するものを削除したシーケンスを返します。
引数 SEQUENCE は保存されます。

  :count    : 削除する文字数を制限します。
  :from-end : :countが指定された場合にのみ意味を持ちます。
         nil    SEQUENCEの先頭から削除します。
         t      SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        =&gt; "abcabcdef"
  (remove #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "abcabcdef"
  (delete #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "acacdef"
</description>
<seealso>delete</seealso>
<seealso>remove-if</seealso>
<seealso>remove-if-not</seealso>
<seealso>remove-duplicates</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remprop</title>
<type>Function</type>
<arguments>remprop SYMBOL INDICATOR</arguments>
<package>lisp</package>
<description>
シンボルのプロパティを削除します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジゲーター

使用例：
  ;;; 関数の説明を削除してみる。
  (defun foo (x) "increment" (1+ x))            =&gt; foo
  (get 'foo 'lisp::function-documentation)      =&gt; "increment"
  (remprop 'foo 'lisp::function-documentation)  =&gt; t
  (get 'foo 'lisp::function-documentation)      =&gt; nil
</description>
<seealso>get</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename-buffer</title>
<type>Function</type>
<arguments>rename-buffer BUFFER-NAME &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
ファイル名は変えずにバッファ名だけを変更します。
</description>
<seealso>rename</seealso>
<seealso>buffer-name</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename-file</title>
<type>Function</type>
<arguments>rename-file FILE NEW-NAME &amp;key :if-exists :if-access-denied</arguments>
<package>lisp</package>
<description>
ファイル名を変更します。
  
  FILE              : 変更前のファイル名を指定します。
  NEW-NAME          : 変更後のファイル名を指定します。
  :if-exists        : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      上書きします。
        :newer          新しければ上書きします。
  :if-access-denied : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的にファイル名の変更を試みます。

変更できたかどうかで戻り値が変わります。

  t   変更に成功
  nil 変更に失敗

使用例：
  (rename-file "C:/xyzzy/test.txt" "C:/xyzzy/test2.txt")
  =&gt; t
</description>
<seealso>rename</seealso>
<seealso>rename-buffer</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename</title>
<type>Function</type>
<arguments>rename FILENAME &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
バッファに関連づけられたファイル名を変更します。バッファ名も同時に変更されます。
変更に成功したらnil以外の値を、失敗したらnilを返します。[C-x C-n]

使用例：
  ;;; カレントバッファのファイル名が"c:/foo.baz"に変更されます。
  ;;; 同時に、バッファ名も"foo.baz"になります。
  (rename "c:/foo.baz")
</description>
<seealso>rename-buffer</seealso>
<seealso>set-buffer-file-name</seealso>
<seealso>rename-file</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>repeat-backward-search</title>
<type>Function</type>
<arguments>repeat-backward-search</arguments>
<package>editor</package>
<description>
前回検索した文字列を再度後方検索します。[S-F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。
</description>
<seealso>repeat-forward-search</seealso>
<seealso>search-forward-again</seealso>
<seealso>re-search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>repeat-forward-search</title>
<type>Function</type>
<arguments>repeat-forward-search</arguments>
<package>editor</package>
<description>
前回検索した文字列を再度前方検索します。[F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。
</description>
<seealso>repeat-backward-search</seealso>
<seealso>search-forward-again</seealso>
<seealso>re-search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>replace-buffer</title>
<type>Function</type>
<arguments>replace-buffer PATTERN REPLACEMENT &amp;key :case-fold :tail :regexp :left-bound :right-bound :once :literal :last-match</arguments>
<package>editor</package>
<description>
バッファ中の文字列を検索して置換します。replace-stringもperform-replace
もこれを使って実装されています。

使用例：
 ;;;  英字と漢字の間に空白を１つあける
 (replace-buffer "\\([A-Za-z0-9_]\\) *\\([\X8200-\X9fff\Xe000-\Xfcff]\\)"
    "\\1 \\2" :regexp t)
</description>
<seealso>replace-string</seealso>
<seealso>perform-replace</seealso>
<seealso>substitute-string</seealso>
<seealso>gresreg</seealso>
<seealso>正規表現の表記</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>replace-match</title>
<type>Function</type>
<arguments>replace-match STRING &amp;key :literal</arguments>
<package>editor</package>
<description>
直前の検索結果に基づいて、 STRING にあるメタ文字を解釈しつつ文字列を置き換
えます。 :literal が nil 以外の場合は、メタ文字を意識しません。

メタ文字：
   \0, \&amp;    一致した文字列全体
   \1 〜 \9  正規表現検索での\(\)に対応する文字列

使用例：
  ;;; &lt;!--文字列--&gt;を[文字列]に置き換える場合
  (when (scan-buffer "&lt;!--\\(.+\\)--&gt;" :regexp t)
    (replace-match "[\\1]"))
  =&gt; t
</description>
<seealso>replace-buffer</seealso>
<seealso>match-data</seealso>
<seealso>store-match-data</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>replace-string</title>
<type>Function</type>
<arguments>replace-string PATTERN REPLACEMENT &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
バッファを検索して文字列で置換します。perform-replaceを使って実装されて
います。 [M-r]

  PATTERN     : 置換前文字列です。
  REPLACEMENT : 置換後文字列です。
  NOERROR     : 文字列が見つからないときにエラーを出す？

replace系の関数の系譜：
  replace-string         ：interactiveな関数として宣言されている。
    └perform-replace    ：普通はこれで十分の筈
        └replace-buffer ：いろいろと細かく設定したければこれで行う。

使用例：
  (defun test-proc ()
    (interactive)
    (replace-string "aaa" "xxx"))   ;; aaaをxxxに置換
</description>
<seealso>query-replace</seealso>
<seealso>replace-buffer</seealso>
<seealso>substitute-string</seealso>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>replace</title>
<type>Function</type>
<arguments>replace SEQUENCE1 SEQUENCE2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
SEQUENCE1 を SEQUENCE2 で置換します。元の SEQUENCE は置き換えられます。
SEQUENCE1 の :start1-:end1 の位置に、 SEQUENCE2 の :start2-:end2 を挿入
します。

使用例：
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  =&gt; "aaaaaaaa"
  (setq bar (make-sequence 'string 3 :initial-element #\b))
  =&gt; "bbb"
  (replace foo bar)
  =&gt; "bbbaaaaa"
  (replace foo bar :start1 4 :end1 5)
  =&gt; "bbbabaaa"
</description>
<seealso>substitute-string</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>require</title>
<type>Function</type>
<arguments>require MODULE-NAME &amp;optional PATHNAME</arguments>
<package>lisp</package>
<description>
指定したモジュールを読み込みます。既に読込済みであれば何もしません。

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  (require "foreign")
</description>
<seealso>load-library</seealso>
<seealso>provide</seealso>
<seealso>*modules*</seealso>
<seealso>各種ロード関係の関数の違い</seealso>
<section>評価</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>resolve-shortcut</title>
<type>Function</type>
<arguments>resolve-shortcut PATHNAME</arguments>
<package>editor</package>
<description>
ショートカットからファイル名を求めます。

  PATHNAME : ショートカットを指定します。

使用例：
  (resolve-shortcut "d:/winnt/profiles/henmi2/personal/my documentsへのショートカット.lnk")
  =&gt; "G:/My Documents"
</description>
<seealso>create-shortcut</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>return-from</title>
<type>Special Form</type>
<arguments>return-from NAME [RESULT]</arguments>
<package>lisp</package>
<description>
ブロックから脱出します。
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>return</title>
<type>Macro</type>
<arguments>return &amp;optional RESULT</arguments>
<package>lisp</package>
<description>
指定された値でブロックから脱出します。
catchしてくれるブロックがないと例外が発生します。

  (return RESULT) = (return-from nil RESULT)

使用例：
  ;;; ループからの脱出の場合
  (loop (if (yes-or-no-p "quit?") (return 123)))
  =&gt; 123

  ;;; ブロックが無いのでcatchできない場合
  (if (yes-or-no-p "quit?") (return 123))
  =&gt; `return-from'のキャッチャを参照できません: nil
</description>
<seealso>return-from</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>revappend</title>
<type>Function</type>
<arguments>revappend X Y</arguments>
<package>lisp</package>
<description>
X を反転させて Y を結合したリストを返します。
引数 X は保存されます。

  (revappend x y) == (append (reverse x) y)
  
revappendの方が効率が良いようです。
</description>
<seealso>nreconc</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>reverse-region</title>
<type>Function</type>
<arguments>reverse-region FROM TO &amp;optional TEMPORARY</arguments>
<package>editor</package>
<description>
リージョンを反転表示します。
TEMPORARYがnon nilならば、次のキー入力で反転表示が元に戻ります。
</description>
<seealso>clear-reverse-region</seealso>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>reverse</title>
<type>Function</type>
<arguments>reverse SEQUENCE</arguments>
<package>lisp</package>
<description>
SEQUENCE を逆順にした新しいシーケンスを作成して返します。
引数 SEQUENCE は保存されます。
</description>
<seealso>nreverse</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rewind-ime-composition</title>
<type>Function</type>
<arguments>rewind-ime-composition &amp;optional NODELETE POP</arguments>
<package>editor</package>
<description>
直前に IME で変換した文字列を非確定状態に戻します。[C-c C-c]
変換直後でなければ、直前に変換した文字列を非確定状態で挿入します。
</description>
<seealso>ime-push-composition-string</seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>rotatef</title>
<type>Macro</type>
<arguments>rotatef {PLACE}*</arguments>
<package>lisp</package>
<description>
引数として与えられた値の格納場所の内容をローテーションさせます。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └┬┘  └┬┘  └┬┘
      ┌─┘  ┌─┘  ┌─┘
   (*)┘  ┌─┘  ┌─┘  ┌─(*)
          ↓      ↓      ↓
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 1│
        └─┘  └─┘  └─┘
使用例：
  ;;; a b cに数値を入れてrotatefする。
  (setq a 1 b 2 c 3)    =&gt; 3
  (list a b c)          =&gt; (1 2 3)
  (rotatef a b c)       =&gt; 1
  (list a b c)          =&gt; (2 3 1)
</description>
<seealso>setf</seealso>
<seealso>shiftf</seealso>
<section>変数と定数</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>round</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを近い方の整数に丸めます。
ちょうど0.5の場合には偶数方向に丸められます。

使用例： 
  (round 2.5)
  =&gt; 2
  (round 2.6)
  =&gt; 3
  (round 3.5)
  =&gt; 4
  (round -2.5)
  =&gt; -2
  (round -2.6)
  =&gt; -3
  (multiple-value-list (round 2.5))
  =&gt; (2 0.5)
</description>
<seealso>floor</seealso>
<seealso>ceiling</seealso>
<seealso>truncate</seealso>
<seealso>fround</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rplaca</title>
<type>Function</type>
<arguments>rplaca X Y</arguments>
<package>lisp</package>
<description>
リスト X の car を Y に置き換えて、置き換えた X を返します。
(progn (setf (car X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq g '(a b c)) 
  =&gt; (a b c)
  (rplaca (cdr g) 'd)
  =&gt; (d c) 
  g
  =&gt; (a d c)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rplacd</title>
<type>Function</type>
<arguments>rplacd X Y</arguments>
<package>lisp</package>
<description>
リスト X の cdr を Y に置き換えて、置き換えた X を返します。
(progn (setf (cdr X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq x '(a b c)) 
  (rplacd x 'd)
  =&gt; (a . d) 
  x
  =&gt; (a . d)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args-until-success</title>
<type>Function</type>
<arguments>run-hook-with-args-until-success HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
run-hooksと同じように関数を実行します。run-hooksと異なり戻り値
がnon-nilになるまで順番に実行します。
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-while-success</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args-while-success</title>
<type>Function</type>
<arguments>run-hook-with-args-while-success HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
run-hooksと同じように関数を実行します。run-hooksと異なり戻り値
がnon-nilの間だけ順番に実行します。
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args</title>
<type>Function</type>
<arguments>run-hook-with-args HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
run-hooksと同じように関数を実行します。run-hooksと異なり引数を
指定できます。
</description>
<seealso>run-hooks</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hooks</title>
<type>Function</type>
<arguments>run-hooks &amp;rest HOOKLIST</arguments>
<package>editor</package>
<description>
フック変数を順番に実行します。フック変数の詳細はadd-hookを参照して下さい。

  HOOKLIST : フック変数を指定します。複数個並べて書けます。
             並べて書いた順番に実行します。

フック変数の実行には引数をつけることが出来ません。
どうしてもつけたい場合には、run-hook-with-argsを使いましょう。

使用例：
  ;;; c-mode.l
  (run-hooks 'c-mode-hook)
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<seealso>run-hook-with-args-while-success</seealso>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>safe-caaaar</title>
<type>Function</type>
<arguments>safe-caaaar X</arguments>
<package>lisp</package>
<description>
safe-caaaar を返します。

  (safe-caaaar X) = (safe-car (safe-car (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaadr</title>
<type>Function</type>
<arguments>safe-caaadr X</arguments>
<package>lisp</package>
<description>
safe-caaadr を返します。

  (safe-caaadr X) = (safe-car (safe-car (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaar</title>
<type>Function</type>
<arguments>safe-caaar X</arguments>
<package>lisp</package>
<description>
safe-caaar を返します。

  (safe-caaar X) = (safe-car (safe-car (safe-car X)))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caadar</title>
<type>Function</type>
<arguments>safe-caadar X</arguments>
<package>lisp</package>
<description>
safe-caadar を返します。

  (safe-caadar X) = (safe-car (safe-car (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaddr</title>
<type>Function</type>
<arguments>safe-caaddr X</arguments>
<package>lisp</package>
<description>
safe-caaddr を返します。

  (safe-caaddr X) = (safe-car (safe-car (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caadr</title>
<type>Function</type>
<arguments>safe-caadr X</arguments>
<package>lisp</package>
<description>
safe-caadr を返します。

  (safe-caadr X) = (safe-car (safe-car (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caar</title>
<type>Function</type>
<arguments>safe-caar X</arguments>
<package>lisp</package>
<description>
safe-caar を返します。

  (safe-caar X) = (safe-car (safe-car X))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadaar</title>
<type>Function</type>
<arguments>safe-cadaar X</arguments>
<package>lisp</package>
<description>
safe-cadaar を返します。

  (safe-cadaar X) = (safe-car (safe-cdr (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadadr</title>
<type>Function</type>
<arguments>safe-cadadr X</arguments>
<package>lisp</package>
<description>
safe-cadadr を返します。

  (safe-cadadr X) = (safe-car (safe-cdr (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadar</title>
<type>Function</type>
<arguments>safe-cadar X</arguments>
<package>lisp</package>
<description>
safe-cadar を返します。

  (safe-cadar X) = (safe-car (safe-cdr (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caddar</title>
<type>Function</type>
<arguments>safe-caddar X</arguments>
<package>lisp</package>
<description>
safe-caddar を返します。

  (safe-caddar X) = (safe-car (safe-cdr (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadddr</title>
<type>Function</type>
<arguments>safe-cadddr X</arguments>
<package>lisp</package>
<description>
safe-cadddr を返します。

  (safe-cadddr X) = (safe-car (safe-cdr (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caddr</title>
<type>Function</type>
<arguments>safe-caddr X</arguments>
<package>lisp</package>
<description>
safe-caddr を返します。

  (safe-caddr X) = (safe-car (safe-cdr (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadr</title>
<type>Function</type>
<arguments>safe-cadr X</arguments>
<package>lisp</package>
<description>
safe-cadr を返します。

  (safe-cadr X) = (safe-car (safe-cdr X))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-car</title>
<type>Function</type>
<arguments>safe-car X</arguments>
<package>lisp</package>
<description>
(car X) は X が nil か cons でなければエラーになります
しかし safe-car はエラーを発生せずに nil を返します。

使用例：
  ;;; carとsafe-carの違い
  (car "abc")
  =&gt; 不正なデータ型です: "abc": cons
  (safe-car "abc")
  =&gt; nil
</description>
<seealso>car</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaaar</title>
<type>Function</type>
<arguments>safe-cdaaar X</arguments>
<package>lisp</package>
<description>
safe-cdaaar を返します。

  (safe-cdaaar X) = (safe-cdr (safe-car (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaadr</title>
<type>Function</type>
<arguments>safe-cdaadr X</arguments>
<package>lisp</package>
<description>
safe-cdaadr を返します。

  (safe-cdaadr X) = (safe-cdr (safe-car (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaar</title>
<type>Function</type>
<arguments>safe-cdaar X</arguments>
<package>lisp</package>
<description>
safe-cdaar を返します。

  (safe-cdaar X) = (safe-cdr (safe-car (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdadar</title>
<type>Function</type>
<arguments>safe-cdadar X</arguments>
<package>lisp</package>
<description>
safe-cdadar を返します。

  (safe-cdadar X) = (safe-cdr (safe-car (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaddr</title>
<type>Function</type>
<arguments>safe-cdaddr X</arguments>
<package>lisp</package>
<description>
safe-cdaddr を返します。

  (safe-cdaddr X) = (safe-cdr (safe-car (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdadr</title>
<type>Function</type>
<arguments>safe-cdadr X</arguments>
<package>lisp</package>
<description>
safe-cdadr を返します。

  (safe-cdadr X) = (safe-cdr (safe-car (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdar</title>
<type>Function</type>
<arguments>safe-cdar X</arguments>
<package>lisp</package>
<description>
safe-cdar を返します。

  (safe-cdar X) = (safe-cdr (safe-car X))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddaar</title>
<type>Function</type>
<arguments>safe-cddaar X</arguments>
<package>lisp</package>
<description>
safe-cddaar を返します。

  (safe-cddaar X) = (safe-cdr (safe-cdr (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddadr</title>
<type>Function</type>
<arguments>safe-cddadr X</arguments>
<package>lisp</package>
<description>
safe-cddadr を返します。

  (safe-cddadr X) = (safe-cdr (safe-cdr (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddar</title>
<type>Function</type>
<arguments>safe-cddar X</arguments>
<package>lisp</package>
<description>
safe-cddar を返します。

  (safe-cddar X) = (safe-cdr (safe-cdr (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdddar</title>
<type>Function</type>
<arguments>safe-cdddar X</arguments>
<package>lisp</package>
<description>
safe-cdddar を返します。

  (safe-cdddar X) = (safe-cdr (safe-cdr (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddddr</title>
<type>Function</type>
<arguments>safe-cddddr X</arguments>
<package>lisp</package>
<description>
safe-cddddr を返します。

  (safe-cddddr X) = (safe-cdr (safe-cdr (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdddr</title>
<type>Function</type>
<arguments>safe-cdddr X</arguments>
<package>lisp</package>
<description>
safe-cdddr を返します。

  (safe-cdddr X) = (safe-cdr (safe-cdr (safe-cdr X)))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddr</title>
<type>Function</type>
<arguments>safe-cddr X</arguments>
<package>lisp</package>
<description>
safe-cddr を返します。

  (safe-cddr X) = (safe-cdr (safe-cdr X))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdr</title>
<type>Function</type>
<arguments>safe-cdr X</arguments>
<package>lisp</package>
<description>
(cdr X) は X が nil か cons でなければエラーになります
しかし safe-cdr はエラーを発生せずに nil を返します。
</description>
<seealso>cdr</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>save-excursion</title>
<type>Special Form</type>
<arguments>save-excursion {FORM}*</arguments>
<package>editor</package>
<description>
処理の前後でカレントバッファとポイントを保存します。ウィンドウのレイアウ
トは保存しないので注意してください。

ウィンドウのレイアウトも保存したい場合には、save-window-excursionを使います。
</description>
<seealso>save-window-excursion</seealso>
<seealso>save-restriction</seealso>
<seealso>set-goal-column</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>save-restriction</title>
<type>Special Form</type>
<arguments>save-restriction {FORM}*</arguments>
<package>editor</package>
<description>
narrow-to-regionする前の状態を保存します。ポイントやバッファの位置は保存
しません。ポイントやバッファの位置を保存したい場合には、save-excursionを
使用します。

特定の処理の前後でrestrictionの状態とポイントの両方を保存したい場合には、
以下の様にします。

  ;;; うまくいく書き方
  (save-excursion (save-restriction ... )) 

以下の様に書いてしまった場合、処理の中でrestrictionを掛けると内側の
save-excursionでのポイントの復元がうまくいかないことがあります。注意しま
しょう。

  ;;; うまくいかないことがある書き方
  (save-restriction (save-excursion ... ))

使用例：
    ;;; この時点では narrow-to-region してないとする。
    (save-restriction
      (narrow-to-region FROM-1 TO-1)             ; FROM-1からTO-1に制限する
      (save-restriction
        (narrow-to-region FROM-2 TO-2)           ; FROM-2からTO-2に制限する
        (msgbox "~A ~A" (point-min) (point-max))
      )                                          ; FROM-1からTO-1に制限されている
                                                 ; 状態に戻る
      (msgbox "~A ~A" (point-min) (point-max))
    )                                            ; 制限されなくなる
    (msgbox "~A ~A" (point-min) (point-max))
</description>
<seealso>narrow-to-region</seealso>
<seealso>save-excursion</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>save-window-excursion</title>
<type>Special Form</type>
<arguments>save-window-excursion {FORM}*</arguments>
<package>editor</package>
<description>
処理の前後でカレントウィンドウとウィンドウのレイアウトの状態を保存します。
</description>
<seealso>save-excursion</seealso>
<seealso>with-selected-window</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>scan-buffer</title>
<type>Function</type>
<arguments>scan-buffer PATTERN &amp;key :no-dup :case-fold :reverse :tail :regexp :limit :left-bound :right-bound :last-match</arguments>
<package>editor</package>
<description>
バッファを検索します。

  PATTERN      : 検索パターンとして、[文字列]、[正規表現]、[コンパイル済
                 み正規表現]の何れかを指定する。
                 コンパイル済み正規表現の場合は :regexp の値は無視する。
                 また :case-fold 指定も無視され、compile-regexp 時の第2
                 引数の指定が用いられる。

  :no-dup      : 検索方向に対して次のポイントからの検索を指定する。
        nil     - 現在のポイントから検索する。
        non-nil - reverse が nil の場合は、次のポイントから検索する。
                  non-nil の場合は、前のポイントから検索する。

  :case-fold   : ASCII 文字の大文字小文字の区別の方法を指定する。
                 PATTERN が[コンパイル済み正規表現]の場合は、:case-fold
                 指定は意味をもたない。
        nil     - 大文字小文字を区別して検索する。
        :smart  - PATTERN に大文字が含まれていない場合、大文字小文字を区
                  別せずに検索する。
        上記以外- 大文字小文字を区別せずに検索する。

  :reverse     : 検索方向を指定する。
        nil     - バッファの末尾に向かって検索する。
        non-nil - バッファの先頭に向かって検索する。

  :tail        : 検索成功後の移動先ポイントをどこにするかを指定する。
        nil     - 検索成功後、マッチ範囲の先頭((match-beginning 0)のポイ
                  ント)に移動する。
                  bar を検索した場合、:tail が nil なら
                      foo bar baz qux quux ...
                          ^ ポイントはここに移動する。
        non-nil - 検索成功後、マッチ範囲の末尾((match-end 0)のポイント)
                  に移動する。
                  bar を検索した場合、:tail が non-nil なら
                     foo bar baz qux quux ...
                            ^ ポイントはここに移動する。

  :regexp      : PATTERN が [正規表現] であることを指定する。
                 PATTERN が[コンパイル済み正規表現]の場合は、:regexp 指
                 定は意味をもたない。
        nil     - PATTERN を[文字列]とみなす。
        non-nil - PATTERN を[正規表現]とみなす。

  :limit       : 検索範囲をポイント位置で制限する。 
                 文字数制限ではない。
        nil     - 制限なし。
        INTEGER - :reverse が nil の場合は、マッチ末尾文字のポイントが
                  INTEGER 未満となる範囲で検索する。non-nil の場合は、
                  マッチ先頭文字のポイントが INTEGER 以上となる範囲で検
                  索する。
        MARKER  - MARKER に設定されたポイントを上記 INTEGER と見なし検索
                  範囲を制限する。
                  MARKER にポイントが設定されていない((marker-point
                   MARKER) が nil)場合、scan-buffer は nil を返す。
        上記以外- type-error が発生される。

  :left-bound  : [文字列]検索時の左側境界マッチ条件を指定する。
                 正規表現検索の場合は無効。
        nil     - 左側境界に関わらずマッチ成立
        :symbol - マッチ範囲左側境界((match-beginning 0)のポイント)が、
                  以下の何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲左側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word,symbol として登録されていない
                      ((syntax-word-p 文字), (syntax-symbol-p 文字) が
                       nil を返す。)
        上記以外- マッチ範囲左側境界((match-beginning 0)のポイント)が、
                  以下の何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲左側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word として登録されていない
                      ((syntax-word-p 文字)がnilを返す。)

  :right-bound : [文字列]検索時の右側境界マッチ条件を指定する。
                 正規表現検索の場合は無効。
        nil     - 右側境界に関わらずマッチ成立
        :symbol - マッチ範囲右側境界((match-end 0)のポイント)が、以下の
                  何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲右側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word,symbol として登録されていない
                      ((syntax-word-p 文字), (syntax-symbol-p 文字) が
                       nil を返す。)
        上記以外- マッチ範囲右側境界((match-end 0)のポイント)が、以下の
                  何れかの条件を満たせばマッチ成立
                    - バッファの先頭である
                    - バッファの末尾である
                  マッチ範囲右側境界のポイント、もしくは、その前のポイン
                  トの文字が、以下の何れかの条件を満たせばマッチ成立
                    - ASCII 文字でない
                    - syntax-table に word として登録されていない
                      ((syntax-word-p 文字) が nil を返す。)

  :last-match  : 使用効果不明
                 (perform-replace) でのみ用いられている。
                 (&lt;last-match&gt; . &lt;last-match-char&gt;) からなる。
                 &lt;last-match&gt; : 直前のscan-buffer成功時の
                     (match-beginning 0)のポイントを指定
                 &lt;last-match-char&gt;: 直前のscan-buffer成功時の
                     (match-end 0)の前のポイントの文字を指定

戻り値は以下のとおりです。

  t    検索に成功
  nil  検索に失敗

使用例：
  (scan-buffer 検索文字列 :regexp t)
  (scan-buffer 検索文字列 :tail t)
  (scan-buffer 検索文字列 :limit 3000)
  (scan-buffer 検索文字列 :reverse t)
  (scan-buffer 検索文字列 :regexp t :no-dup t)
</description>
<seealso>match-beginning</seealso>
<seealso>match-end</seealso>
<seealso>perform-replace</seealso>
<seealso>make-marker</seealso>
<seealso>skip-chars-forward</seealso>
<seealso>正規表現の表記</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>schar</title>
<type>Function</type>
<arguments>schar SIMPLE-STRING INDEX</arguments>
<package>lisp</package>
<description>
SIMPLE-STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; simpleでないstringでscharを使ってみる。
  (setq foo (make-vector 10 :initial-element #\a :element-type 'character :fill-pointer 3))
                        =&gt; "aaa"
  (schar foo 0)         =&gt; 不正なデータ型です: "aaa": simple-string
  (setq bar "aaa")      =&gt; "aaa"
  (schar bar 0)         =&gt; #\a
</description>
<seealso>char</seealso>
<seealso>simple-string</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>screen-height</title>
<type>Function</type>
<arguments>screen-height</arguments>
<package>editor</package>
<description>
xyzzyのウィンドウ全体の高さが何行になるのかを返します。
</description>
<seealso>screen-width</seealso>
<seealso>window-height</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>scroll-down-both-window</title>
<type>Function</type>
<arguments>scroll-down-both-window</arguments>
<package>editor</package>
<description>
現在のウィンドウと、次のウィンドウを同時に下スクロールします。[S-C-Up]
</description>
<seealso>scroll-up-both-window</seealso>
<seealso>scroll-down-other-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-up-both-window</title>
<type>Function</type>
<arguments>scroll-up-both-window</arguments>
<package>editor</package>
<description>
現在のウィンドウと、次のウィンドウを同時に上スクロールします。[S-C-Down]
</description>
<seealso>scroll-down-both-window</seealso>
<seealso>scroll-up-other-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-window</title>
<type>Function</type>
<arguments>scroll-window ARG</arguments>
<package>editor</package>
<description>
ウィンドウを指定行数分スクロールします。
負の数値を指定すると逆方向にスクロールします。

使用例：
  ;;; 0.3秒おきに1行ずつスクロールさせる。
  (dotimes (i 4) (scroll-window 1) (sit-for .3))
  =&gt; nil
</description>
<seealso>scroll-other-window</seealso>
<seealso>scroll-window-horizontally</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>search-backward</title>
<type>Function</type>
<arguments>search-backward PATTERN &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
後方検索をします。[C-r]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>search-forward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>search-forward</title>
<type>Function</type>
<arguments>search-forward PATTERN &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
前方検索をします。[C-s]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>search-backward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>second</title>
<type>Function</type>
<arguments>second X</arguments>
<package>lisp</package>
<description>
cadrの別名です。
全く同じ動きをします。

使用例：
  ;;; cadrと同じ動きをする。
  (cadr '(1 2 3))
  =&gt; 2
  (second '(1 2 3))
  =&gt; 2
  (symbol-function 'cadr)
  =&gt; #&lt;lexical-closure: cadr&gt;
  (symbol-function 'second)
  =&gt; #&lt;lexical-closure: cadr&gt;
 
参考：
  ;;; list.lの定義
  (si:*fset 'second #'cadr)
</description>
<seealso>first</seealso>
<seealso>cadr</seealso>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>select-buffer</title>
<type>Function</type>
<arguments>select-buffer</arguments>
<package>editor</package>
<description>
バッファを選択するダイアログを表示します。 [F2]
デフォルトではC-p/C-nで上下し、C-mで選択します。
buffer-menuのようなバッファの削除などはできません。
※正確には*std-control-xxx-char*の設定に依ります。
</description>
<seealso>buffer-menu</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>selected-buffer</title>
<type>Function</type>
<arguments>selected-buffer</arguments>
<package>editor</package>
<description>
現在操作中のバッファ（カレントバッファ）を返します。

使用例：
  (selected-buffer)
  =&gt; #&lt;buffer: reference.xml&gt;

互換性：
  この関数はmuleにはありません。
  muleでのcurrent-bufferに相当します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selected-window</title>
<type>Function</type>
<arguments>selected-window</arguments>
<package>editor</package>
<description>
現在アクティブなウィンドウを返します。

使用例：
  ;;; 現在のウィンドウを返してみる。
  (selected-window)
  =&gt; #&lt;window 54137832&gt;
</description>
<seealso>set-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selection-backward-char</title>
<type>Function</type>
<arguments>selection-backward-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
後方の文字までをセレクションにします。[S-Left]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-backward-word</title>
<type>Function</type>
<arguments>selection-backward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
後方の単語までをセレクションにします。[S-C-Left]
</description>
<seealso>selection-forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-forward-char</title>
<type>Function</type>
<arguments>selection-forward-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の文字までをセレクションにします。[S-Right]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-forward-word</title>
<type>Function</type>
<arguments>selection-forward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の単語までをセレクションにします。[S-C-Right]
</description>
<seealso>selection-backward-word</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-mark</title>
<type>Function</type>
<arguments>selection-mark</arguments>
<package>editor</package>
<description>
セレクションの開始のポイントを返します。
</description>
<seealso>selection-point</seealso>
<seealso>region-beginning</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selection-next-page</title>
<type>Function</type>
<arguments>selection-next-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次ページまでをセレクションにします。[S-PageDown]
</description>
<seealso>selection-previous-page</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-next-virtual-line</title>
<type>Function</type>
<arguments>selection-next-virtual-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次の表示行までをセレクションにします。[S-Down]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-paragraph</title>
<type>Function</type>
<arguments>selection-paragraph</arguments>
<package>editor</package>
<description>
段落をセレクションにします。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>selection-point</title>
<type>Function</type>
<arguments>selection-point</arguments>
<package>editor</package>
<description>
セレクションの終端のポイントを返します。
</description>
<seealso>selection-mark</seealso>
<seealso>region-end</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selection-previous-page</title>
<type>Function</type>
<arguments>selection-previous-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前ページまでをセレクションにします。[S-PageUp]
</description>
<seealso>selection-next-page</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-previous-virtual-line</title>
<type>Function</type>
<arguments>selection-previous-virtual-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前の表示行までをセレクションにします。[S-Up]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>self-insert-command</title>
<type>Function</type>
<arguments>self-insert-command &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
最後に入力されたキー *last-command-char* を挿入モードの如何により
insert / overwrite-char します。
括弧が入力された時に強調表示がなされるのもこの中での作用です。
</description>
<seealso>*auto-fill-hook</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>sequencep</title>
<type>Function</type>
<arguments>sequencep OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が sequence なら t 、そうでなければnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-alternate-file-name</title>
<type>Function</type>
<arguments>set-buffer-alternate-file-name NAME &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファBUFFERにファイル名の別名NAMEをつけます。set-buffer-file-nameでは、
ありえないパスを指定するとエラーになります。
set-buffer-alternate-file-nameではどのような文字列でも指定可能です。

使用例：
  ; c:/abc/は存在しないパス
  (set-buffer-file-name "c:/abc/def.txt")
  =&gt; c:/abc/def.txt
     指定されたパスが見つかりません。 

  ; URLでもなんでも任意の文字列を設定可
  (set-buffer-alternate-file-name "http://www.asahi.com")
  =&gt; t

指定した文字列は、バッファのファイル名がnilの場合（つまり、
get-buffer-file-nameの戻り値がnilの場合）に限り、
以下の個所で使用されます

  1)select-bufferで表示されるダイアログのファイル名
  2)mode-line-format/title-bar-formatのファイル名
</description>
<seealso>get-buffer-alternate-file-name</seealso>
<seealso>set-buffer-file-name</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-colors</title>
<type>Function</type>
<arguments>set-buffer-colors COLORS &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの色を設定します。設定した色は現状のバッファにだけ適用されます。

  COLORS : BGRを表す数値をベクタで指定します。
</description>
<seealso>get-buffer-colors</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-colors</title>
<type>Function</type>
<arguments>get-buffer-colors &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの色をBGRを表す数値をベクタで返します。

使用例：
  (ed:get-buffer-colors)
  =&gt; #(0 16777215 12639424 16777215 16750899 16711680 8421376 8388736 32768 128 255 8388736 0 128 0 0 0 15790320)

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<section>バッファ</section>
<seealso>set-buffer-colors</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-eol-code</title>
<type>Function</type>
<arguments>set-buffer-eol-code CODE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの改行コードを設定します。
引数として改行コードの種類を表す定数が用意されています。
昔は、set-buffer-newline-codeという名称でしたが、xyzzy 0.2.0.121 からこ
の名前に変更されました。

  CODE：バッファの改行コードの種類を指定します。
        LFの場合        *eol-lf*        0
        CRLFの場合      *eol-crlf*      1
        CRの場合        *eol-cr*        2

使用例：
  ;;; バッファの改行コードをLFに変更する。
  (set-buffer-eol-code *eol-lf*)
  =&gt; t

参考：
  Changelogのxyzzy 0.2.0.121を参照のこと
</description>
<seealso>*eol-lf*</seealso>
<seealso>*eol-crlf*</seealso>
<seealso>*eol-cr*</seealso>
<seealso>set-buffer-fileio-encoding</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-file-name</title>
<type>Function</type>
<arguments>set-buffer-file-name FILE-NAME &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファと結び付けられているファイルをFILE-NAMEにします。
</description>
<seealso>get-buffer-file-name</seealso>
<seealso>rename</seealso>
<seealso>set-buffer-alternate-file-name</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-fileio-encoding</title>
<type>Function</type>
<arguments>set-buffer-fileio-encoding CODE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの文字エンコーディングをCODEにします。設定した文字エンコーディングは
buffer-fileio-encodingで参照することができます。

  CODE   : 文字エンコーディングを指定します。
  BUFFER : 変更するバッファを指定します。

使用例：
  (set-buffer-fileio-encoding *encoding-sjis*)
  (set-buffer-fileio-encoding *encoding-euc-jp*)
  (set-buffer-fileio-encoding *encoding-jis*)
  (set-buffer-fileio-encoding *encoding-utf8*)

参照：
  kanji.l
</description>
<seealso>buffer-fileio-encoding</seealso>
<seealso>*char-encoding-list*</seealso>
<seealso>set-buffer-eol-code</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-column-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-column-update</arguments>
<package>editor</package>
<description>
カレントバッファが指定位置で折り返しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-column</title>
<type>Function</type>
<arguments>set-buffer-fold-type-column</arguments>
<package>editor</package>
<description>
カレントバッファを指定位置で折り返しします。
</description>
<seealso>set-buffer-fold-type-window</seealso>
<seealso>set-buffer-fold-type-none</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-none-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-none-update</arguments>
<package>editor</package>
<description>
カレントバッファが折り返し無しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-none</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-none</title>
<type>Function</type>
<arguments>set-buffer-fold-type-none</arguments>
<package>editor</package>
<description>
カレントバッファを折り返しなしにします。
</description>
<seealso>set-buffer-fold-type-window</seealso>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-window-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-window-update</arguments>
<package>editor</package>
<description>
カレントバッファがウィンドウ幅で折り返しになっているかどうかを返します。

戻り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-window</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-window</title>
<type>Function</type>
<arguments>set-buffer-fold-type-window</arguments>
<package>editor</package>
<description>
カレントバッファをウィンドウ幅で折り返します。
</description>
<seealso>set-buffer-fold-type-none</seealso>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-width</title>
<type>Function</type>
<arguments>set-buffer-fold-width WIDTH &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
テキストの折り返し方法を制御します。[ツール]-[ローカル設定]-[表示]の"テ
キストの折り返し"と同じで、現在のバッファだけに影響します。

  WIDTH  : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。
  BUFFER : ローカル設定するバッファを指定します。
</description>
<seealso>buffer-fold-width</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-modified-p</title>
<type>Function</type>
<arguments>set-buffer-modified-p FLAG &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが変更されたかどうかのフラグを設定します。

  FLAG   : フラグを指定します。
        t       変更されている状態にします。
        nil     変更が存在しない状態にします。
  BUFFER : 対象のバッファ

使用例： 
  ;;; 変更フラグの設定・クリア
  (set-buffer-modified-p t)
  (set-buffer-modified-p nil)
</description>
<seealso>buffer-modified-p</seealso>
<seealso>not-modified</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer</title>
<type>Function</type>
<arguments>set-buffer BUFFER</arguments>
<package>editor</package>
<description>
バッファを選択します。
</description>
<seealso>switch-to-buffer</seealso>
<seealso>with-set-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default-directory</title>
<type>Function</type>
<arguments>set-default-directory DIRECTORY &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが作業しているディレクトリを変更します。

  DIRECTORY : ディレクトリを指定します。
  BUFFER    : バッファを指定します。
              指定がなければカレントバッファになります。
</description>
<seealso>default-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default-fold-width</title>
<type>Function</type>
<arguments>set-default-fold-width WIDTH</arguments>
<package>editor</package>
<description>
テキストの折り返し方法を制御します。[ツール]-[共通設定]-[表示]の"テキス
トの折り返し"と同じで、全体に影響します。

  WIDTH : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。
</description>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default</title>
<type>Function</type>
<arguments>set-default SYMBOL VALUE</arguments>
<package>lisp</package>
<description>
この関数は、ただ 1つの symbol と 1 つの value のみを許す点と、その両方を
評価する点とを除き setq-default と同じです (setq-default 参照)。

使用例：
  (set-default (car '(a b c)) 23)
  =&gt; 23
</description>
<seealso>setq-default</seealso>
<seealso>set</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-difference</title>
<type>Function</type>
<arguments>set-difference LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
二つのリストの差を返します。
nset-difference と違い引数 LIST1 は保存されます。

使用例：
  (set-difference  '(3 6 9) '(2 4 6 8 10))
  =&gt; (9 3)
</description>
<seealso>nset-difference</seealso>
<seealso>union</seealso>
<seealso>intersection</seealso>
<seealso>set-exclusive-or</seealso>
<seealso>ldiff</seealso>
<seealso>subsetp</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>set-extended-key-translate-table</title>
<type>Function</type>
<arguments>set-extended-key-translate-table KEY C</arguments>
<package>editor</package>
<description>
通常は同時押しができないキーを別のキーに振り向けるテーブルです。

| c-modeでシフトを押しながらTABを押した時に
| インデントしてもらおうと思ったんですが、
| #\TABを#\S-TABにしたらSHIFTは使えませんとのことで。

残念ながらまともな手段では Shift+Tab は使えません。が、まともでない手
段が用意されています。

  (set-extended-key-translate-table exkey-S-tab #\F20)

このようにしておくと、Shift+Tab が押されたときに F20 が押されたふりをするので

  (global-set-key #\F20 'foo)

とすればお望み通り(^^

exkey-... に指定できるのは以下の通り。

  exkey-space
  exkey-S-space
  exkey-C-space
  exkey-S-C-space
  exkey-M-space
  exkey-S-M-space
  exkey-C-M-space
  exkey-S-C-M-space
                   
  exkey-backspace
  exkey-S-backspace
  exkey-C-backspace
  exkey-S-C-backspace
  exkey-M-backspace
  exkey-S-M-backspace
  exkey-C-M-backspace
  exkey-S-C-M-backspace
  
  exkey-tab
  exkey-S-tab
  exkey-C-tab
  exkey-S-C-tab
  
  exkey-return
  exkey-S-return
  exkey-C-return
  exkey-S-C-return
  exkey-M-return
  exkey-S-M-return
  exkey-C-M-return
  exkey-S-C-M-return
  
  exkey-escape
  exkey-S-escape

  exkey-zenkaku
  exkey-S-zenkaku
  exkey-C-zenkaku
  exkey-S-C-zenkaku
  exkey-S-M-zenkaku
</description>
<section>キーマップ</section>
<file>keyboard.l</file>
</chapter>

<chapter>
<title>set-file-write-time</title>
<type>Function</type>
<arguments>set-file-write-time FILENAME UNIVERSAL-TIME</arguments>
<package>lisp</package>
<description>
ファイルの最終更新日を変更します。

  FILENAME       : ファイル名を指定します。フルパスでなければ
                   (default-directory)からの相対パスになります。
  UNIVERSAL-TIME : 最終更新日をユニバーサルタイム形式で指定します。
</description>
<seealso>file-write-time</seealso>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-fill-column</title>
<type>Function</type>
<arguments>set-fill-column &amp;optional (COL (CURRENT-COLUMN))</arguments>
<package>editor</package>
<description>
詰め込み桁数を指定します。[C-x f]
指定された値は、変数 fill-column に代入されます。

  COL : 詰め込み桁数
        引数がない場合は、現在のカーソル位置の桁数を詰め込み桁数に設定し
        ます。
</description>
<seealso>fill-column</seealso>
<link></link>
<section>ポジション</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>set-fill-prefix</title>
<type>Function</type>
<arguments>set-fill-prefix</arguments>
<package>editor</package>
<description>
行頭からポイントまでをfill prefixに設定します。 [C-x .]
行頭で実行された場合には、fill prefixはクリアされます。auto-fill-mode
では、折り返しが行なわれると行頭にfill prefixが挿入されます。
</description>
<seealso>fill-prefix</seealso>
<seealso>auto-fill-mode</seealso>
<link></link>
<section>その他</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>set-function-bar-label</title>
<type>Function</type>
<arguments>set-function-bar-label CHAR LABEL</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルを変更します。

  CHAR  : 各ファンクファンクションバーに対応したキャラクタ
  LABEL : 表示するラベル

使用例
  (global-set-key #\F3 'search-forward-again)
  =&gt; t
  (set-function-bar-label #\F3 "次検索")
  =&gt; t
</description>
<seealso>set-number-of-function-bar-labels</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-goal-column</title>
<type>Function</type>
<arguments>set-goal-column COLUMN</arguments>
<package>editor</package>
<description>
ゴールカラムを設定します。save-excursionしてもgoal-columnが破壊されない
ように使用するぐらいでしょうか。

使用例：
  ;;; goal-columnを大事にして編集してみる。
  (let ((g (goal-column)))
    (save-excursion ... )
    (set-goal-column g))
  =&gt; t  
</description>
<seealso>goal-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-local-window-flags</title>
<type>Function</type>
<arguments>set-local-window-flags WINDOW-OR-BUFFER FLAGS ON-OR-OFF</arguments>
<package>editor</package>
<description>
ウィンドウもしくはバッファの各種表示を制御します。
ほぼ全ての項目で、ウィンドウでもバッファでも設定可能です。
バッファの設定 &gt; ウィンドウの設定 &gt; 全体の設定
の順番で指定が優先されます。

 BUFFER-OR-WINDOW : バッファかウィンドウのいずれかを指定します。
 FLAGS            : 下のフラグのどれかを指定します。
        *window-flag-alternate-vscroll-bar* バッファ全体表示できている
                                            場合の垂直スクロールバー
        *window-flag-cursor-line*           行カーソル
        *window-flag-eof*                   EOF
        *window-flag-fold-line*             折り返しライン
        *window-flag-fold-mark*             折り返し
        *window-flag-full-width-space*      全角スペース
        *window-flag-half-width-space*      半角スペース
        *window-flag-hscroll-bar*           水平スクロールバー
        *window-flag-just-inverse*          （詳細不明）
        *window-flag-line-number*           行番号
        *window-flag-mode-line*             モード行
        *window-flag-newline*               改行
        *window-flag-ruler*                 ルーラ
        *window-flag-scrolling*             描画位置の計算でジャンプスクロール
        *window-flag-tab*                   タブ
        *window-flag-vscroll-bar*           垂直スクロールバー
        *window-flag-zenkaku-space*         全角スペース
                                            (*window-flag-full-width-space*と同じ)
 ON-OR-OFF       : 変更後の値を設定します。
        t        フラグをonにします。
        nil      フラグをoffにします。
        それ以外 デフォルトに戻します。

使用例：
  ;;; カレントバッファの行番号を表示しないようにする。
  (set-local-window-flags (selected-buffer)
                          *window-flag-line-number* nil)
  =&gt; t
</description>
<seealso>set-window-flags</seealso>
<seealso>get-local-window-flags</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-macro-character</title>
<type>Function</type>
<arguments>set-macro-character CHAR FUNCTION &amp;optional NON-TERMINATING-P READTABLE</arguments>
<package>lisp</package>
<description>
マクロ文字を設定します。

  CHAR                  マクロ文字にする文字
  FUNCTION              CHAR が読まれたときに呼ばれる関数
  NON-TERMINATING-P     トークンの途中に現れた CHAR をマクロ文字とみなさない
  READTABLE             設定するリードテーブル

使用例：
  (set-macro-character #\? 'read-test)
  (defun read-test (stream ch)
    (list '*question* (read stream)))
  (read-from-string "?a")
  =&gt; (*question* a)
  =&gt; 2
</description>
<seealso>get-macro-character</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-mark-command</title>
<type>Function</type>
<arguments>set-mark-command</arguments>
<package>editor</package>
<description>
マークを設定します。[ESC SPC], [C-@]
ビルトイン関数の set-mark を対話に行うためのものです。

使用例：
  ;;; マークを設定してその位置を取得する。
  (set-mark-command)
  =&gt; t
  (mark)
  =&gt; 2554
</description>
<seealso>set-mark</seealso>
<seealso>mark-word</seealso>
<seealso>mark-sexp</seealso>
<seealso>mark-defun</seealso>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>set-marker</title>
<type>Function</type>
<arguments>set-marker MARKER &amp;optional POINT</arguments>
<package>editor</package>
<description>
マーカーにポジションを設定します。
POINT が nil の場合は現在の位置を設定します。

  POINT : マーカーに設定する位置

使用例：
  (setq m (make-marker))
  =&gt; #&lt;marker: *scratch*: -&gt;
  (set-marker m)
  =&gt; #&lt;marker: *scratch*: 62&gt;
  (marker-point m)
  =&gt; 62
</description>
<seealso>point-marker</seealso>
<seealso>unset-marker</seealso>
<seealso>make-marker</seealso>
<seealso>marker-point</seealso>
<seealso>goto-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-menu</title>
<type>Function</type>
<arguments>set-menu MENU</arguments>
<package>editor</package>
<description>
指定されたメニューをデフォルトのメニューにします。xyzzy上部に常時表示さ
れるようになります。

  MENU : 設定するメニューを指定します。
         メニューが不要ならばnilを指定します。
</description>
<seealso>use-local-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-minor-mode-map</title>
<type>Function</type>
<arguments>set-minor-mode-map KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
マイナーモード用のキーマップを設定します。
</description>
<seealso>unset-minor-mode-map</seealso>
<seealso>minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-number-of-function-bar-labels</title>
<type>Function</type>
<arguments>set-number-of-function-bar-labels N</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルの数を設定します。指定できる数は、
4/5/8/10/12/15です。
[共通設定] - [表示] - [ファンクションキー] のところでも値を設定できます。
</description>
<seealso>number-of-function-bar-labels</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-per-device-directory</title>
<type>Function</type>
<arguments>set-per-device-directory DIRECTORY</arguments>
<package>lisp</package>
<description>
ドライブ毎のデフォルトのディレクトリを設定します。ドライブ毎のデ
フォルトのディレクトリは、ファイラ等で移動すると毎回更新されます。
更新されたくない場合には、*auto-update-per-device-directory*をnil
に設定します。

使用例：
  (set-per-device-directory "D:/foo/bar")
  (set-per-device-directory "E:/bar/foo")
</description>
<seealso>*auto-update-per-device-directory*</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-eol-code</title>
<type>Function</type>
<arguments>set-process-eol-code PROCESS CODE</arguments>
<package>editor</package>
<description>
PROCESSで処理する場合の改行コードCODEを設定します。
</description>
<seealso>process-eol-code</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-filter</title>
<type>Function</type>
<arguments>set-process-filter PROCESS FILTER</arguments>
<package>editor</package>
<description>
プロセスの出力を加工するためのフィルタを指定します。
プロセスからの入力があるとset-process-filter関数でプロセスと関係づけられた
フィルタ関数が呼ばれます。
フィルタの第一引数はプロセスで第二引数は入力文字列です。
フィルタの戻り値は捨てられるようです。

使用例:
  ;;; プロセスへの出力を試すミニマルではないかも
  (let ((buf (create-new-buffer "hoge")))
    (unwind-protect ;;念の為感が強い
        (progn
           (make-process *eshell* :output buf)
           (set-process-filter (buffer-process buf)
                               (lambda (prc str)
                                 (yes-or-no-p "proc ~S str ~S" prc str)))
           (process-send-string (buffer-process buf)
                                (concat "dir&amp;exit" *shell-ret*))
           (sleep-for 0.9))
      (delete-buffer buf)))
</description>
<seealso>process-filter</seealso>
<seealso>set-process-outcode</seealso>
<seealso>set-process-incode</seealso>
<seealso>set-process-sentinel</seealso>
<seealso>process-send-string</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-incode</title>
<type>Function</type>
<arguments>set-process-incode PROCESS CODE</arguments>
<package>editor</package>
<description>
プロセスからset-process-filterに入力がある場合の文字エンコーディングを指定します。
</description>
<seealso>set-process-outcode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-outcode</title>
<type>Function</type>
<arguments>set-process-outcode PROCESS CODE</arguments>
<package>editor</package>
<description>
プロセスに対してsend-process-stringをする場合の文字エンコーディングを指定します。
</description>
<seealso>set-process-incode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-sentinel</title>
<type>Function</type>
<arguments>set-process-sentinel PROCESS SENTINEL</arguments>
<package>editor</package>
<description>
プロセスが終了する場合に呼ばれる関数（いわゆるSENTINEL）を指定します。
</description>
<seealso>process-sentinel</seealso>
<seealso>set-process-filter</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-comment-column</title>
<type>Function</type>
<arguments>set-syntax-comment-column SYNTAX-TABLE COLUMN</arguments>
<package>editor</package>
<description>
指定された列に#\SPC以外のキャラクタがある場合にコメント行と見な
します。特定のキャラクタだけにしたい場合には、
set-syntax-option を参照して下さい。
  
使用例：
  ;;; cobol-mode.lの定義
  (set-syntax-comment-column *cobol-mode-syntax-table* 6)
</description>
<seealso>set-syntax-option</seealso>
<seealso>set-syntax-start-column-comment</seealso>
<seealso>syntax-table</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-end-c++-comment</title>
<type>Function</type>
<arguments>set-syntax-end-c++-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをC++スタイルのコメントの終了文字として規定します。
開始文字と異なり、終了文字は同じ文字を二つ連ねません。

使用例：
  ;;; cc-mode.l
  (set-syntax-end-c++-comment *c++-mode-syntax-table* #\LFD)
</description>
<seealso>set-syntax-start-c++-comment</seealso>
<seealso>syntax-end-c++-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-end-comment</title>
<type>Function</type>
<arguments>set-syntax-end-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P MAYBE-COMMENT-END-P</arguments>
<package>editor</package>
<description>
文字CHARをコメント終了文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-end-comment *perl-mode-syntax-table* #\LFD)
</description>
<seealso>set-syntax-start-comment</seealso>
<seealso>syntax-end-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-end-multi-comment</title>
<type>Function</type>
<arguments>set-syntax-end-multi-comment SYNTAX-TABLE STRING</arguments>
<package>editor</package>
<description>
文字列STRINGをSYNTAX-TABLEに複数行のコメント終了を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-end-multi-comment *c-mode-syntax-table* "*/")
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>syntax-start-multi-comment-1-p</seealso>
<seealso>syntax-start-multi-comment-2-p</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-escape</title>
<type>Function</type>
<arguments>set-syntax-escape SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARをエスケープ文字として規定します。
文字列中に限らず次の一文字の構文上の機能を抑制します。

使用例：
  ;;; c-mode.l
  (set-syntax-escape *c-mode-syntax-table* #\\)
</description>
<seealso>set-syntax-string</seealso>
<seealso>syntax-escape-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-junk</title>
<type>Function</type>
<arguments>set-syntax-junk SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARをゴミ文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backward でゴミ文字をスキッ
プするのに役に立つかもしれません。
</description>
<seealso>syntax-junk-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-match</title>
<type>Function</type>
<arguments>set-syntax-match SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR</arguments>
<package>editor</package>
<description>
文字OPEN-CHARとCLOSE-CHARをSYNTAX-TABLEに対応付けのある文字として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-match *c-mode-syntax-table* #\( #\))
  (set-syntax-match *c-mode-syntax-table* #\{ #\})
  (set-syntax-match *c-mode-syntax-table* #\[ #\])
</description>
<seealso>syntax-open-p</seealso>
<seealso>syntax-close-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<seealso>goto-matched-parenthesis</seealso>
<seealso>*show-matched-parenthesis*</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-math</title>
<type>Function</type>
<arguments>set-syntax-math SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARを対になった区切り文字として規定します。
Latexの数式モードの区切りに相当します。

使用例：
  ;;; Latex.l
  (set-syntax-math *LaTeX-mode-syntax-table* #\$)
</description>
<seealso>syntax-math-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-option</title>
<type>Function</type>
<arguments>set-syntax-option SYNTAX-TABLE OPTION</arguments>
<package>editor</package>
<description>
シンタックスの補助的な設定をします。

  *syntax-option-c-preprocessor* : （詳細不明）
  *syntax-option-indent-c++*     : （詳細不明）
  *syntax-option-indent-java*    : （詳細不明）
  *syntax-option-indent-csharp*  : （詳細不明）
  *syntax-option-indent-c++/cli* :
        属性や ref class など C++/CLI 用のインデントを有効にします。
  *syntax-option-column-comment-char* :
        set-syntax-comment-column だけでは、指定カラムに空白以外が来ると
        コメントと見なしますが、特定のキャラクタが現れた場合にだけにした
        い場合に設定します。以下の二つを設定しなければなりません。

        1) set-syntax-option に *syntax-option-comment-column-char* を指定する。
        2) set-syntax-start-column-comment でそのキャラクタを指定する。

使用例：
  ;;; fortran.lの定義
  ;;; 0桁目に'C'か'c'が現れたらその行はコメントと見なす。
  (set-syntax-comment-column fortran-mode-syntax-table 0)
  (set-syntax-option fortran-mode-syntax-table
                     *syntax-option-column-comment-char*)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\C)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\c)

参考：
  [xyzzy:07988]を参照のこと
</description>
<seealso>set-syntax-comment-column</seealso>
<seealso>set-syntax-start-column-comment</seealso>
<link>[xyzzy:07988]</link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-punctuation</title>
<type>Function</type>
<arguments>set-syntax-punctuation SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARを句読点文字として規定します。
ほとんど使うことはないでしょう。
</description>
<seealso>syntax-punctuation-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-quote</title>
<type>Function</type>
<arguments>set-syntax-quote SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARをquoteとして規定します。
lispでリストで使う`''(quote)や、マクロで使う``'(backquote) `,'(comma)、
ベクタで使う`#'等があります。シンタックス上では意味付けをすることができ
ますが、どのような違いが出るかは不明。

使用例：
  ; lisp/lispmode.l
  (set-syntax-quote *lisp-mode-syntax-table* #\#)
  (set-syntax-quote *lisp-mode-syntax-table* #\')
  (set-syntax-quote *lisp-mode-syntax-table* #\,)
  (set-syntax-quote *lisp-mode-syntax-table* #\`)
</description>
<seealso>syntax-quote-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-c++-comment</title>
<type>Function</type>
<arguments>set-syntax-start-c++-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをC++スタイルのコメントの開始文字として規定します。
「C++スタイルのコメント」とは同じ文字を二つ連ねる形式のことを指しています。

使用例：
  ;;; cc-mode.l
  (set-syntax-start-c++-comment *c++-mode-syntax-table* #\/)
</description>
<seealso>syntax-c++-comment-p</seealso>
<seealso>set-syntax-end-c++-comment</seealso>
<seealso>set-syntax-start-comment</seealso>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>set-syntax-comment-column</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-column-comment</title>
<type>Function</type>
<arguments>set-syntax-start-column-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
set-syntax-comment-column の補助的な設定をします。
set-syntax-optionに *syntax-option-comment-column-char* を指定した場合に
のコメント開始用のキャラクタを設定します。
詳細は set-syntax-option を参照して下さい。
</description>
<seealso>set-syntax-option</seealso>
<seealso>set-syntax-comment-column</seealso>
<seealso>syntax-start-column-comment-p</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-comment</title>
<type>Function</type>
<arguments>set-syntax-start-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをコメント開始文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-start-comment *perl-mode-syntax-table* #\#)
</description>
<seealso>set-syntax-end-comment</seealso>
<seealso>syntax-start-comment-p</seealso>
<seealso>set-syntax-start-c++-comment</seealso>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-multi-comment</title>
<type>Function</type>
<arguments>set-syntax-start-multi-comment SYNTAX-TABLE STRING</arguments>
<package>editor</package>
<description>
文字列STRINGをSYNTAX-TABLEに複数行のコメント開始を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-start-multi-comment *c-mode-syntax-table* "/*")
</description>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>syntax-start-multi-comment-1-p</seealso>
<seealso>syntax-start-multi-comment-2-p</seealso>
<seealso>parse-point-syntax</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-string</title>
<type>Function</type>
<arguments>set-syntax-string SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARを文字列の区切り文字として規定します。ここで指定した文
字で囲まれた領域はリテラルの文字列として色づけされます。

使用例：
  ; | を 文字列の区切り文字とする場合
  (set-syntax-string *user-mode-syntax-table* #\|)
</description>
<seealso>syntax-string-p</seealso>
<seealso>set-syntax-escape</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-symbol-prefix</title>
<type>Function</type>
<arguments>set-syntax-symbol-prefix SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字をシンボルの前置子として規定します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。  

HTMLの`&amp;'(実体参照)や、Perlの`$'(変数)、`@'(配列)、`%'(連想配列)等が
相当するようです。Emacsの構文テーブルには相当するものが無いように思います。

使用例：
  ;;; perl.l
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\$)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\@)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\%)
</description>
<seealso>syntax-symbol-prefix-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-symbol</title>
<type>Function</type>
<arguments>set-syntax-symbol SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでシンボル名を構成する文字（単語構成文字は除く）と
して規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-symbol *c-mode-syntax-table* #\_)
  (set-syntax-symbol *c-mode-syntax-table* #\#)
</description>
<seealso>syntax-symbol-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-tag</title>
<type>Function</type>
<arguments>set-syntax-tag SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR</arguments>
<package>editor</package>
<description>
シンタックステーブルにタグの開始記号と終了記号を設定します。
HTMLやXML系のモードに設定するといいみたいです。
実際に利用する際にはさらに html-highlight-mode をnon-nilにす
る必要があります。

使用例：
  ;;; htmlmode.lでの定義
  (set-syntax-tag *html-mode-syntax-table* #\&lt; #\&gt;)
</description>
<seealso>html-highlight-mode</seealso>
<seealso>syntax-open-tag-p</seealso>
<seealso>syntax-close-tag-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-whitespace</title>
<type>Function</type>
<arguments>set-syntax-whitespace SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARをwhitespaceとして規定します。whitespaceとして規定され
た文字は skip-white-forward / skip-white-backwardでスキップされるように
なります。

使用例：
  ; lisp/lispmode.l
  (set-syntax-whitespace *lisp-mode-syntax-table* #\SPC)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\TAB)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\C-l)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\RET)
</description>
<seealso>syntax-whitespace-p</seealso>
<seealso>skip-white-forward</seealso>
<seealso>skip-white-backward</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<seealso>skip-syntax-spec-backward</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-word</title>
<type>Function</type>
<arguments>set-syntax-word SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字を単語を構成する文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backwardに影響します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。

デフォルトでは#\0 .. #\9, #\A .. #\Z, #\a .. #\z です。
余程特殊でない限り新たに設定する必要は無いでしょう。
</description>
<seealso>syntax-word-p</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-tab-columns</title>
<type>Function</type>
<arguments>set-tab-columns COLUMN &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
タブ幅を設定します。

  COLUMN : タブ幅を指定します。1以上32以下の任意の整数です。
           2のべき乗である必要はありません。
  BUFFER : タブ幅を変更するバッファを指定します。
           指定がなければカレントバッファが対象になります。
</description>
<seealso>tab-columns</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-text-attribute</title>
<type>Function</type>
<arguments>set-text-attribute FROM TO TAG &amp;key :foreground :background :bold :underline :strike-out :prefix :extend</arguments>
<package>editor</package>
<description>
リージョンに色などの属性を付けます。
付けた属性は delete-text-attributes で消せます。
一括して消す場合には、clear-all-text-attributes を使用します。

  FROM          属性を付加する開始位置
  TO            属性を付加する終了位置
  TAG           個々の属性を区別するタグ
  :bold         ボールドで表示するかどうかを
  :underline    下線付きで表示するかどうかを
  :strike-out   取り消し線を表示するかどうか
  :foreground   文字色を整数で指定
  :background   背景色を整数で指定
  :prefix       使い方は不明
  :extend       行末の改行文字以降も変えるかどうか

色の整数について：
  [ツール]-[共通設定]-[フォント]のところにある表示色になります。

  :foreground 0     : 文字色
              1〜15 : 文字1〜文字15
  :background 0     : 背景色
              1〜15 : 背景1〜背景15

  15 より大きい値を指定すると，0〜15 の色が繰り返されます。

使用例：
  ;;; バッファ全体を文字1の色にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  =&gt; t
  (delete-text-attributes 'all)
  =&gt; t
</description>
<seealso>modify-text-attributes</seealso>
<seealso>find-text-attribute</seealso>
<seealso>delete-text-attributes</seealso>
<seealso>clear-all-text-attributes</seealso>
<seealso>list-text-attributes</seealso>
<seealso>find-text-attribute-point</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-text-color</title>
<type>Function</type>
<arguments>set-text-color FROM TO &amp;optional FOREGROUND BACKGROUND CHAR EXTEND-P</arguments>
<package>editor</package>
<description>
指定された領域を装飾します。

  FROM       : 開始位置を指定します。
  TO         : 終了位置を指定します。
  FOREGROUND : 文字の色を番号で指定します。以下を参照
  BACKGROUND : 文字の色を番号で指定します。以下を参照
  CHAR       : （詳細不明）
  EXTEND-P   : （詳細不明）

参考：
  ;;; 番号と色の対応
         R   G   B
       ------------
   0     0   0   0
   1   255   0   0
   2     0 255   0
   3   255 255   0
   4     0   0 255
   5   255   0 255
   6     0 255 255
   7   255 255 255
   8     0   0   0
   9   128   0   0
  10     0 128   0
  11   128 128   0
  12     0   0 128
  13   128   0 128
  14     0 128 128
  15   128 128 128

補足:
  この関数は Version 0.0.0.92 にて obsolete となりました。
</description>
<seealso>set-text-attribute</seealso>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>get-text-fontset</title>
<type>Function</type>
<arguments>get-text-fontset</arguments>
<package>editor</package>
<description>
フォント設定を取得します。

使用例：
  (get-text-fontset)
  =&gt; ((:ascii :face "Consolas" :size 14 :size-pixel-p nil)
      (:japanese :face "ＭＳ ゴシック" :size 14 :size-pixel-p nil)
      (:latin :face "Courier New" :size 13 :size-pixel-p nil)
      (:cyrillic :face "Courier New" :size 13 :size-pixel-p nil)
      (:greek :face "Courier New" :size 13 :size-pixel-p nil)
      (:cn-simplified :face "MS Hei" :size 14 :size-pixel-p nil)
      (:cn-traditional :face "MingLiu" :size 14 :size-pixel-p nil)
      (:ksc5601 :face "GulimChe" :size 14 :size-pixel-p nil)
      (:georgian :face "BPG Courier New U" :size 14 :size-pixel-p nil))

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>get-text-font</seealso>
<seealso>set-text-font</seealso>
<seealso>set-text-fontset</seealso>
<seealso>increase-text-font-size</seealso>
<seealso>decrease-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-text-fontset</title>
<type>Function</type>
<arguments>set-text-fontset FONTSET</arguments>
<package>editor</package>
<description>
FONTSETで指定したフォントの設定を更新します。
変更したい設定のみを指定可能です。
設定を変更した場合は t が、変更点がなかった場合は nil を返します。
変更した設定はxyzzy.iniに保存されます。

使用例：
  (set-text-fontset '((:ascii :face "Consolas" :size 20 :size-pixel-p t)
                      (:japanese :face "ＭＳ ゴシック" :size 20 :size-pixel-p t)))
  =&gt; t

  (set-text-fontset '((:ascii :size 16)))
  =&gt; t

  (set-text-fontset (get-text-fontset))
  =&gt; nil

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>get-text-font</seealso>
<seealso>set-text-font</seealso>
<seealso>get-text-fontset</seealso>
<seealso>increase-text-font-size</seealso>
<seealso>decrease-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-text-font</title>
<type>Function</type>
<arguments>get-text-font LANG</arguments>
<package>editor</package>
<description>
指定した言語のフォント設定を取得します。

  LANG : フォント設定を変更する言語を指定します。
         :ascii          : ASCII
         :japanese       : 日本語
         :latin          : ラテン文字
         :cyrillic       : キリル文字
         :greek          : ギリシャ語
         :cn-simplified  : 中国語(簡体字)
         :cn-traditional : 中国語(繁体字)
         :ksc5601        : 韓国語
         :georgian       : グルジア文字

使用例：
  (get-text-font :ascii)
  =&gt; (:face "Consolas" :size 14 :size-pixel-p nil)

  (get-text-font :japanese)
  =&gt; (:face "ＭＳ ゴシック" :size 14 :size-pixel-p nil)

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>set-text-font</seealso>
<seealso>set-text-fontset</seealso>
<seealso>get-text-fontset</seealso>
<seealso>increase-text-font-size</seealso>
<seealso>decrease-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-text-font</title>
<type>Function</type>
<arguments>set-text-font LANG &amp; :face :size :size-pixel-p</arguments>
<package>editor</package>
<description>
指定した言語のフォント設定を更新します。
変更したい設定のみを指定可能です。
設定を変更した場合は t が、変更点がなかった場合は nil を返します。
変更した設定はxyzzy.iniに保存されます。

  LANG          : フォント設定を変更する言語を指定します。
                  :ascii          : ASCII
                  :japanese       : 日本語
                  :latin          : ラテン文字
                  :cyrillic       : キリル文字
                  :greek          : ギリシャ語
                  :cn-simplified  : 中国語(簡体字)
                  :cn-traditional : 中国語(繁体字)
                  :ksc5601        : 韓国語
                  :georgian       : グルジア文字
  :face         : フォント名を指定します。
  :size         : フォントサイズを指定します。
  :size-pixel-p : フォントサイズがピクセル単位なら t を指定します。

使用例：
  (set-text-font :ascii :size 10)
  =&gt; t

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>get-text-font</seealso>
<seealso>get-text-fontset</seealso>
<seealso>set-text-fontset</seealso>
<seealso>increase-text-font-size</seealso>
<seealso>decrease-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>increase-text-font-size</title>
<type>Function</type>
<arguments>increase-text-font-size &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
フォントサイズを大きくします。

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>get-text-font</seealso>
<seealso>set-text-font</seealso>
<seealso>set-text-fontset</seealso>
<seealso>get-text-fontset</seealso>
<seealso>decrease-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>decrease-text-font-size</title>
<type>Function</type>
<arguments>decrease-text-font-size &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
フォントサイズを小さくします。

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>get-text-font</seealso>
<seealso>set-text-font</seealso>
<seealso>set-text-fontset</seealso>
<seealso>get-text-fontset</seealso>
<seealso>increase-text-font-size</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-window-configuration</title>
<type>Function</type>
<arguments>set-window-configuration CONF</arguments>
<package>editor</package>
<description>
取得しておいたウィンドウの状態に戻します。

  CONF：current-window-configurationで取得したウィンドウの状態
</description>
<seealso>current-window-configuration</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-window</title>
<type>Function</type>
<arguments>set-window WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウを変更します。
selected-window や get-buffer-window で取得したウィンドウに移動します。

  WINDOW：移動先のウィンドウ

使用例：
  ;;; *scratch*が表示されていれば移動する。
  (setq win (get-buffer-window (find-buffer "*scratch*")))
  =&gt; #&lt;window 48436204&gt;
  (if win (set-window win))
  =&gt; t
  (selected-buffer)
  =&gt; #&lt;buffer: *scratch*&gt;
</description>
<seealso>selected-window</seealso>
<seealso>get-buffer-window</seealso>
<seealso>next-window</seealso>
<seealso>previous-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set</title>
<type>Function</type>
<arguments>set SYMBOL VALUE</arguments>
<package>lisp</package>
<description>
シンボルの値を設定します。
setq と違って局所変数には影響を与えません。

  SYMBOL : シンボル名
  VALUE  : 設定する値

使用例：
  ;;; foo というシンボルを束縛してみる
  (boundp 'foo)         =&gt; nil
  (set 'foo 2)          =&gt; 2
  (boundp 'foo)         =&gt; t
  foo                   =&gt; 2
  ;;; 局所変数には影響しない
  (let ((foo 1))
    (set 'foo 2) foo)   =&gt; 1
</description>
<seealso>setq</seealso>
<seealso>symbol-value</seealso>
<seealso>makunbound</seealso>
<link></link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>setf</title>
<type>Macro</type>
<arguments>setf {PLACE NEW-VALUE}*</arguments>
<package>lisp</package>
<description>
このマクロは、変数にアクセスし、その値を変更するために使われます。従来用
いられてきたsetqよりも汎用的であり、setqと全く置き換えて使用することがで
きます。PLACEは、アクセスしようとするデータオブジェクトのある場所を指し、
NEW-VALUEを評価した値がその場所に書き込まれます。

setfは、いくつでもPLACEやNEW-VALUEの対でも受け付けます。そして、同時にで
はなく、順番に値を割り当てます。つまり、最初の引数の対は、二番目の対が評
価される前に評価され、PLACEによって示される場所に値が書き込まれています。
このように、二番目の引数の対は、最初の対の評価によって割り当てられた値を
使うことが可能です。setfは、最後に評価された引数の対によって割り当てられ
た値、あるいは、まったく引数が与えられなかった場合は、nilを返します。

PLACEの形式は以下のどのようなものも可能です：

(1)変数名(レキシカル変数でもスペシャル変数でもよい)

  (setf hoge 1); 変数hogeに1を代入する
  =&gt; 1
  hoge
  =&gt; 1

(2)アクセス関数
 * 構造体(構造体名＋変数)

  (defstruct foo a b c); 構造体fooを宣言する
  =&gt; #&lt;structure-definition: foo&gt;
  (setf hoge (make-foo)); hogeに空のfoo構造体を代入する(ここのsetfはsetqでもよい)
  =&gt; #S(foo a nil b nil c nil)
  (setf (foo-a hoge) 10); hogeのスロットaに10を代入する
  =&gt; 10
  hoge
  =&gt; #S(foo a 10 b nil c nil)

 * 配列(aref, svref, fill-pointer)

  (setf hoge (make-array 3)); hogeに空のベクタを代入する(ここのsetfはsetqでもよい)
  =&gt; #(nil nil nil)
  (setf (aref hoge 1) 5); hogeベクタの2番目の数値を5にする
  =&gt; 5
  hoge
  =&gt; #(nil 5 nil)

 * リスト(car, cdr, first, rest, etc...)

  (setf hoge '("a" "b" "c"))
  =&gt; ("a" "b" "c")
  (setf (car (cdr hoge)) "d")
  =&gt; "d"
  hoge
  =&gt;("a" "d" "c")

 * 属性リスト(get, getf, symbol-plist)

  (setf (get 'Japan 'language) "Japanese")
  =&gt; "Japanese"
  (setf (get 'Japan 'population) 120000000)
  =&gt; 120000000
  (symbol-plist 'Japan)
  =&gt; (population 120000000 language "Japanese")

 * その他(symbol-value, gethash, symbol-function, documentation, macro-function)
</description>
<seealso>setq</seealso>
<section>変数と定数</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>setq-default</title>
<type>Macro</type>
<arguments>setq-default VAR VAL</arguments>
<package>editor</package>
<description>
シンボルがローカルでない場合のデフォルトの値を設定します。

この関数は、各 symbol のデフォルト値を、(それに対応する) value に設定し
ます。(symbol は評価しませんが) value は評価します。最初の value を返し
ます。 

デフォルト値は、固有のバッファローカル値を持たないバッファで見られます。 

カレントバッファで symbol がバッファローカルでない場合、これは (この)カ
レントバッファで setq を行なうのと同じことになります。 symbol がカレント
バッファでバッファローカルである場合、カレントバッファで見える値ではなく、
他のバッファがまだバッファローカルな値を持たない場合にそこで見える値を設
定します。

使用例：
  (make-variable-buffer-local 'local)
  =&gt; local
  ;; バッファ foo 中:
  (setq local 'foo)
  =&gt; foo
  ;; バッファ bar 中:
  local
  =&gt; nil
  (setq-default local 'default)
  =&gt; default
  local
  =&gt; default
  (setq local 'bar)
  =&gt; bar
  ;; バッファ baz 中:
  local
  =&gt; default
  ;; バッファ foo 中:
  (setq local 'foo)
  =&gt; foo
  (default-value 'local)
  =&gt; default
</description>
<seealso>default-value</seealso>
<seealso>set-default</seealso>
<seealso>make-local-variable</seealso>
<seealso>defvar-local</seealso>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>setq</title>
<type>Special Form</type>
<arguments>setq {VAR FORM}*</arguments>
<package>lisp</package>
<description>
変数に値を設定します。

  (setq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。

  (setq foo '(1 2 3)) = (set 'foo '(1 2 3))

使用例：
  ;;; setとsetqで同じことをしてみる。
  (set 'foo '(2 3 4))   =&gt; (2 3 4)
  foo                   =&gt; (2 3 4)
  (setq foo '(1 2 3))   =&gt; (1 2 3)
  foo                   =&gt; (1 2 3)
</description>
<seealso>setf</seealso>
<seealso>psetq</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>seventh</title>
<type>Function</type>
<arguments>seventh X</arguments>
<package>lisp</package>
<description>
list の 7 番目の要素を返します。

  (seventh X) = (nth 6 X)

使用例：
  (seventh '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 7
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>shell-execute</title>
<type>Function</type>
<arguments>shell-execute FILENAME &amp;optional DIRECTORY PARAMS</arguments>
<package>editor</package>
<description>
何かを行います。URLであればそれを開き、実行ファイルであれば実行したり、
拡張子に応じてアプリケーションを実行します。

  FILENAME  : 何か？URLもOK？
  DIRECTORY : どこでそれを実行するかを指定します。
        t       (cwd)の返されるディレクトリで実行されるみたいです。
        nil     特に指定がないのでFILENAMEのディレクトリで実行されます。

質問：

  | http://java.sun.com/products/jdk/1.2/docs/api/index.html
  | とかをF3キー一発で開けたらって思ってるんです。

  こんなかんじでどうぞ。

  (defun foo ()
    (interactive)
    (shell-execute "http://java.sun.com/products/jdk/1.2/docs/api/index.html" t))
</description>
<seealso>execute-shell-command</seealso>
<seealso>make-process</seealso>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>shift-region</title>
<type>Function</type>
<arguments>shift-region START END &amp;optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))</arguments>
<package>editor</package>
<description>
STARTとENDがある行の範囲をCOLUMN桁だけインデントします。
</description>
<seealso>unshift-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>shiftf</title>
<type>Macro</type>
<arguments>shiftf {PLACE}+ NEWVALUE</arguments>
<package>lisp</package>
<description>
引数として与えられた値の格納場所の内容をシフトさせます。
(shiftf a b c)とすると以下のようになります。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └─┘  └┬┘  └┬┘
              ┌─┘  ┌─┘
          ┌─┘  ┌─┘  
          ↓      ↓      
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 3│
        └─┘  └─┘  └─┘
</description>
<seealso>rotatef</seealso>
<link></link>
<section>変数と定数</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>short-float-p</title>
<type>Function</type>
<arguments>short-float-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがshort-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>show-command-bar</title>
<type>Function</type>
<arguments>show-command-bar SYM</arguments>
<package>editor</package>
<description>
define-command-barで定義したコマンドバーを表示します。
</description>
<seealso>hide-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>show-html-help</title>
<type>Function</type>
<arguments>show-html-help</arguments>
<package>editor</package>
<description>
カーソル位置の文字列を HTML Help から検索します。
*html-help-path* に設定されたヘルプファイルが使用されます。

*html-help-path* の値は、「共通設定」-「ディレクトリ」-「HTML ヘルプ」-
「COL/CHMファイル」から設定できるみたいです。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>winhelp.l</file>
</chapter>

<chapter>
<title>show-tool-bar</title>
<type>Function</type>
<arguments>show-tool-bar NAME &amp;optional EDGE X Y W</arguments>
<package>editor</package>
<description>
ツールバーNAMEを表示します。EDGE X Y Wを指定することで任意の位置に表示さ
せることが可能です。

  EDGE  :top    上側に表示
        :left   左側に表示
        :right  右側に表示
        :bottom 下側に表示
        nil     非表示
  X     横の位置
  Y     縦の位置
  W     タブバーの場合に左右に表示した場合の横幅を与える。
        ツールバーの場合はnilを与える。

[表示]-[ツールバー]に登録したいのならば、show-tool-barではなく、
define-command-bar/show-command-barを使います。
</description>
<seealso>hide-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>show-winhelp</title>
<type>Function</type>
<arguments>show-winhelp</arguments>
<package>editor</package>
<description>
カーソル位置の文字列を WinHelp から検索します。[C-F1]
*winhelp-path* に設定されたヘルプファイルが使用されます。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>winhelp.l</file>
</chapter>

<chapter>
<title>shrink-window-horizontally</title>
<type>Function</type>
<arguments>shrink-window-horizontally &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの幅を小さくします。[C-x {]

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (shrink-window-horizontally (- (window-width) *lister-margin*))
</description>
<seealso>enlarge-window-horizontally</seealso>
<seealso>shrink-window</seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>shrink-window</title>
<type>Function</type>
<arguments>shrink-window &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの高さを小さくします。  [C-x C-z]
</description>
<seealso>shrink-window-horizontally</seealso>
<seealso>enlarge-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>si:*activate-toplevel</title>
<type>Function</type>
<arguments>*activate-toplevel</arguments>
<package>system</package>
<description>
xyzzyを他のウィンドウの最前面に表示します。
</description>
<seealso></seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*app-user-model-id</title>
<type>Function</type>
<arguments>*app-user-model-id</arguments>
<package>system</package>
<description>
xyzzyのアプリケーションIDを返します。
Windows 7以降のタスクバーではこのアプリケーションIDを元に
ウィンドウをグループ化して管理します。

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>create-shortcut</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*builtin-function-p</title>
<type>Function</type>
<arguments>*builtin-function-p OBJECT</arguments>
<package>system</package>
<description>
オブジェクトがビルトイン関数かどうかを調べます。

使用例：
  ;;; carを調べてみる。
  (si:*builtin-function-p #'car)
  =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*load-library</title>
<type>Function</type>
<arguments>*load-library FILENAME &amp;key :no-suffix :if-does-not-exist :no-message</arguments>
<package>system</package>
<description>
ライブラリをロードします。普通は load-library でいいと思いますが、
どんなときにsi:*load-libraryを使うのでしょうか？

  :no-suffix         : non-nil なら指定されたファイル名をそのままロードする。
                       nil なら *load-path* を考慮する。
  :if-does-not-exist : :no-suffix が nil でファイルが存在しない場合、
                       :error ならエラー、それ以外なら nil を返す。
  :no-message        : non-nil ならロード中のメッセージを出さない。
</description>
<seealso>*load-path*</seealso>
<seealso>load-library</seealso>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*stream-line-number</title>
<type>Misc</type>
<arguments>*stream-line-number &amp;optional STREAM</arguments>
<package>system</package>
<description>
（詳細不明）
(si:*stream-line-number *standard-input*)
</description>
<seealso></seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:base64-decode</title>
<type>Function</type>
<arguments>base64-decode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM FOLD-WIDTH</arguments>
<package>system</package>
<description>
Base64でデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はbase64-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。

使用例：
  (si:base64-decode "gtmCsILZgrA=")
  =&gt; "ほげほげ"
</description>
<seealso>si:base64-encode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:base64-encode</title>
<type>Function</type>
<arguments>base64-encode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>system</package>
<description>
Base64エンコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はbase64-encodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。

使用例：  
  (si:base64-encode "ほげほげ")
  =&gt; "gtmCsILZgrA="
</description>
<seealso>si:base64-decode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:closure-variable</title>
<type>Function</type>
<arguments>si:closure-variable CLOSURE</arguments>
<package>system</package>
<description>
クロージャの中身を覗くための関数です。

  CLOSURE : レキシカルクロージャもしくは関数定義に
            レキシカルクロージャを持つシンボルを指定します。

以下の関数でクロージャを参照することが可能です。

  si:closure-variable closure
  si:closure-function closure
  si:closure-frame closure
  si:closure-body closure

使用例：
  (setq foo (let ((x 3)) #'(lambda () (incf x) x)))
  =&gt; #&lt;lexical-closure: (anonymous)&gt;
  (funcall foo)
  =&gt; 4
  (funcall foo)
  =&gt; 5
  (si:closure-variable foo)
  =&gt; ((x . 5))
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:dump-image-path</title>
<type>Function</type>
<arguments>dump-image-path</arguments>
<package>system</package>
<description>
読み込んだダンプファイルのパスを返します。

使用例：
  (si:dump-image-path)
  =&gt; "C:/Program Files/xyzzy/xyzzy.w2k"
</description>
<seealso>dump-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:getenv</title>
<type>Function</type>
<arguments>getenv VARIABLE</arguments>
<package>system</package>
<description>
環境変数の値を取り出します。

  VARIABLE：環境変数名

使用例：
  ;;; 環境変数PATHを取り出して、個々のPATHに分割する。
  (split-string (si:getenv "PATH") #\;)
  =&gt; ("c:\\usr\\local\\bin" "C:\\WINNT\\system32" "C:\\WINNT" ...)
</description>
<seealso>user-name</seealso>
<seealso>machine-name</seealso>
<seealso>si:putenv</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:putenv</title>
<type>Function</type>
<arguments>putenv VARIABLE &amp;optional VALUE</arguments>
<package>system</package>
<description>
環境変数に値を設定します。

  VARIABLE：環境変数名
  VALUE   ：環境変数値

VALUE を省略した場合や nil を指定した場合は環境変数を削除します。

環境変数の設定に成功した場合は設定した値を、環境変数を削除した場合
または設定に失敗した場合は nil を返します。

使用例：
  ;;; 環境変数PATHに$XYZZY/binを追加する
  (si:putenv "PATH" (format nil "~A;~A"
                            (merge-pathnames "bin" (si:system-root))
                            (si:getenv "PATH")))

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:getenv</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:getpid</title>
<type>Function</type>
<arguments>getpid</arguments>
<package>system</package>
<description>
xyzzyのプロセスIDを返します。

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:make-chunk</title>
<type>Function</type>
<arguments>make-chunk TYPE SIZE &amp;optional SOURCE OFFSET</arguments>
<package>system</package>
<description>
チャンクを作成します。チャンクとは外部とのやりとりをするための領域で、
外部DLLの呼び出しをする場合等に使用します。C言語的にはchar[]に相当するよ
うに思います。

  TYPE      : チャンクの型です。現状では使用していないようです。
  SIZE      : チャンクの長さです。
  SRC-CHUNK : 作成するチャンクの元ネタとなるチャンクです。
  OFFSET    : 作成するチャンクの元ネタとなるチャンクの開始位置です。

SRC-CHUNKとOFFSETの組み合わせでチャンクに関連付けされるメモリの取り方が
変わるようです。他のチャンクの内容を使用したい場合等にはを付けましょう。

  ┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┓  
  ┃                  ┃OFFSET                                            ┃  
  ┃                  ┠────────────┬────────────┨  
  ┃                  ┃指定有                  │nil                     ┃  
  ┣━━━━━┯━━━╋━━━━━━━━━━━━┿━━━━━━━━━━━━┫  
  ┃SRC-CHUNK │指定有┃SRC-CHUNK + OFFSETを参照│SRC-CHUNKを共有         ┃  
  ┃          ├───╂────────────┼────────────┨  
  ┃          │nil   ┃OFFSETのアドレスを参照  │新しいメモリを確保      ┃  
  ┗━━━━━┷━━━┻━━━━━━━━━━━━┷━━━━━━━━━━━━┛  

SRC-CHUNK が nil で OFFSET が指定されていた場合には、 OFFSET をアドレス
と見なすのが特殊です。

補足説明：
  si:make-chunkはDLLを呼び出すとき、C言語に渡せるメモリ割り当てを行いま
  す。例えば以下のC言語のコードは
  ┌───────────────────────────────────┐
  │char buf[300];                                                        │
  │DWORD rc = GetCurrentDirectory(300, buf);                             │
  └───────────────────────────────────┘
  xyzzy lispで書くと、以下のようになります。
  ┌───────────────────────────────────┐
  │(let ((s (si:make-chunk nil 300))) ; C言語互換メモリの割り当て        │
  │   (GetCurrentDirectory 300 s)     ; define-dll-entryで定義しておく事 │
  │   (si:unpack-string s 0))         ; lispの文字列に変換               │
  └───────────────────────────────────┘
</description>
<seealso>チャンクの概要</seealso>
<seealso>si:make-string-chunk</seealso>
<seealso>si:unpack-string</seealso>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:make-string-chunk</title>
<type>Function</type>
<arguments>make-string-chunk STRING</arguments>
<package>system</package>
<description>
引数に指定された文字列の内容がコピーされたチャンクを作成します。

使用例：
  ;;; WIN32APIのMessageBoxを使ってみる。
  (let ((s (si:make-string-chunk "hello"))
        (r (si:make-string-chunk "title")))
    (MessageBox 0 s r MB_OK))     ; define-dll-entryで定義する事
</description>
<seealso>si:make-chunk</seealso>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:md5</title>
<type>Function</type>
<arguments>md5 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
MD5ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：  
  (si:md5 "ほげほげ")
  =&gt; "11e100e3eb6e6171d9681ba6641794e3"
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:sha-1</title>
<type>Function</type>
<arguments>sha-1 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA1 ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:sha-1 "ほげほげ")
  =&gt; "ac4dfa2e4d091a8636ea740e326bb72e6e7749a0"
</description>
<seealso>si:md5</seealso>
<seealso>si:sha-224</seealso>
<seealso>si:sha-256</seealso>
<seealso>si:sha-384</seealso>
<seealso>si:sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:sha-224</title>
<type>Function</type>
<arguments>sha-224 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA224 ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:sha-224 "ほげほげ")
  =&gt; "310aa231065ce5c0cd397c2de10dba942fc6580e3631b6354446664d"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:md5</seealso>
<seealso>si:sha-1</seealso>
<seealso>si:sha-256</seealso>
<seealso>si:sha-384</seealso>
<seealso>si:sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:sha-256</title>
<type>Function</type>
<arguments>sha-256 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA256 ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:sha-256 "ほげほげ")
  =&gt; "2f33a6ce8c3ebaf0f3af2f7c6e90d532dcb0e733c8ef2e4f55485302d64de910"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:md5</seealso>
<seealso>si:sha-1</seealso>
<seealso>si:sha-224</seealso>
<seealso>si:sha-384</seealso>
<seealso>si:sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:sha-384</title>
<type>Function</type>
<arguments>sha-384 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA384 ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:sha-384 "ほげほげ")
  =&gt; "a54809e2c52b54e5832ad827dd397a25f73c2997027f7d0da102a2090bc64d29db9f5a95c301abfc5aa62ea35ca9a612"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:md5</seealso>
<seealso>si:sha-1</seealso>
<seealso>si:sha-224</seealso>
<seealso>si:sha-256</seealso>
<seealso>si:sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:sha-512</title>
<type>Function</type>
<arguments>sha-512 INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA512 ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:sha-512 "ほげほげ")
  =&gt; "ae86321f351722bc915b1c5b75262e086bcf074aa8bdd496773d55f267b07d7ce8b58b29680ca821ee3e68c2b50ebe070ac7f183e2663af6b4226e0d400fd782"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:md5</seealso>
<seealso>si:sha-1</seealso>
<seealso>si:sha-224</seealso>
<seealso>si:sha-256</seealso>
<seealso>si:sha-384</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-md5</title>
<type>Function</type>
<arguments>hmac-md5 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
MD5 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-md5 "secret" "ほげほげ")
  =&gt; "12a092046e2629830aca05cc2c85b3af"
</description>
<seealso>si:hmac-sha-1</seealso>
<seealso>si:hmac-sha-224</seealso>
<seealso>si:hmac-sha-256</seealso>
<seealso>si:hmac-sha-384</seealso>
<seealso>si:hmac-sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-sha-1</title>
<type>Function</type>
<arguments>hmac-sha-1 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA1 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-sha-1 "secret" "ほげほげ")
  =&gt; "79b224aa36871315b272fa2d62197b54566f5580"
</description>
<seealso>si:hmac-md5</seealso>
<seealso>si:hmac-sha-224</seealso>
<seealso>si:hmac-sha-256</seealso>
<seealso>si:hmac-sha-384</seealso>
<seealso>si:hmac-sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-sha-224</title>
<type>Function</type>
<arguments>hmac-sha-224 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA224 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-sha-224 "secret" "ほげほげ")
  =&gt; "6ae2369b6dbad816a088f000a0239511fc0ebec228048b3e27e69b17"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:hmac-md5</seealso>
<seealso>si:hmac-sha-1</seealso>
<seealso>si:hmac-sha-256</seealso>
<seealso>si:hmac-sha-384</seealso>
<seealso>si:hmac-sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-sha-256</title>
<type>Function</type>
<arguments>hmac-sha-256 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA256 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-sha-256 "secret" "ほげほげ")
  =&gt; "b965ae8881656b71b29fbdab349fcfe7769d5cd26bce81cc9616205b4c7a9e6e"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:hmac-md5</seealso>
<seealso>si:hmac-sha-1</seealso>
<seealso>si:hmac-sha-224</seealso>
<seealso>si:hmac-sha-384</seealso>
<seealso>si:hmac-sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-sha-384</title>
<type>Function</type>
<arguments>hmac-sha-384 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA384 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-sha-384 "secret" "ほげほげ")
  =&gt; "41a30b9a8e3dd864a20fb1af62b3baa58ddfaea64bc45c817e0803fd1b9ac7437049cd116a97145238cc1b6a0c06a9c5"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:hmac-md5</seealso>
<seealso>si:hmac-sha-1</seealso>
<seealso>si:hmac-sha-224</seealso>
<seealso>si:hmac-sha-256</seealso>
<seealso>si:hmac-sha-512</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:hmac-sha-512</title>
<type>Function</type>
<arguments>hmac-sha-512 KEY INPUT-STRING-OR-STREAM</arguments>
<package>system</package>
<description>
SHA512 関数を利用してメッセージ認証コード値を得ます。

  KEY                    : 秘密鍵
  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：
  (si:hmac-sha-512 "secret" "ほげほげ")
  =&gt; "84410143a5b046a25d9c508e1ac1cdfecff665ae580844fc13f2b22a374e0392ccdc54eb65934d93985ae2130a7e9948e4b8639c117a87f484b5033fd47871f4"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>si:hmac-md5</seealso>
<seealso>si:hmac-sha-1</seealso>
<seealso>si:hmac-sha-224</seealso>
<seealso>si:hmac-sha-256</seealso>
<seealso>si:hmac-sha-384</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:quoted-printable-decode</title>
<type>Function</type>
<arguments>quoted-printable-decode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM UNDERSCORE-TO-SPACE</arguments>
<package>system</package>
<description>
Quoted-Printableデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はquoted-printable-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:octet-length</title>
<type>Function</type>
<arguments>octet-length STRING &amp;key :encoding :start :end</arguments>
<package>system</package>
<description>
指定したエンコーディングでエンコードした場合の文字列のバイトサイズを求めます。

  STRING    : バイトサイズを求める文字列
  :encoding : エンコーディング。デフォルトはエンコーディング変換なし
  :start    : 開始位置。デフォルトは 0 で非負の整数
  :end      : 終了位置。デフォルトは nil で、 nil の場合は文字列の長さを
              指定した場合と等しい動作

使用例：
  (si:octet-length "abc")
  =&gt; 3
  (si:octet-length "abcあいう")
  =&gt; 9
  (si:octet-length "abcアイウ" :start 1 :end 5)
  =&gt; 6
  (si:octet-length "abcアイウ" :encoding *encoding-utf8n*)
  =&gt; 12
  (si:octet-length (convert-encoding-from-internal *encoding-utf8n* "abcアイウ"))
  =&gt; 12

補足：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:system-root</title>
<type>Function</type>
<arguments>system-root</arguments>
<package>system</package>
<description>
xyzzyがインストールされているパスを返します。

※userパッケージもeditorパッケージもsystemをuse-packageしていないので、
  呼び出すときはsi:を付けて、(si:system-root)としなければいけません。

使用例：
  (load (merge-pathnames "lisp/henmi/foo.l" (si:system-root)))
</description>
<seealso>user-homedir-pathname</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:unpack-string</title>
<type>Function</type>
<arguments>unpack-string CHUNK OFFSET SIZE &amp;optional ZERO-TERMINATING-P</arguments>
<package>system</package>
<description>
チャンクをlispの文字列に変換します。

  CHUNK              : make-chunkで作られたチャンク
  OFFSET             : 文字列化する位置を指定します。
  SIZE               : OFFSETの位置から文字列化する長さを指定します。
  ZERO-TERMINATING-P : （詳細不明）
</description>
<seealso>si:make-chunk</seealso>
<seealso>チャンクの概要</seealso>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:uudecode</title>
<type>Function</type>
<arguments>uudecode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>system</package>
<description>
uudecodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はuudecodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。
</description>
<seealso>si:uuencode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:uuencode</title>
<type>Function</type>
<arguments>uuencode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>system</package>
<description>
uuencodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はuuencodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。
</description>
<seealso>si:uudecode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:uuid-create</title>
<type>Function</type>
<arguments>uuid-create &amp;key :sequential</arguments>
<package>system</package>
<description>
UUIDを生成し文字列とリストの多値で返します。

  :sequential : non-nilを指定すると連番のUUIDを生成します。

リストは以下の形式になっています。

  (time-low
   time-mid
   time-high-and-version
   clock-seq-and-reserved
   clock-seq-low
   (node-octet0
    node-octet1
    ...
    node-octet5))

使用例：

  (si:uuid-create)
  =&gt; "0035e2b2-9839-48c6-a914-9c2928d0cd53"
  =&gt; (3531442 38969 18630 169 20 (156 41 40 208 205 83))

  (apply 'format nil "~8,'0X-~4,'0X-~4,'0X-~2,'0X~2,'0X-~{~2,'0X~}"
         '(3531442 38969 18630 169 20 (156 41 40 208 205 83)))
  =&gt; "0035e2b2-9839-48c6-a914-9c2928d0cd53"

  (si:uuid-create :sequential t)
  =&gt; "e05fe0ee-7561-11e1-ba61-000c29aae86e"
  =&gt; (3764379886 30049 4577 186 97 (0 12 41 170 232 110))

  (si:uuid-create :sequential t)
  =&gt; "e05fe0ef-7561-11e1-ba61-000c29aae86e"
  =&gt; (3764379887 30049 4577 186 97 (0 12 41 170 232 110))

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso></seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>signal-process</title>
<type>Function</type>
<arguments>signal-process PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスPROCESSにシグナルを送ります。
※SIGINT?
</description>
<seealso>kill-process</seealso>
<seealso>process-exit-code</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>signum</title>
<type>Function</type>
<arguments>signum NUMBER</arguments>
<package>lisp</package>
<description>
数値の符号を返します。
引数が複素数の場合は偏角が等しく絶対値が 1 の複素数を返します

使用例：
  (signum 12)
  =&gt; 1
  (signum 0)
  =&gt; 0
  (signum -5.0)
  =&gt;-1.0
  (signum (complex 1 1))
  =&gt;#C(0.7071068 0.7071068)
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>simple-string-p</title>
<type>Function</type>
<arguments>simple-string-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsimple-stringならt、それ以外ならnilを返します。

使用例：
  ;;; make-vectorを使ってsimple-stringでないstringを作ります。
  (setq var1 (make-vector 10 :element-type 'character)
        var2 (make-vector 10 :element-type 'character :fill-pointer 0))
  =&gt; ""
  (type-of var1)                =&gt; simple-string
  (type-of var2)                =&gt; string
  (simple-string-p var1)        =&gt; t
  (simple-string-p var2)        =&gt; nil
</description>
<seealso>simple-string</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>simple-string</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
simple-string とはシンプルな文字列のことを指します。
共有可能でなく、フィルポインタを持たず、サイズ変更不可能な文字列のことで
す。formatやconcatを使って文字列を操作する場合にはsimple-stringのままです。

使用例：
  ;;; simple-stringの場合
  (type-of "abc") 
  =&gt; simple-string
</description>
<seealso>simple-string-p</seealso>
<seealso>schar</seealso>
<section>データ型</section>
<file></file>
</chapter>

<chapter>
<title>simple-vector-p</title>
<type>Function</type>
<arguments>simple-vector-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsimple-vectorならt、それ以外ならnilを返します。
</description>
<seealso>vectorp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sin</title>
<type>Function</type>
<arguments>sin RADIANS</arguments>
<package>lisp</package>
<description>
正弦関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>single-float-p</title>
<type>Function</type>
<arguments>single-float-p OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsingle-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sit-for</title>
<type>Function</type>
<arguments>sit-for TIMEOUT &amp;optional NO-REDRAW</arguments>
<package>editor</package>
<description>
指定された秒数停止します。途中でキー入力があれば直ぐに再開します。

  TIMEOUT   : 停止する秒数を指定します。
  NO-REDRAW : 再開後に画面を再描画するかどうかを指定します。
</description>
<seealso>sleep-for</seealso>
<seealso>do-events</seealso>
<seealso>refresh-screen</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sixth</title>
<type>Function</type>
<arguments>sixth X</arguments>
<package>lisp</package>
<description>
list の 6 番目の要素を返します。

  (sixth X) = (nth 5 X)

使用例：
  (sixth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 6
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>skip-chars-backward</title>
<type>Function</type>
<arguments>skip-chars-backward CHARS</arguments>
<package>editor</package>
<description>
skip-chars-forwardの後ろ向きのものです。
</description>
<seealso>skip-chars-forward</seealso>
<seealso>skip-syntax-spec-backward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-chars-forward</title>
<type>Function</type>
<arguments>skip-chars-forward CHARS</arguments>
<package>editor</package>
<description>
指定された文字群を前方方向にスキップします。

  CHARS : スキップする文字群を指定します。

skip-syntax-spec-forwardも似た動作をしますが、これはバッファのシンタック
ステーブルを見てスキップする文字を判断します。目的がはっきりしていれば、
skip-chars-forwardを使用しましょう。

使用例：
  ;;; 半角空白とタブ文字をスキップします。
  (skip-chars-forward " \t")
</description>
<seealso>skip-chars-backward</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-syntax-spec-backward</title>
<type>Function</type>
<arguments>skip-syntax-spec-backward SYNTAX-SPEC</arguments>
<package>editor</package>
<description>
skip-syntax-spec-forwardの後ろ向きのものです。
</description>
<seealso>skip-syntax-spec-forward</seealso>
<seealso>skip-chars-backward</seealso>
<seealso>skip-white-backward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-syntax-spec-forward</title>
<type>Function</type>
<arguments>skip-syntax-spec-forward SYNTAX-SPEC</arguments>
<package>editor</package>
<description>
シンタックステーブルのカテゴリ基づいて文字を前方方向にスキップします。

skip-syntax-spec-(for|back)ward は、シンタックステーブルで指定
される文字のカテゴリに基づいて、指定されたカテゴリに属する文字
をスキップする関数です。カテゴリを表す文字は以下の通りです(7 割
ぐらいは Emacs と互換性あり)。

;  ' '(スペース)  空白文字
;  .              記号
;  (              開き括弧
;  )              閉じ括弧
;  $              TeX の $
;  "              文字列の区切り
;  &lt;             1 文字コメントの開始
;  &gt;             1 文字コメントの終了
;  /              C++ の // コメントの終了
;  \              エスケープ文字
;  '              単独で現れたときは記号、シンボルに隣接している場合はシンボル
;  _              シンボルを構成する文字
;  w              単語を構成する文字
;  k              いわゆる半角カナ
;  j              漢字
;  x              ゴミ文字
;  {              タグの開始
;  }              タグの終了

最初に '^' を指定すると、指定したカテゴリ以外という意味になりま
す(正規表現の[^...]と同じ)。カレントバッファのシンタックステー
ブルに基づくので、バッファのモードによって動きが変わってきます。
ちなみに、単語を構成する文字は一般に英数字で、シンボルを構成す
る文字は単語を構成する文字以外で識別子に使えそうな文字という意
味です。

文字の並びには意味はありません。"w_" と"_w" は同じものを意味します。

使用例：
  ;;; ワードの区切りに移動・英字
  (skip-syntax-spec-forward "w_")

  ;;; ワードの区切りに移動・漢字
  (skip-syntax-spec-forward "jk_")
</description>
<seealso>skip-syntax-spec-backward</seealso>
<seealso>skip-chars-forward</seealso>
<seealso>skip-white-forward</seealso>
<seealso>skip-token</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-token</title>
<type>Function</type>
<arguments>skip-token</arguments>
<package>editor</package>
<description>
多分シンボル構成文字と単語構成文字をスキップします。
（詳細不明）
</description>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-white-backward</title>
<type>Function</type>
<arguments>skip-white-backward</arguments>
<package>editor</package>
<description>
空白文字を後方にスキップします。
シンタックステーブル上でwhitespaceとして規定されている文字を後方に
スキップします。他にも影響する要素があるようですが詳細は不明。
</description>
<seealso>skip-white-forward</seealso>
<seealso>skip-syntax-spec-backward</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-white-forward</title>
<type>Function</type>
<arguments>skip-white-forward</arguments>
<package>editor</package>
<description>
空白文字を前方にスキップします
シンタックステーブル上でwhitespaceとして規定されている文字を前方に
スキップします。他にも影響する要素があるようですが詳細は不明。
</description>
<seealso>skip-white-backward</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sleep-for</title>
<type>Function</type>
<arguments>sleep-for TIMEOUT</arguments>
<package>editor</package>
<description>
指定された秒数停止します。途中でキー入力があっても直ぐには再開しません。

  TIMEOUT   : 停止する秒数を指定します。
</description>
<seealso>sit-for</seealso>
<seealso>refresh-screen</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>smart-indentation</title>
<type>Function</type>
<arguments>smart-indentation COLUMN</arguments>
<package>editor</package>
<description>
行頭からcolumn文字インデントします。
*smart-indentation*がtの時は適度にサボったりするみたいです。
</description>
<seealso>*smart-indentation*</seealso>
<seealso>indent-to</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>software-type</title>
<type>Function</type>
<arguments>software-type</arguments>
<package>lisp</package>
<description>
ソフト名を返します。

使用例：  
  (software-type)
  =&gt; "xyzzy"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>software-version</title>
<type>Function</type>
<arguments>software-version</arguments>
<package>lisp</package>
<description>
xyzzyのバージョンを返します。

使用例：
  (software-version)
  =&gt; "0.2.2.228"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>some</title>
<type>Function</type>
<arguments>some PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、その値をSOMEの戻り値としてすぐに終了します。
PREDICATEを満たす要素が見つからない時は nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>every</seealso>
<seealso>notany</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>sort</title>
<type>Function</type>
<arguments>sort SEQUENCE PREDICATE &amp;key :key</arguments>
<package>lisp</package>
<description>
SEQUENCE を PREDICATE に従った順番に並び替えたものを返します。元の SEQUENCE
は変更されます。 sort は安定であることは保証されません。安定なソートが必要
なときは stable-sort を使いましょう。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :key      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (setq *test-seq* (sort *test-seq* #'string-lessp :key #'car))
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (sort *test-seq* #'string-lessp :key #'car)
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("foo") ("hoge"))

参考：
  [xyzzy:06221] (こっそり)バージョンアップのお知らせ
  ・sort のアルゴリズムを quick から merge に変更
  (比較回数が少ない分、merge の方が速いっぽい)。
  結果、stable-sort と同じになった(が、依存しないように)。
  従来は *たまたま* (eq list (sort list)) だったが、
  そうではなくなったので注意すること。
</description>
<seealso>stable-sort</seealso>
<link>[xyzzy:06221]</link>
<section>シーケンス</section>
<file></file>
</chapter>

<chapter>
<title>special-file-p</title>
<type>Function</type>
<arguments>special-file-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEがデバイスファイル(CON, AUX, NUL, PRN, LPT1/2/3/4, COM1/2/3/4)か
否かを返します。
  t    デバイスファイルである。
  nil  デバイスファイルでない。
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>special-form-p</title>
<type>Function</type>
<arguments>special-form-p SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが特殊形式かどうかを返します。

  SYMBOL : 判定するシンボル

戻り値
  nil      シンボルは特殊形式ではない。
  non-nil  シンボルは特殊形式

  ; 特殊形式を書き出してみる
  (do-all-symbols (i "end")
    (and (special-form-p i)
         (format t "~A~%" i)))
  interactive
  save-restriction
  save-excursion
  save-window-excursion
  *byte-code
  macrolet
  setq
  throw
  return-from
  progn
  let*
  go
  labels
  if
  multiple-value-call
  unwind-protect
  multiple-value-setq
  catch
  tagbody
  eval-when
  let
  multiple-value-bind
  block
  function
  quote
  multiple-value-prog1
  flet
  =&gt;"end"
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>special</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
declare をごらんください。
</description>
<seealso>declare</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>split-line</title>
<type>Function</type>
<arguments>split-line</arguments>
<package>editor</package>
<description>
カーソル位置から行末までのテキストを縦に 1 行下げ、2 行に分割します。[ESC C-o]
</description>
<seealso>open-line</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>split-string</title>
<type>Function</type>
<arguments>split-string STRING SEPARATOR &amp;optional IGNORE-EMPTY CHAR-BAG</arguments>
<package>editor</package>
<description>
文字列を指定されたセパレータ文字で分割したリストにします。
セパレータ文字は含まれません。

  STRING       : 分割する文字列を指定します。
  SEPARATOR    : セパレータ文字を指定します。
  IGNORE-EMPTY : 長さが0の文字列も（つまり、セパレータ文字が連続するような場合）
                 を許すかどうかを指定します。
  CHAR-BAG     : 分割した後の文字列の前後をトリムするための文字群を指定します。
  
使用例：
  (split-string "121,,12321" #\,)       =&gt; ("121" "12321")
  (split-string "121,,12321" #\, t)     =&gt; ("121" "" "12321")
  (split-string "121,,12321" #\, t "1") =&gt; ("2" "" "232")
  (split-string "121,,12321" #\, t "3") =&gt; ("121" "" "12321")
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>split-window-vertically</title>
<type>Function</type>
<arguments>split-window-vertically &amp;optional ARG</arguments>
<package>editor</package>
<description>
ウィンドウを左右に分割します。[C-x 5]
</description>
<seealso>split-window</seealso>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>split-window</title>
<type>Function</type>
<arguments>split-window &amp;optional ARG VERTICAL</arguments>
<package>editor</package>
<description>
ウィンドウを分割します。分割サイズと分割方向が指定可能です。[C-x 2]

  ARG      : 分割サイズを指定します。
  VERTICAL : 分割方向を指定します。
        t       左右に分割します。
        nil     上下に分割します。

分割後にカレントになるウィンドウには注意が必要です。

  (split-window 20 t)
  =&gt; +20-+---------+    
     |   |         |
     +↑-+---------+
      こちらにカーソルがくる
 
  (split-window -20 t)
  =&gt; +---------+20-+
     |         |   |
     +---------+↑-+
                こちらにカーソルがくる

  (split-window 20 nil)
  =&gt; +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+    
     +-------------+    
      
  (split-window -20 nil)
  =&gt; +-------------+    
     +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+          
</description>
<seealso>split-window-vertically</seealso>
<seealso>pop-to-buffer</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sqrt</title>
<type>Function</type>
<arguments>sqrt NUMBER</arguments>
<package>lisp</package>
<description>
平方根の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stable-sort</title>
<type>Function</type>
<arguments>stable-sort SEQUENCE PREDICATE &amp;key :key</arguments>
<package>lisp</package>
<description>
SEQUENCE を PREDICATE に従った順番に並び替えたものを返します。元の SEQUENCE
は変更されます。 stable-sort は安定なソートを行います。つまり PREDICATE によっ
て同順と見なされる要素間の順序は、ソート前と同じであることが保証されます。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :key      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (setq *test-seq* (stable-sort *test-seq* #'string-lessp :key #'car))
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (stable-sort *test-seq* #'string-lessp :key #'car)
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("foo") ("hoge"))
</description>
<seealso>sort</seealso>
<link>[xyzzy:06221]</link>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>start-selection-as-line</title>
<type>Function</type>
<arguments>start-selection-as-line</arguments>
<package>editor</package>
<description>
行選択モードを開始します。[F6]
セレクションが存在する場合は、セレクションを解除します。
</description>
<seealso>start-selection-as-region</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>start-selection-as-region</title>
<type>Function</type>
<arguments>start-selection-as-region</arguments>
<package>editor</package>
<description>
文字選択モードを開始します。[S-F6]
文字選択モードが開始されている場合は、矩形選択モードに切替えます。
矩形選択モードが開始されている場合は、文字選択モードに切替えます。
行選択モードが開始されている場合は、選択モードを解除します。
</description>
<seealso>start-selection-as-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>start-selection</title>
<type>Function</type>
<arguments>start-selection TYPE &amp;optional TEMPORARY POINT</arguments>
<package>editor</package>
<description>
選択領域の範囲指定を開始します。

  TYPE：選択領域の範囲指定の方法を指定します。 
        1の場合         範囲選択を行で行います。
        2の場合         範囲選択を文字で行います。
        3の場合         範囲選択を矩形で行います。

  TEMPORARY：一時的なものかどうかを指定します。
        tの場合         キー入力されると範囲指定を解除します。
        nilの場合       カーソル移動に応じて範囲を変更します。

使用例：
  ;;; 矩形で範囲指定する。
  (start-selection 3 nil)
  =&gt; t
</description>
<seealso>stop-selection</seealso>
<seealso>get-selection-type</seealso>
<seealso>set-selection-type</seealso>
<seealso>fix-selection-point</seealso>
<seealso>pre-selection-p</seealso>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>start-timer</title>
<type>Function</type>
<arguments>start-timer INTERVAL FN &amp;optional ONE-SHOT-P</arguments>
<package>editor</package>
<description>
タイマーを設定します。INTERVAL秒後に、FNがfuncallされます。

  INTERVAL   : 何秒後に関数を実行するかを指定します。
  FN         : 実行する関数を指定します。
  ONE-SHOT-P : 継続して作動させるかどうかを指定します。
        nil      継続して作動させます。
        non-nil  1 回だけ作動させます。
  
使用例：
  ;; パターンを循環参照で作る
  (setq pat '(#\― #\／ #\｜ #\＼))
  =&gt; pat
  (setf (cdr (last pat)) pat)
  =&gt; #1=(#\― #\／ #\｜ #\＼ . #1#)
  (defun func () (setq pat (cdr pat)) (message "~A" (car pat)))
  =&gt; func
  ;; 動かす時は…
  (start-timer 0.2 'func)
  =&gt; t  
  ;; 止める時は…
  (stop-timer 'func)
  =&gt; t
</description>
<seealso>stop-timer</seealso>
<link></link>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>start-xyzzy-server</title>
<type>Function</type>
<arguments>start-xyzzy-server</arguments>
<package>editor</package>
<description>
stop-xyzzy-serverの逆です。複数のxyzzy-serverが立ち上がっている状態で
xyzzycli.exe が実行された場合、最後にアクティブになったほうが選択され
るようです。
</description>
<seealso>stop-xyzzy-server</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>step</title>
<type>Macro</type>
<arguments>step FORM</arguments>
<package>lisp</package>
<description>
ステップ実行を行います。
</description>
<seealso></seealso>
<link></link>
<section>制御構造</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>stop-selection</title>
<type>Function</type>
<arguments>stop-selection</arguments>
<package>editor</package>
<description>
セレクションを解除します。
</description>
<seealso>start-selection</seealso>
<seealso>fix-selection-point</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stop-timer</title>
<type>Function</type>
<arguments>stop-timer FN</arguments>
<package>editor</package>
<description>
設定したタイマーを停止します。
</description>
<seealso>start-timer</seealso>
<link></link>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stop-xyzzy-server</title>
<type>Function</type>
<arguments>stop-xyzzy-server</arguments>
<package>editor</package>
<description>
xyzzycli.exeに反応しないようにします。
</description>
<seealso>start-xyzzy-server</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>store-match-data</title>
<type>Function</type>
<arguments>store-match-data DATA</arguments>
<package>editor</package>
<description>
match-data で退避しておいた検索時点の状態を戻します。
</description>
<seealso>scan-buffer</seealso>
<seealso>match-data</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>streamp</title>
<type>Function</type>
<arguments>streamp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがストリームか否かを返します。
  t    OBJECTはストリームである。
  nil  OBJECTはストリームでない。
</description>
<seealso>open-stream-p</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-capitalize</title>
<type>Function</type>
<arguments>string-capitalize STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING の内部の単語の先頭を大文字に、それ以外を小文字にした文字列を返します。
引数 STRING は保存されます。

使用例：
  (string-capitalize "xYZzY")
  =&gt; "Xyzzy"  
  (string-capitalize "tHis iS a pEn.")
  =&gt; "This Is A Pen."
</description>
<seealso>nstring-capitalize</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-downcase</title>
<type>Function</type>
<arguments>string-downcase STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING を小文字にした文字列を返します。引数 STRING は保存されます。

使用例：
  (string-downcase "XyZzY")
  =&gt; "xyzzy"
  (string-downcase "XYZZY" :start 2 :end 4)
  =&gt; "XYzzY"
</description>
<seealso>nstring-downcase</seealso>
<seealso>char-downcase</seealso>
<seealso>downcase-word</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-equal</title>
<type>Function</type>
<arguments>string-equal STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して等しければt、そうでなけ
ればnilを返します。

使用例：
  (string-equal "foo" "foo")
  =&gt; t
  (string-equal "foo" "Foo")
  =&gt; t
</description>
<seealso>equalp</seealso>
<seealso>string=</seealso>
<seealso>string-not-equal</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-greaterp</title>
<type>Function</type>
<arguments>string-greaterp STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して「&gt;」の条件を満たせば
一致しない文字のインデックスを、そうでなければnilを返します。

使用例：
  (string-greaterp "ac" "ab")
  =&gt; 1
  (string-greaterp "ac" "ac")
  =&gt; nil
  (string-greaterp "AC" "ab")
  =&gt; 1
</description>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-left-trim</title>
<type>Function</type>
<arguments>string-left-trim CHARACTER-BAG STRING</arguments>
<package>lisp</package>
<description>
文字列の先頭から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  先頭の"/"や"\"を取り除きます。
  (string-left-trim "/\\" "/foo/bar/zzz.txt/")
  =&gt; "foo/bar/zzz.txt/"
</description>
<seealso>string-trim</seealso>
<seealso>string-right-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-lessp</title>
<type>Function</type>
<arguments>string-lessp STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して「&lt;」の条件を満たせば
一致しない文字のインデックスを、そうでなければnilを返します。

使用例：  
  (string-lessp "Aa" "ab")
  =&gt; 1
  (string-lessp "ac" "AB")
  =&gt; nil  
</description>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-match</title>
<type>Function</type>
<arguments>string-match REGEXP STRING &amp;optional START END</arguments>
<package>editor</package>
<description>
指定された文字列が正規表現に一致するかどうかを返します。

  REGEXP : 正規表現
  STRING : チェックする文字列
  START  : 文字列の開始位置
  END    : 文字列の終了位置

互換性：
  muleあり。
  Common Lispなし。
</description>
<seealso>string-matchp</seealso>
<seealso>string-looking-at</seealso>
<seealso>looking-at</seealso>
<seealso>正規表現の表記</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-matchp</title>
<type>Function</type>
<arguments>string-matchp REGEXP STRING &amp;optional START END</arguments>
<package>editor</package>
<description>
| string-match と string-matchp とはどこがどう
| 違うのでしょう？

p 付きの方は大文字小文字を区別しません。
</description>
<seealso>string-match</seealso>
<seealso>string-looking-at</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-equal</title>
<type>Function</type>
<arguments>string-not-equal STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して等しくなければ一致しない
文字のインデックスを、そうでなければnilを返します。
string-equalの反対の機能です。
</description>
<seealso>string-equal</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-greaterp</title>
<type>Function</type>
<arguments>string-not-greaterp STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して「&lt;=」の条件を満たせ
ば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-lessp</title>
<type>Function</type>
<arguments>string-not-lessp STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して「&gt;=」の条件を満たせ
ば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-replace-match</title>
<type>Function</type>
<arguments>string-replace-match STRING REPLACEMENT</arguments>
<package>editor</package>
<description>
string-matchで検索した結果を使って文字列の置換を行います。

  STRING      : string-matchで指定した文字列を指定します。
  REPLACEMENT : 置換する文字列を指定します。
                REPLACEには正規表現に部分\1-\9を含めることが可能です。

使用例：
  ;;; 文字列を置換してみる。
  (setq str "01356:00001:error message")
  =&gt; "01356:00001:error message"
  (when (string-match "\\([0-9]+\\):\\([0-9]+\\):\\(.*\\)" str)
    (setq str (string-replace-match str "\\1,\\3")))
  =&gt; "01356,error message"
</description>
<seealso>string-match</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-right-trim</title>
<type>Function</type>
<arguments>string-right-trim CHARACTER-BAG STRING</arguments>
<package>lisp</package>
<description>
文字列の末尾から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  末尾の"/"や"\"を取り除きます。
  (string-right-trim "/\\" "/foo/bar/zzz.txt/")
  =&gt; "/foo/bar/zzz.txt"
</description>
<seealso>string-trim</seealso>
<seealso>string-left-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-trim</title>
<type>Function</type>
<arguments>string-trim CHARACTER-BAG STRING</arguments>
<package>lisp</package>
<description>
文字列の前後から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  前後の"/"や"\"を取り除きます。
  (string-trim "/\\" "/foo/bar/zzz.txt/")
  =&gt; "foo/bar/zzz.txt"
</description>
<seealso>string-right-trim</seealso>
<seealso>string-left-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-upcase</title>
<type>Function</type>
<arguments>string-upcase STRING &amp;key :start :end</arguments>
<package>lisp</package>
<description>
STRING を大文字にした文字列を返します。引数 STRING は保存されます。

使用例：
  (string-upcase "xyzzy")
  =&gt; "XYZZY"
  (string-upcase "xyzzy" :start 2 :end 4)
  =&gt; "xyZZy"
</description>
<seealso>nstring-upcase</seealso>
<seealso>char-upcase</seealso>
<seealso>upcase-word</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string/=</title>
<type>Function</type>
<arguments>string/= STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して等しくなければ一致しない文字のインデックスを、
そうでなければnilを返します。
英字の大文字と小文字は区別します。string=の反対の機能です。
</description>
<seealso>string=</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&lt;=</title>
<type>Function</type>
<arguments>string&lt;= STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して「&lt;=」の条件を満たせば一致しない文字のイン
デックスを、そうでなければnilを返します。
</description>
<seealso>string=</seealso>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&lt;</title>
<type>Function</type>
<arguments>string&lt; STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して「&lt;」の条件を満たせば一致しない文字のインデ
ックスを、そうでなければnilを返します。

使用例：
  (string&lt; "aa" "aa")
  =&gt; nil
  (string&lt; "aa" "ab")
  =&gt; 1
</description>
<seealso>string=</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string=</title>
<type>Function</type>
<arguments>string= STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して等しければt、そうでなければnilを返します。
英字の大文字と小文字は区別します。

使用例：
  (string= "foo" "foo")
  =&gt; t
  (string= "foo" "Foo")
  =&gt; nil
  (string= "together" "frog" :start1 1 :end1 3 :start2 2)
  =&gt; t

参考：
  case-sensitive        case-insensitive
  ----                  ----
  string=               string-equal
  string/=              string-not-equal
  string&lt;               string-lessp
  string&gt;               string-greaterp
  string&lt;=              string-not-greaterp
  string&gt;=              string-not-lessp
</description>
<seealso>equal</seealso>
<seealso>string-equal</seealso>
<seealso>string/=</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;</seealso>
<seealso>string&lt;=</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&gt;=</title>
<type>Function</type>
<arguments>string&gt;= STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して「&gt;=」の条件を満たせば一致しない文字のイン
デックスを、そうでなければnilを返します。
</description>
<seealso>string&lt;</seealso>
<seealso>string&gt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&gt;</title>
<type>Function</type>
<arguments>string&gt; STRING1 STRING2 &amp;key :start1 :end1 :start2 :end2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して「&gt;」の条件を満たせば一致しない文字のインデ
ックスを、そうでなければnilを返します。

使用例：
  (string&gt; "ac" "ab")
  =&gt; 1
  (string&gt; "ac" "ac")
  =&gt; nil
  (string&gt; "AC" "ab")
  =&gt; nil
</description>
<seealso>string&lt;</seealso>
<seealso>string&lt;=</seealso>
<seealso>string&gt;=</seealso>
<seealso>string-lessp</seealso>
<seealso>string-not-lessp</seealso>
<seealso>string-greaterp</seealso>
<seealso>string-not-greaterp</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string</title>
<type>Function</type>
<arguments>string X</arguments>
<package>lisp</package>
<description>
Xが文字列ならそれを返します。シンボルならその名前を返します。
文字や文字のベクタなら、それらの文字からなる文字列を返します。

使用例：
  (string "foo")
  =&gt; "foo"
  (string 'bar)
  =&gt; "bar"
  (string #\a)
  =&gt; "a"
  (string (make-vector 3 :initial-contents '(#\a #\b #\c)))
  =&gt; "abc"
</description>
<seealso>symbol-name</seealso>
<seealso>make-sequence</seealso>
<seealso>format</seealso>
<seealso>coerce</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stringp</title>
<type>Function</type>
<arguments>stringp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがstringならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sub-directory-p</title>
<type>Function</type>
<arguments>sub-directory-p DIRECTORY PARENT</arguments>
<package>lisp</package>
<description>
DIRECTORYがPARENTのサブディレクトリならt、そうでなければnilを返します。

使用例： 
  (sub-directory-p "c:/windows/system" "c:/windows")
  =&gt; t
</description>
<seealso>path-equal</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sublis</title>
<type>Function</type>
<arguments>sublis ALIST TREE &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
TREE の中で ALIST の :key との :test を満たすものを VALUE に置き換えたリストを返します。
引数 TREE は保存されます。

使用例：
  ;;; a-&gt;1、b-&gt;2に変更
  (sublis '((a . 1) (b . 2)) '(a b c))
  =&gt; (1 2 c)
</description>
<seealso>subst</seealso>
<seealso>nsublis</seealso>
<seealso>nsubstitute</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subseq</title>
<type>Function</type>
<arguments>subseq SEQUENCE START &amp;optional END</arguments>
<package>lisp</package>
<description>
SEQUENCEのSTART番目からENDもしくは最後までの新しいsequenceを返します。
</description>
<seealso>last</seealso>
<seealso>butlast</seealso>
<seealso>substring</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst-if-not</title>
<type>Function</type>
<arguments>subst-if-not NEW TEST TREE &amp;key :key</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TREEは保存されます。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  =&gt; ((123 "abc") '(456 "123") (789 #\a))
  (subst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  =&gt; ((123 0) (0 (456 0)) (789 0))
  a
  =&gt; ((123 "abc") '(456 "123") (789 #\a))  
</description>
<seealso>subst-if</seealso>
<seealso>subst</seealso>
<seealso>substitute-if-not</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst-if</title>
<type>Function</type>
<arguments>subst-if NEW TEST TREE &amp;key :key</arguments>
<package>lisp</package>
<description>
TREE の中で TEST を満たすものがあれば NEW に置き換えたものを返します。
引数 TREE は保存されます。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTにはTREEの部分リストと要素を順番に引数として与えるので、必ずしも末端
の要素だけが置き換えの対象とはなりません。例えば、こんな感じで呼び出され
ます。

  ;;; funcで判定する場合
  (subst-if 0 #'func '(1 2 3))

  ;;; funcに引数として与えられる値(1 2 3だけじゃない)
  (1 2 3) 1 (2 3) 2 (3) 3 nil

下の使用例の様に事前の型チェックをして回避します。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  =&gt; ((1 2) ((1 3) (1 (1 3))))
  (subst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  =&gt; ((0 2) ((0 0) (0 (0 0))))
  a
  =&gt; ((1 2) ((1 3) (1 (1 3))))
</description>
<seealso>subst-if-not</seealso>
<seealso>subst</seealso>
<seealso>substitute-if</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst</title>
<type>Function</type>
<arguments>subst NEW OLD TREE &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
TREE の中で OLD を NEW に置き換えた TREE のコピーを返します。
引数 TREE は保存されます。

使用例：
  ;;; 階層のあるツリーをsubstしてみる。aはそのまま
  (setq a '((1 2) ((1 3) (1 4))))       =&gt; ((1 2) ((1 3) (1 4)))
  (subst 5 1 a)                         =&gt; ((5 2) ((5 3) (5 4)))
  a                                     =&gt; ((1 2) ((1 3) (1 4)))
</description>
<seealso>sublis</seealso>
<seealso>nsubst</seealso>
<seealso>subst-if</seealso>
<seealso>subst-if-not</seealso>
<seealso>substitute</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>substitute-if-not</title>
<type>Function</type>
<arguments>substitute-if-not NEWITEM TEST SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は保存されますが、戻り値と一部を共有するかもしれません。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>subst-if-not</seealso>
<seealso>substitute</seealso>
<seealso>substitute-if</seealso>
<seealso>nsubstitute-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substitute-if</title>
<type>Function</type>
<arguments>substitute-if NEWITEM TEST SEQUENCE &amp;key :from-end :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えたシーケンスを返します。
引数 SEQUENCE は保存されますが、戻り値と一部を共有するかもしれません。

  TEST      : テストを行う単項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>subst-if</seealso>
<seealso>substitute</seealso>
<seealso>substitute-if-not</seealso>
<seealso>nsubstitute-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substitute-string</title>
<type>Function</type>
<arguments>substitute-string STRING PATTERN REPLACEMENT &amp;key :case-fold :start :end :skip :count</arguments>
<package>editor</package>
<description>
文字列中の正規表現パターンを置換して返します。

  :case-fold  : nil なら大文字小文字を区別する。
                :smart なら、パターンに大文字が現れないときのみ区別しない。
                その他の場合なら大文字小文字を区別しない。                
  :start      : 開始位置。デフォルトは 0 で非負の整数
  :end        : 終了位置。デフォルトは nil で、 nil の場合は列の長さを
                指定した場合と等しい動作
  :skip       : 指定された回数マッチするまでは置換を行わない
  :count      : 置き換える最大の回数

使用例：
  ;;; 部分文字列を置換する。
  (substitute-string "Hogehoge" "ho" "pa")
  =&gt; "Hogepage"

  ;;; 大文字小文字を区別せず置換する。
  (substitute-string "Hogehoge" "ho" "pa" :case-fold t)
  =&gt; "pagepage"

  ; 正規表現・メタ文字の利用
  (substitute-string "abc123cdef" "[^0-9]*\\([0-9]+\\).*" "\\1 in \\&amp;")
  =&gt;"123 in abc123cdef"
</description>
<seealso>replace-string</seealso>
<seealso>substitute</seealso>
<seealso>replace</seealso>
<seealso>quote-string</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>substitute</title>
<type>Function</type>
<arguments>substitute NEWITEM OLDITEM SEQUENCE &amp;key :from-end :test :test-not :start :end :count :key</arguments>
<package>lisp</package>
<description>
SEQUENCE に対して OLDITEM との :test を満足する要素を NEWITEM に置き換え
たシーケンスを返します。引数 SEQUENCE は保存されますが、戻り値と一部を共有する
かもしれません。

  :test     : テストを行う2項演算子
  :start    : 開始位置。デフォルトは0で非負の整数
  :end      : 終了位置。デフォルトはnilで、nilの場合はSEQUENCEの長さを指定した
              場合と等しい動作。
  :count    : 置き換える最大の回数。
  :from-end : nil ならば先頭から、non-nil で末尾から置換を行う。 :count
              が与えられた時のみ意味を持つ。
</description>
<seealso>substitute-if</seealso>
<seealso>substitute-if-not</seealso>
<seealso>nsubstitute</seealso>
<seealso>subst</seealso>
<seealso>substitute-string</seealso>
<seealso>sublis</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substring</title>
<type>Function</type>
<arguments>substring STRING START &amp;optional END</arguments>
<package>lisp</package>
<description>
指定された文字列の部分文字列を返します。
START, END に負の数値を指定すると文字列の最後からカウントします。

互換性：
  Common Lispにはなし(ただしsubseqがほぼ同等の機能）
  muleあり。
</description>
<seealso>subseq</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subtypep</title>
<type>Function</type>
<arguments>subtypep TYPE1 TYPE2</arguments>
<package>lisp</package>
<description>
ある型が他の型の副型かどうか調べて多値で返します。
（詳細不明）

  TYPE1 : 副型を指定します。
  TYPE2 : 型を指定します。

  t   t         TYPE1は明確にTYPE2の副型
  nil t         TYPE1は明確にTYPE1の副型ではない
  nil nil       関係を判断できない

使用例：
  ;;; サブタイプかどうかを調べる。
  (subtypep 'single-float 'number)
  =&gt; (single-float double-float long-float)
  (subtypep 'cons 'number)
  =&gt; nil
</description>
<seealso>deftype</seealso>
<seealso>typep</seealso>
<seealso>型一覧</seealso>
<section>データ型</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>svref</title>
<type>Accessor</type>
<arguments>svref SIMPLE-VECTOR INDEX</arguments>
<package>lisp</package>
<description>
aref と同じですが、 svref はベクタ(一次元配列)のみにアクセスできます。つ
まり、ベクタ hoge があるとき、 (svref hoge 2) は (aref hoge 2) と同じ意味で
す。ただし、 foo が2x2配列の場合は、 svref でアクセスすることはできません。
</description>
<seealso>aref</seealso>
<seealso>setf</seealso>
<seealso>vector</seealso>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>switch-to-buffer-other-window</title>
<type>Function</type>
<arguments>switch-to-buffer-other-window BUFFER &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
他のウィンドウに移ってからバッファを切り替えます。[C-x 4 b]
ウィンドウ数が1の時は、ウィンドウを分割します。

  BUFFER : このバッファにカレントウィンドウを切り替えます。
  NOWARN : non-nilならば、指定したバッファが他のアプリケーションにより更
           新されているかのチェックを行いません。
</description>
<seealso>switch-to-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>switch-to-buffer</title>
<type>Function</type>
<arguments>switch-to-buffer BUFFER &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
指定されたバッファに移動し、ウィンドウに移動します。 [C-x b]
バッファが存在しなければバッファを作成します。そのバッファを操作中のウ
ィンドウに表示するところ以外は、get-buffer-createのinteractive版と言え
ます。

使用例：
  ;;; *calc*があろうとなかろうと*calc*に移動する。
  (switch-to-buffer "*calc*")
  =&gt; #&lt;buffer: *calc*&gt;
</description>
<seealso>get-buffer-create</seealso>
<seealso>set-buffer</seealso>
<seealso>verify-visited-file-modtime</seealso>
<seealso>switch-to-buffer-other-window</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>symbol-function</title>
<type>Function</type>
<arguments>symbol-function SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが束縛された関数定義を返します。
fletなどで定義したローカルの関数定義は参照できません。

  SYMBOL : 関数定義を取得するシンボル名

使用例：
  ;;; 関数定義の取得
  (symbol-function 'foo)
  =&gt; 関数が定義されていません: foo
  (defun foo (x) (* x 2))
  =&gt; foo
  (symbol-function 'foo)
  =&gt; #&lt;lexical-closure: foo&gt;
</description>
<seealso>symbol-value</seealso>
<seealso>function</seealso>
<link></link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-name</title>
<type>Function</type>
<arguments>symbol-name SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルの名前を印字用の文字列として返します。

使用例：
  ;;; シンボルxyzzyを文字列にしてみる。
  (symbol-name 'xyzzy)
  =&gt; "xyzzy"
</description>
<seealso>intern</seealso>
<seealso>string</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-package</title>
<type>Function</type>
<arguments>symbol-package SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが属するパッケージを返します。
make-symbol とか gensym で生成されたシンボルはどのパッケージにも属しません。

使用例：
  ;;; uninternedなシンボルとそうでないシンボルを作ってみる。
  (setq foo 2)                          =&gt; foo
  (symbol-package 'foo)                 =&gt; #&lt;package: user&gt;
  
  (setq bar (make-symbol "bar"))        =&gt; #:bar
  (set bar 3)                           =&gt; 3
  (symbol-value bar)                    =&gt; 3
  (symbol-package bar)                  =&gt; nil
</description>
<seealso>make-symbol</seealso>
<seealso>gensym</seealso>
<seealso>intern</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-plist</title>
<type>Function</type>
<arguments>symbol-plist SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルのプロパティリストを返す。

使用例：
  ;;; シンボルのプロパティリストを見てみる。
  (symbol-plist 'xyzzy)         =&gt; nil
  (setf (get 'xyzzy 'foo) 1)    =&gt; 1
  (symbol-plist 'xyzzy)         =&gt; (foo 1)
</description>
<seealso>get</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-value</title>
<type>Function</type>
<arguments>symbol-value SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが束縛されている値を返します。
局所変数の値は参照できません。

  SYMBOL : 値を返すシンボル

使用例：
  ;;; foo というシンボルの値を返してみる
  (set 'foo 3)          =&gt; 3
  (symbol-value 'foo)   =&gt; 3
  foo                   =&gt; 3
  ;;; 局所変数は参照できない
  (let ((foo 1))
    (symbol-value 'foo)) =&gt; 3
</description>
<seealso>symbol-function</seealso>
<seealso>default-value</seealso>
<seealso>buffer-local-value</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbolp</title>
<type>Function</type>
<arguments>symbolp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsymbolならt、それ以外ならnilを返します。

  (symbolp x) == (typep x 'symbol)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-c++-comment-p</title>
<type>Function</type>
<arguments>syntax-c++-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがC++スタイルのコメントの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。
</description>
<seealso>set-syntax-start-c++-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-close-p</title>
<type>Function</type>
<arguments>syntax-close-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが括弧などの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。
</description>
<seealso>set-syntax-match</seealso>
<seealso>syntax-open-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-close-tag-p</title>
<type>Function</type>
<arguments>syntax-close-tag-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがタグの終了文字として規定されているかを返します。

  t     タグの終了文字である。
  nil   タグの終了文字でない。
</description>
<seealso>set-syntax-close-tag</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-c++-comment-p</title>
<type>Function</type>
<arguments>syntax-end-c++-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがC++スタイルのコメントの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。
</description>
<seealso>set-syntax-end-c++-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-comment-p</title>
<type>Function</type>
<arguments>syntax-end-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了文字として規定されているかを返します。

  t     コメント終了文字である。
  nil   コメント終了文字でない。
</description>
<seealso>set-syntax-end-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-multi-comment-1-p</title>
<type>Function</type>
<arguments>syntax-end-multi-comment-1-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了の文字列の1文字目として規定されているかを返します。

  t     コメント終了文字列の1文字目である。
  nil   コメント終了文字列の1文字目でない。
</description>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>syntax-end-multi-comment-2-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-multi-comment-2-p</title>
<type>Function</type>
<arguments>syntax-end-multi-comment-2-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了の文字列の2文字目として規定されているかを返します。

  t     コメント終了文字列の2文字目である。
  nil   コメント終了文字列の2文字目でない。
</description>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>syntax-end-multi-comment-1-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-escape-p</title>
<type>Function</type>
<arguments>syntax-escape-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがエスケープ文字として規定されているかを返します。

  t     エスケープ文字である。
  nil   エスケープ文字でない。
</description>
<seealso>set-syntax-escape</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-junk-p</title>
<type>Function</type>
<arguments>syntax-junk-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがゴミ文字として規定されているかを返します。

  t     ゴミ文字である。
  nil   ゴミ文字でない。
</description>
<seealso>set-syntax-junk</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-math-p</title>
<type>Function</type>
<arguments>syntax-math-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが対になった区切り文字として規定されているかを返します。

  t     対になった区切り文字である。
  nil   対になった区切り文字でない。
</description>
<seealso>set-syntax-math</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-open-p</title>
<type>Function</type>
<arguments>syntax-open-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが括弧などの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。
</description>
<seealso>set-syntax-match</seealso>
<seealso>syntax-close-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-open-tag-p</title>
<type>Function</type>
<arguments>syntax-open-tag-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがタグの開始文字として規定されているかを返します。

  t     タグの開始文字である。
  nil   タグの開始文字でない。
</description>
<seealso>set-syntax-tag</seealso>
<seealso>syntax-close-tag-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-punctuation-p</title>
<type>Function</type>
<arguments>syntax-punctuation-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが句読点文字として規定されているかを返します。

  t     句読点文字である。
  nil   句読点文字である。
</description>
<seealso>set-syntax-punctuation</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-quote-p</title>
<type>Function</type>
<arguments>syntax-quote-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでquote(?)として規定されているか否か返します。

  t    CHARはquoteである。
  nil  CHARはquoteでない。
</description>
<seealso>set-syntax-quote</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-column-comment-p</title>
<type>Function</type>
<arguments>syntax-start-column-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
set-syntax-start-column-comment で指定した文字か否かを判定します。
</description>
<seealso>set-syntax-start-column-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-comment-p</title>
<type>Function</type>
<arguments>syntax-start-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント開始文字として規定されているかを返します。

  t     コメント開始文字である。
  nil   コメント開始文字でない。
</description>
<seealso>set-syntax-start-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-multi-comment-1-p</title>
<type>Function</type>
<arguments>syntax-start-multi-comment-1-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字がコメント開始の文字列の1文字目として規定されているかを返します。

  CHAR         : コメント開始の1文字目を指定します。
  SYNTAX-TABLE : シンタックステーブルを指定します。指定しないと、カレン
                 トバッファにしようされているシンタックステーブルが使用
                 されます。

  t     コメント開始文字列の1文字目である。
  nil   コメント開始文字列の1文字目でない。
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>syntax-start-multi-comment-2-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-multi-comment-2-p</title>
<type>Function</type>
<arguments>syntax-start-multi-comment-2-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント開始の文字列の2文字目として規定されているかを返します。

  t     コメント開始文字列の2文字目である。
  nil   コメント開始文字列の2文字目でない。
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>syntax-start-multi-comment-1-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-string-p</title>
<type>Function</type>
<arguments>syntax-string-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEで文字列の区切りとして規定されているか否かを返します。

  t    CHARは文字列の区切り文字である。
  nil  CHARは文字列の区切り文字でない。
</description>
<seealso>set-syntax-string</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-symbol-p</title>
<type>Function</type>
<arguments>syntax-symbol-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字がシンボル名を構成する文字として規定されているかを返します。
ただし単語構成文字は除きます。

  CHAR : 文字を指定します。  

  t     シンボル名を構成する文字である。
  nil   シンボル名を構成する文字でない。
</description>
<seealso>set-syntax-symbol</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-symbol-prefix-p</title>
<type>Function</type>
<arguments>syntax-symbol-prefix-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがシンボルの前置子として規定されているかを返します。

  CHAR : 文字を指定します。  

  t     シンボルの前置子である。
  nil   シンボルの前置子でない。
</description>
<seealso>set-syntax-symbol-prefix</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-table-p</title>
<type>Function</type>
<arguments>syntax-table-p OBJECT</arguments>
<package>editor</package>
<description>
指定されてオブジェクトOBJECTがシンタックステーブルか否かを返します。

  t    シンタックステーブルである。
  nil  シンタックステーブルでない。
</description>
<seealso>make-syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-table</title>
<type>Function</type>
<arguments>syntax-table &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
現在のシンタックステーブルを取り出します。

使用例：
  ;;; evalして挿入
  (defun xmldoc-eval-and-insert ()
    (interactive "p")
    (let ((syntab (syntax-table)))  ;;現在のxmldocモードのsyntax-tableを取り出し
      (let (from to col str start end)
        (cond ((selection-start-end (start end)
                 (setq from start to end)))
              (t
               ;;一時的にlispに切り替えて
               (use-syntax-table ed::*lisp-mode-syntax-table*)
               (unwind-protect
                   (setq from (progn
                                (backward-sexp)
                                (point))
                         to (progn
                              (forward-sexp)
                              (point)))
                 ;; また元に戻す
                 (use-syntax-table syntab))))
</description>
<seealso>make-syntax-table</seealso>
<seealso>syntax-table-p</seealso>
<seealso>use-syntax-table</seealso>
<seealso>parse-point-syntax</seealso>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-whitespace-p</title>
<type>Function</type>
<arguments>syntax-whitespace-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでwhitespaceとして規定されてるか否かを返します。

  t    CHARはwhitespaceでない。
  nil  CHARはwhitespaceである。
</description>
<seealso>set-syntax-whitespace</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-word-p</title>
<type>Function</type>
<arguments>syntax-word-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字が単語を構成する文字として規定されているかを返します。

  CHAR : 判定する文字を指定します。

  t     単語を構成する文字である。
  nil   単語を構成する文字でない。
</description>
<seealso>set-syntax-word</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>t</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
真を表す定数です。
</description>
<seealso>nil</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>tab-bar-add-item</title>
<type>Function</type>
<arguments>tab-bar-add-item BAR ITEM STRING &amp;optional TOOLTIP MENU &amp;key :first :last :before :after</arguments>
<package>editor</package>
<description>
create-tab-barで作成したタブバーBARにタブを追加します。タブを識別するた
めのITEMとタブの文字列STRINGを指定します。個別のツールチップTOOLTIPと、
メニューMENUを指定可能です。
</description>
<seealso>tab-bar-delete-item</seealso>
<seealso>tab-bar-find-item</seealso>
<seealso>tab-bar-current-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-current-item</title>
<type>Function</type>
<arguments>tab-bar-current-item BAR</arguments>
<package>editor</package>
<description>
選択中のタブの情報が返されます。タブがひとつも無い場合には、nilが返され
ます。必ず、タブを識別するためのシンボル、タブの文字列、ツールチップのリ
ストで返されます。ツールチップが設定されていない場合には、nilが返されま
す。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  =&gt; t
  (tab-bar-current-item 'a-bar)
  =&gt; (1st "- 1st -" "1st item")
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  =&gt; t
</description>
<seealso>tab-bar-delete-item</seealso>
<seealso>tab-bar-add-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-delete-item</title>
<type>Function</type>
<arguments>tab-bar-delete-item BAR ITEM</arguments>
<package>editor</package>
<description>
create-tab-barで作成したタブバーBARからタブITEMを削除します。削除するタ
ブが選択状態であれば、次のタブが選択されて同時にCALLBACKが実行されます。
</description>
<seealso>tab-bar-add-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-find-item</title>
<type>Function</type>
<arguments>tab-bar-find-item BAR ITEM</arguments>
<package>editor</package>
<description>
指定されたタブバーBARからタブITEMが存在するか否かを返します。

  t    存在する。
  nil  存在しない。

使用例：
  (tab-bar-find-item 'a-bar '1st)
  =&gt; t
  (tab-bar-find-item 'a-bar '3rd)
  =&gt; nil
</description>
<seealso>create-tab-bar</seealso>
<seealso>tab-bar-list-items</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-list-items</title>
<type>Function</type>
<arguments>tab-bar-list-items BAR</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブのシンボルのリストを返します。

使用例：
  (tab-bar-list-items 'a-bar)
  =&gt; (1st 2nd)
</description>
<seealso>tab-bar-find-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-modify-item</title>
<type>Function</type>
<arguments>tab-bar-modify-item BAR ITEM &amp;optional STRING TOOLTIP MENU</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブITEMの設定を変更します。

使用例：
  (tab-bar-modify-item 'a-bar '1st "- first -")
  =&gt; t
</description>
<seealso>tab-bar-add-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-select-item</title>
<type>Function</type>
<arguments>tab-bar-select-item BAR ITEM</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブITEMを選択状態にします。同時にタブバーに設定
されたCALLBACKが実行されます。
</description>
<seealso>tab-bar-current-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-columns</title>
<type>Function</type>
<arguments>tab-columns &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
タブ幅を返します。タブ幅はset-tab-columnsで設定できます。

  BUFFER : タブ幅を返すバッファを指定します。
           指定がなければカレントバッファが対象となります。
</description>
<seealso>set-tab-columns</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tagbody</title>
<type>Special Form</type>
<arguments>tagbody {TAG|STATEMENT}*</arguments>
<package>lisp</package>
<description>
labelジャンプです。
tagbody内は任意の数のtag(シンボルもしくは数字)とstatement(S式)からなり
実行時にはtagは無視されstatementが実行されます。(go tag)が評価されたときに
実行はtagの場所に移ります。tagbodyは終了時にnilを返します。
</description>
<seealso>go</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tailp</title>
<type>Function</type>
<arguments>tailp SUBLIST LIST</arguments>
<package>lisp</package>
<description>
SUBLISTがLISTを構成しているconsであるかを返す。

具体的にはLISTを順にcdrしていった結果とSUBLISTが
eqならtそうでないならnilを返す。
</description>
<seealso>ldiff</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>tan</title>
<type>Function</type>
<arguments>tan RADIANS</arguments>
<package>lisp</package>
<description>
正接関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tenth</title>
<type>Function</type>
<arguments>tenth X</arguments>
<package>lisp</package>
<description>
list の 10 番目の要素を返します。

  (tenth X) = (nth 9 X)

使用例：
  (tenth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 0
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>terpri</title>
<type>Function</type>
<arguments>terpri &amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAM に改行 (#\LFD) を出力して nil を返します。
</description>
<seealso>fresh-line</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>third</title>
<type>Function</type>
<arguments>third X</arguments>
<package>lisp</package>
<description>
caddr の別名です。全く同じ動きをします。
</description>
<seealso>caddr</seealso>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>throw</title>
<type>Special Form</type>
<arguments>throw TAG RESULT</arguments>
<package>lisp</package>
<description>
catchで指定されたラベルまで、非局所脱出します。
名前はC++と同じです。

  C++  : try    throw
  Lisp : catch  throw

使用例：
  ;;; test2で例外を出してtest1でキャッチする。
  (defun test1 (x)
    (catch 'label1
      (test2 x)))
  =&gt; test1
  (defun test2 (x)
    (if (zerop x)
        (throw 'label1 'division-by-zero)
        (/ 1 x)))
  =&gt; test2
  (test1 0)
  =&gt; division-by-zero

参考：
  エラー処理関連
</description>
<seealso>catch</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>title-bar-format</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
タイトルバーのフォーマットを設定します。

使用例：
  (setq title-bar-format "--%*- %b (%M) [%k:%l] %P %f")

パラメタ：
  %*    変更あり          : **
        書込禁止          : %-
        変更あり・書込禁止: %*
        それ以外          : --
  %#*   変更あり: *
        変更なし: (空白) 
  %r    書込可  : (空白)
        書込禁止: % 
  %#r   書込可        : (空白)
        書込禁止      : %
        不完全バッファ: # 
  %p    プログラム名 
  %v    バージョン 
  %$    プロセスID
  %h    ホスト名 
  %#h   @ホスト名 
  %b    バッファ名 
  %f    File: ファイル名 
  %#f   ファイル名 
  %F    File: ファイル名。ファイル名がなければバッファ名 
  %#F   ファイル名。ファイル名がなければバッファ名 
  %M    モード(マイナーモード含む) 
  %m    モード 
  %k    エンコーディング 
  %l    改行コード 

備考：
  モードラインのフォーマットとほぼ同様ですが、
  %i, %P, %/ はタイトルバーでは設定できません。

備考：
  %$ は xyzzy 0.2.2.236 から利用可能です。
</description>
<seealso>mode-line-format</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>toggle-ime</title>
<type>Function</type>
<arguments>toggle-ime &amp;optional ON-OR-OFF</arguments>
<package>editor</package>
<description>
IMEのON/OFFを制御します。
  non-nil  IMEをONにする
  nil      IMEをOFFにする
  省略時   IMEをトグルする
</description>
<seealso>*ime-mode-hook*</seealso>
<seealso>get-ime-mode</seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>toggle-over</title>
<type>Function</type>
<arguments>toggle-over &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
上書き用マイナーモードを制御します。 [Insert]

  nil以外  上書きモードにする
  nil      挿入モードにする
  省略時   モードをトグルする
</description>
<seealso>overwrite-mode</seealso>
<link></link>
<section>モード</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>toggle-read-only</title>
<type>Function</type>
<arguments>toggle-read-only &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
バッファの書き込み禁止をトグルします。 [C-x C-q]
</description>
<seealso>buffer-read-only</seealso>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>tool-bar-exist-p</title>
<type>Function</type>
<arguments>tool-bar-exist-p NAME</arguments>
<package>editor</package>
<description>
指定されたツールバーNAMEが存在するか否かを返します。

  t    ツールバーが存在する。
  nil  ツールバー存在しない。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tool-bar-info</title>
<type>Function</type>
<arguments>tool-bar-info NAME</arguments>
<package>editor</package>
<description>
指定したツールバーNAMEの情報を多値で返します。

形式：
  表示位置  :top        上側に表示
            :left       左側に表示
            :right      右側に表示
            :bottom     下側に表示
            nil         非表示
  横位置    横の位置を返す。
  縦位置    縦の位置を返す。
  横幅      タブバーの場合に左右に表示した場合の横幅を返す。
            ツールバーの場合はnilを返す。
</description>
<seealso>list-tool-bars</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>track-popup-menu</title>
<type>Function</type>
<arguments>track-popup-menu MENU &amp;optional ANY</arguments>
<package>editor</package>
<description>
フローティングポップアップメニューを表示します。選択されたコマン
ドを実行します。マウスボタンが押されていない場合はnilを返します。

  MENU : create-popup-menuもしくはdefine-popup-menuで作成された
         メニューを指定します。
  ANY  : どのようにポップアップするかを指定できます。
        :button1        マウスの位置にポップアップ
        :button2        マウスの位置にポップアップ
        上記以外        カーソルの位置にポップアップ
</description>
<seealso>create-popup-menu</seealso>
<seealso>define-popup-menu</seealso>
<seealso>popup-string</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>transpose-chars</title>
<type>Function</type>
<arguments>transpose-chars &amp;optional (ARG 1 F)</arguments>
<package>editor</package>
<description>
ポイントのひとつ前の文字を、ポイントの位置の文字と交換します。 [C-t]
ポイント自体はひとつ前に進みます。
</description>
<seealso>transpose-region</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>transpose-paragraphs</title>
<type>Function</type>
<arguments>transpose-paragraphs &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
段落を次の段落と交換します。
</description>
<seealso>transpose-region</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>transpose-region</title>
<type>Function</type>
<arguments>transpose-region MOVER ARG</arguments>
<package>editor</package>
<description>
リージョンを入れ換えます。入れ換えるリージョンは MOVER を funcall して
決定されます。

使用例： 
  (transpose-region 'forward-paragraph arg)
</description>
<seealso>transpose-chars</seealso>
<seealso>transpose-words</seealso>
<seealso>transpose-lines</seealso>
<seealso>transpose-sexps</seealso>
<seealso>transpose-paragraphs</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>transpose-words</title>
<type>Function</type>
<arguments>transpose-words &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置の単語を後方の単語と入れ換えます。[ESC t]
</description>
<seealso>transpose-region</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>truename</title>
<type>Function</type>
<arguments>truename PATHNAME</arguments>
<package>lisp</package>
<description>
相対パスを絶対パスに変えます。

  PATHNAME : 変換するパスを指定します。

使用例：
  ;;; 相対パス及び絶対パスを指定して変換する。
  (truename ".")
  =&gt; "C:/applications/xyzzy"
  (truename "C:/applications/xyzzy/")
  =&gt; "C:/applications/xyzzy"
</description>
<seealso>get-short-path-name</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>truncate</title>
<type>Function</type>
<arguments>truncate NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを0の方向に丸めます。

使用例：
  (truncate 2.8)
  =&gt; 2
  (truncate -2.8)
  =&gt; -2
  (multiple-value-list (truncate 2.8))
  =&gt; (2 0.8)
</description>
<seealso>rem</seealso>
<seealso>floor</seealso>
<seealso>ceiling</seealso>
<seealso>round</seealso>
<seealso>ftruncate</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>two-way-stream-input-stream</title>
<type>Function</type>
<arguments>two-way-stream-input-stream TWO-WAY-STREAM</arguments>
<package>lisp</package>
<description>
make-two-way-stream で作られた TWO-WAY-STREAM の入力元のストリームを返します。
</description>
<seealso>make-two-way-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>two-way-stream-output-stream</title>
<type>Function</type>
<arguments>two-way-stream-output-stream TWO-WAY-STREAM</arguments>
<package>lisp</package>
<description>
make-two-way-stream で作られた TWO-WAY-STREAM の出力先のストリームを返します。
</description>
<seealso>make-two-way-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>type-of</title>
<type>Function</type>
<arguments>type-of OBJECT</arguments>
<package>lisp</package>
<description>
与えられたオブジェクトの型を返します。
(typep OBJECT (type-of OBJECT))は必ずtになります。

使用例：
  ;;; それぞれの型を調べてみる。
  (type-of 1)
  =&gt; integer
  (type-of 2.2)
  =&gt; single-float
  (type-of #'car)
  =&gt; compiled-function
</description>
<seealso>型一覧</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>undefine-key</title>
<type>Function</type>
<arguments>undefine-key KEYMAP KEY</arguments>
<package>editor</package>
<description>
キーマップのキーの割り当てを解除します。

  KEYMAP : キーマップ
  KEY    : 削除するキー

使用例：
  ;;; C-lをfiler-reloadに割り当てて、解除してみる
  (define-key filer-keymap #\C-l 'filer-reload)
  =&gt; t
  (undefine-key filer-keymap #\C-l)
  =&gt; t
</description>
<seealso>define-key</seealso>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>undo-boundary</title>
<type>Function</type>
<arguments>undo-boundary</arguments>
<package>editor</package>
<description>
UNDO情報に境界を設定します。
以後undoを実行すると、この境界まで戻ります。
</description>
<seealso>clear-undo-boundary</seealso>
<seealso>undo</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>undo</title>
<type>Function</type>
<arguments>undo</arguments>
<package>editor</package>
<description>
直前の操作を取り消します。[End], [C-\] 
UNDO情報の直近の境界まで戻ります。
</description>
<seealso>buffer-can-undo-p</seealso>
<seealso>undo-boundary</seealso>
<seealso>clear-undo-boundary</seealso>
<seealso>kept-undo-information</seealso>
<seealso>redo</seealso>
<seealso>last-modified-point</seealso>
<seealso>*move-forward-after-undo-deletion*</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unexport</title>
<type>Function</type>
<arguments>unexport SYMBOLS &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
シンボルのリストを指定して、その全てのシンボルをパッケージの外部から参照
できないようにします。

  ;; find-file は editor パッケージの外部シンボル
  (find-symbol "find-file" "editor")
  =&gt;find-file
    :external

  ;; よって editor パッケージを use している user パッケージから参照できる
  (find-symbol "find-file" "user")
  =&gt;find-file
    :inherited

  ;; 外部から参照できなくする
  (unepxport 'find-file "editor")
  =&gt;t

  ;; 内部シンボルになった
  (find-symbol "find-file" "editor")
  =&gt;editor::find-file
    :internal

  ;; user パッケージから参照できなくなった
  (find-symbol "find-file" "user")
  =&gt;nil
    nil

  ;; 元に戻す
  (export 'ed::find-file "editor")
  =&gt;t
</description>
<seealso>export</seealso>
<seealso>パッケージ</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unicode-char</title>
<type>Function</type>
<arguments>unicode-char CODE</arguments>
<package>editor</package>
<description>
UNICODEのコード値に対応した文字を返します。

使用例：
  ;;; UNICODEから文字を出してみる。
  (unicode-char 28450)
  =&gt; #\漢
</description>
<seealso>char-unicode</seealso>
<seealso>code-char</seealso>
<seealso>*unicode-to-half-width*</seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unintern</title>
<type>Function</type>
<arguments>unintern SYMBOL &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージにシンボルがあれば削除してtを、なければnilを返します。
</description>
<seealso>intern</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>uninterned</title>
<type>Misc</type>
<arguments></arguments>
<package></package>
<description>
uninterned とは intern されていない状態を表します。
すなわちどのパッケージにも属していない状態です。

使用例：
  ;;; make-symbolでパッケージに属さないシンボルを作ってみる。
  (setq a (make-symbol "foo"))  =&gt; #:foo
  (symbol-package a)            =&gt; nil
</description>
<seealso>make-symbol</seealso>
<seealso>gensym</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>unless</title>
<type>Macro</type>
<arguments>unless TEST &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件が成立しない場合に実行します。whenの逆です。

  (unless 条件式  本体 ....)
</description>
<seealso>when</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>unread-char</title>
<type>Function</type>
<arguments>unread-char CHARACTER &amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力ストリームに一文字戻します。

  CHARACTER    : 入力ストリームに戻す文字
  INPUT-STREAM : 入力ストリーム
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unregister-history-variable</title>
<type>Function</type>
<arguments>unregister-history-variable VAR</arguments>
<package>editor</package>
<description>
変数をヒストリ変数の登録から削除します。
</description>
<seealso>define-history-variable</seealso>
<seealso>register-history-variable</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>unset-marker</title>
<type>Function</type>
<arguments>unset-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーのポジションを解除します。
オブジェクトはマーカーとして残ります。

使用例：
  (unset-marker m)
  =&gt; t
  m
  =&gt; #&lt;marker: *scratch*: -&gt;
</description>
<seealso>set-marker</seealso>
<seealso>delete-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unset-minor-mode-map</title>
<type>Function</type>
<arguments>unset-minor-mode-map KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
マイナーモード用のキーマップを解除します。
</description>
<seealso>set-minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unshift-region</title>
<type>Function</type>
<arguments>unshift-region START END &amp;optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))</arguments>
<package>editor</package>
<description>
STARTとENDがある行の範囲をCOLUMN桁だけインデントを戻します。
</description>
<seealso>shift-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>unuse-package</title>
<type>Function</type>
<arguments>unuse-package PACKAGES-TO-UNUSE &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージが別のパッケージを使用しないようにします。

使用例：
  ;;; 使用例はcalc.lを参照
  (unuse-package "lisp" *calc-package*)
  =&gt; t
</description>
<seealso>use-package</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unwind-protect</title>
<type>Special Form</type>
<arguments>unwind-protect PROTECTED-FORM {CLEANUP-FORM}*</arguments>
<package>lisp</package>
<description>
PROTECTED-FORM 中に終了もしくは例外が発生しても（正常、異常を問わず）
CLEANUP-FORM を実行します。

使用例：
  ;;; ゼロ除算が起きても CLEANUP-FORM が実行される。
  (progn
    (msgbox "計算前")
    (unwind-protect (/ 1 0)
      (msgbox "計算後")))
  =&gt; 0で除算しました: /: (1 0)
</description>
<seealso>handler-case</seealso>
<seealso>ignore-errors</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>upcase-region</title>
<type>Function</type>
<arguments>upcase-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語を大文字にします。[C-x C-u]
</description>
<seealso>upcase-word</seealso>
<seealso>capitalize-region</seealso>
<seealso>downcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>upcase-word</title>
<type>Function</type>
<arguments>upcase-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から単語の末尾までを大文字に変換します。[ESC u]
</description>
<seealso>downcase-word</seealso>
<seealso>capitalize-word</seealso>
<seealso>upcase-region</seealso>
<seealso>upcase-selection</seealso>
<seealso>string-upcase</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>


<chapter>
<title>update-mode-line</title>
<type>Function</type>
<arguments>update-mode-line &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
モード行を更新します。mode-line-formatの変更などを行った場合に、速やかに
モード行に反映したい場合に実行します。
</description>
<seealso>mode-line-format</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>upper-case-p</title>
<type>Function</type>
<arguments>upper-case-p CHAR</arguments>
<package>lisp</package>
<description>
CHAR が大文字なら t 、そうでなければ nil を返します。

使用例：  
  (upper-case-p #\A)
  =&gt; t
  (upper-case-p #\a)
  =&gt; nil
  (upper-case-p #\RET)
  =&gt; nil
</description>
<seealso>lower-case-p</seealso>
<seealso>both-case-p</seealso>
<seealso>char-upcase</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-keymap</title>
<type>Function</type>
<arguments>use-keymap KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが使用するキーマップを設定します。

  KEYMAP : 使用するキーマップを指定します。
  BUFFER : バッファを指定します。省略時はカレントバッファに適用されます。

使用例：
  ;;; lispmode.lより
  (defun lisp-mode ()
    (interactive)
    (kill-all-local-variables)
    (setq buffer-mode 'lisp-mode)
    (setq mode-name "Lisp")
    (use-keymap *lisp-mode-map*)
    ...
    (run-hooks '*lisp-mode-hook*))
</description>
<seealso>make-keymap</seealso>
<seealso>define-key</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-local-menu</title>
<type>Function</type>
<arguments>use-local-menu MENU</arguments>
<package>editor</package>
<description>
カレントバッファにローカルなメニューを設定します。

  MENU : バッファにローカルなメニューを指定します。nilを設定するとローカ
         ルなメニューは解除され、デフォルトのメニューが使用されます。
</description>
<seealso>set-menu</seealso>
<seealso>current-menu</seealso>
<seealso>define-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-package</title>
<type>Function</type>
<arguments>use-package PACKAGES-TO-USE &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
指定されたパッケージ（省略された場合はカレントのパッケージ）が使
用する他のパッケージを設定します。
</description>
<seealso>export</seealso>
<seealso>defpackage</seealso>
<seealso>パッケージ</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-syntax-table</title>
<type>Function</type>
<arguments>use-syntax-table SYNTAX-TABLE &amp;optional BUFFER (INVALIDATE-P T)</arguments>
<package>editor</package>
<description>
バッファで使用するシンタックステーブルを設定します。

使用例：
  ;;; lispmode.lの例
  (use-syntax-table *lisp-mode-syntax-table*)
  =&gt; t
</description>
<seealso>syntax-table-p</seealso>
<seealso>syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>user-config-path</title>
<type>Function</type>
<arguments>user-config-path</arguments>
<package>editor</package>
<description>
ユーザ設定を格納しているディレクトリを返します。
ダイアログでの規定値等が格納されるディレクトリです。

起動時オプション -config で指定したり，XYZZYCONFIGPATH
で指定可能です。両方指定された場合，起動時オプションが
優先されます。

使用例：
  (user-config-path)
  =&gt;"H:/xyzzy/usr/Administrator/w2k/"
</description>
<seealso>user-homedir-pathname</seealso>
<seealso>si:system-root</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>user-homedir-pathname</title>
<type>Function</type>
<arguments>user-homedir-pathname</arguments>
<package>lisp</package>
<description>
ユーザーのホームディレクトリを返します。

find-fileしたときに"~/"で参照可能なディレクトリです。
起動時に、このディレクトリに格納されている.xyzzyを読み込みます。
同一PCを複数人で使用していたり、ネットワーク共有されたフォルダに
xyzzyを格納した場合には、ユーザ毎にホームディレクトリの設定して
.xyzzyを切り替えることができます。

ユーザのホームディレクトリは、以下の順番で決定されます。

  1)iniファイル内の[init]homeDir
  2)環境変数 XYZZYHOME
  3)環境変数 HOME
  4)環境変数 HOMEDRIVE + HOMEPATH
  5)iniファイル内の[init]logDir
  6)xyzzy.exeのpath

使用例：
  (user-homedir-pathname)
  =&gt; "C:/HOME/"
</description>
<seealso>si:system-root</seealso>
<seealso>user-config-path</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>user-name</title>
<type>Function</type>
<arguments>user-name</arguments>
<package>editor</package>
<description>
Windowsのログオンユーザー名を返します。
</description>
<seealso>machine-name</seealso>
<seealso>si:getenv</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>uudecode-region-to-file</title>
<type>Function</type>
<arguments>uudecode-region-to-file FILENAME FROM TO</arguments>
<package>editor</package>
<description>
リージョンをuudecodeしてファイルに保存します。
</description>
<seealso>si:uudecode</seealso>
<seealso>uudecode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>uudecode-region</title>
<type>Function</type>
<arguments>uudecode-region FROM TO</arguments>
<package>editor</package>
<description>
リージョンをuudecodeします。
</description>
<seealso>si:uudecode</seealso>
<seealso>uudecode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>valid-path-p</title>
<type>Function</type>
<arguments>valid-path-p PATHNAME</arguments>
<package>lisp</package>
<description>
パスが有効かどうかをチェックします。

  PATHNAME : 有効かどうかをチェックするパス

ここで「有効なパス」というのは、最終的なファイルやディレクトリが存在する
ことを指すのではなく、途中の経路が存在することを指します。ファイルを指し
示している場合には、そのファイル自体の有無は関係ありません。そのファイル
に至るディレクトリが全て存在していることが有効か否かに関わります。

使用例：
  (valid-path-p "foo/bar/zzz.txt")
  =&gt;nil
  (valid-path-p "/autoexec.bat")
  =&gt;t
</description>
<seealso>check-valid-pathname</seealso>
<seealso>file-exist-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>values-list</title>
<type>Function</type>
<arguments>values-list LIST</arguments>
<package>lisp</package>
<description>
指定されたリストを多値として返します。

  (values-list '(a b c)) == (values a b c)
  (values-list list) == (apply #'values list)
</description>
<seealso>values</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>values</title>
<type>Function</type>
<arguments>values &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
多値で値を返します。

C言語では関数は1つの値しか返すことができませんが、Common Lispでは複数の
値を返す事ができます（リストとは違います）。これを多値（関数）と呼びます。
複数の値を返したい時は、 (values 値1 値2 ..)という構文を使います。

多値関数を呼び出す場合には、複数の戻り値を受け取れるように 
multiple-value-bind または multiple-value-listを使って受け取ります。

互換性：
  Common Lispとxyzzyにはあり。
  muleにはなさそう。
</description>
<seealso>values-list</seealso>
<seealso>multiple-value-bind</seealso>
<seealso>multiple-value-list</seealso>
<seealso>multiple-value-setq</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>vector-push-extend</title>
<type>Function</type>
<arguments>vector-push-extend NEW-ELEMENT VECTOR &amp;optional EXTENSION</arguments>
<package>lisp</package>
<description>
ベクタ VECTOR に新しい要素を追加します。長さが足りなければ拡張します。
VECTOR はフィルポインタを持ち、かつアジャスタブルなベクタである必要があります。

  NEW-ELEMENT：新しい要素 
  VECTOR     ：追加するベクタ
  EXTENSION  ：拡張する時のサイズ増加量。
               デフォルトでは 64 増えます。

使用例：
  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq vec (make-vector 10 :element-type 'character
                            :fill-pointer 0 :adjustable t))
  =&gt; ""
  (vector-push-extend #\a vec)  =&gt; 0
  vec                           =&gt; "a"
  (vector-push-extend #\b vec)  =&gt; 1
  vec                           =&gt; "ab"

  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq s (make-vector 10 :element-type 'character
                          :fill-pointer 0 :adjustable t))
  =&gt; ""
  (dotimes (i 20 s)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s))
  =&gt; "@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSS"
</description>
<seealso>vector-push</seealso>
<seealso>adjustable-array-p</seealso>
<seealso>fill-pointer</seealso>
<seealso>vector</seealso>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>vector</title>
<type>Function</type>
<arguments>vector &amp;rest LIST</arguments>
<package>lisp</package>
<description>
要素 LIST からなるベクタをつくります。

  (setf v (vector 1 2 "oop"))
  =&gt;#(1 2 "oop")

ベクタの各要素にアクセスするためには、svref(あるいはaref)が使われます。
</description>
<seealso>svref</seealso>
<seealso>aref</seealso>
<seealso>setf</seealso>
<seealso>length</seealso>
<seealso>vector-pop</seealso>
<seealso>vector-push</seealso>
<seealso>vector-push-extend</seealso>
<seealso>vectorp</seealso>
<seealso>fill-pointer</seealso>
<seealso>make-vector</seealso>
<seealso>make-array</seealso>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>vectorp</title>
<type>Function</type>
<arguments>vectorp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがvectorならt、それ以外ならnilを返します。
</description>
<seealso>simple-vector-p</seealso>
<seealso>vector</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>verify-visited-file-modtime</title>
<type>Function</type>
<arguments>verify-visited-file-modtime &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファがファイルに関連付けられていない、もしくはバッファとそれに関連付
けられたファイルとの更新時間が一致していると t を返します。バッファとそ
れに関連付けられたファイルとの更新時間が一致していない時、つまり他のプロ
セスによってファイルが変更された時などに nil を返します。
</description>
<seealso>verify-buffers-file-modtime</seealso>
<seealso>switch-to-buffer</seealso>
<seealso>find-file-verify</seealso>
<seealso>clear-visited-file-modtime</seealso>
<seealso>update-visited-file-modtime</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>
<chapter>
<title>verify-visited-file-modtime</title>
<type>BufferLocal</type>
<package>editor</package>
<description>
activate 時のバッファの最終更新日チェックを制御します。
  :auto    更新されていれば自動的に読み直す
  non-nil  チェックする
  nil      チェックしない
</description>
<seealso>verify-buffers-file-modtime</seealso>
<seealso>switch-to-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>version-up-xyzzy</title>
<type>Function</type>
<arguments>version-up-xyzzy &amp;rest ARGS</arguments>
<package>editor</package>
<description>
亀井さんが配布しているxyzzyのアーカイブファイルをxyzzyがインストールされている
ディレクトリに展開します。
別途、ダンプファイルの再作成をする必要があります。
</description>
<seealso>dump-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>verup.l</file>
</chapter>

<chapter>
<title>virtual-bolp</title>
<type>Function</type>
<arguments>virtual-bolp</arguments>
<package>editor</package>
<description>
仮想行の行頭にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行頭にある
  nil   仮想行の行頭にない
</description>
<seealso>virtual-eolp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>virtual-eolp</title>
<type>Function</type>
<arguments>virtual-eolp</arguments>
<package>editor</package>
<description>
仮想行の行末にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行末にある
  nil   仮想行の行末にない
</description>
<seealso>virtual-bolp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>when</title>
<type>Macro</type>
<arguments>when TEST &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件がnilでなければフォームを連続して実行します。

  TEST : 条件部
  BODY : nilでない場合に実行するフォーム

whenはマクロです。以下の様に展開されます。

 (when exp1 exp2 exp3 ...)
 = (if exp1
      (progn exp2
             exp3
             ...))
</description>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>while</title>
<type>Macro</type>
<arguments>while TEST &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件節が成立する間、BODYを繰り返して実行します。
BODYの実行の途中でwhileを抜けるには、returnを使います。

  (while 条件 本体)

使用例：
  ;;; 確認しつつ処理を実行する場合
  (while (yes-or-no-p "次行に移動しますか？")
    (forward-line)
    (reverse-region (progn (goto-bol) (point))
                    (progn (goto-eol) (point)) t)
    (refresh-screen))
  =&gt; nil
</description>
<seealso></seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>widen</title>
<type>Function</type>
<arguments>widen</arguments>
<package>editor</package>
<description>
narrow-to-regionで制限された領域を元に戻します。[C-x w]
</description>
<seealso>narrow-to-region</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>wild-pathname-p</title>
<type>Function</type>
<arguments>wild-pathname-p PATHNAME</arguments>
<package>lisp</package>
<description>
ワイルドカード指定されたパスかどうかを返します。

  t     ワイルドカード指定されたパスです。
  nil   ワイルドカード指定されていません。

使用例：
  ;;; ワイルドカードかどうかを調べてみる。
  (wild-pathname-p "site-lisp/*.l")
  =&gt; t
</description>
<seealso>*brackets-is-wildcard-character*</seealso>
<seealso>pathname-match-p</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-buffer</title>
<type>Function</type>
<arguments>window-buffer WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウが表示しているバッファを返します。
  
使用例：
  (window-buffer (selected-window))
</description>
<seealso>get-buffer-window</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-coordinate</title>
<type>Function</type>
<arguments>window-coordinate &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたウィンドウの座標をリストで返します。
(左端のx座標 左端のy座標 右端のx座標 右端のy座標)

座標軸は左上が (0 0) で右下にいくほど値が大きくなり、
単位はピクセルです。

使用例:
  (window-coordinate)
  =&gt; (0 0 693 636)
</description>
<seealso>window-width</seealso>
<seealso>window-height</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-height</title>
<type>Function</type>
<arguments>window-height &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウの高さを行単位で返します。
部分的でなく完全に表示可能な行の数を返しますが、返す最小値は 1 です。
xyzzy 0.2.2.232 では内部的には window-lines と完全に同一定義です。

使用例：
  ;;; 現在のウィンドウを縦に半分にする。
  (split-window (- (floor (window-height) 2) 2))
  =&gt; t

補足：
  xyzzy 0.2.2.232 では内部的には window-lines と完全に同一定義ですが、
  window-height と window-lines は同一オブジェクトではありません。
  (eq #'window-height #'window-lines) =&gt; nil
</description>
<seealso>window-lines</seealso>
<seealso>window-width</seealso>
<seealso>window-columns</seealso>
<seealso>screen-height</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-lines</title>
<type>Function</type>
<arguments>window-lines &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウの表示可能行数を返します。
部分的でなく完全に表示可能な行の数を返しますが、返す最小値は 1 です。
xyzzy 0.2.2.232 では内部的には window-height と完全に同一定義です。

使用例：
  (window-lines)
  =&gt; 18

補足：
  xyzzy 0.2.2.232 では内部的には window-height と完全に同一定義ですが、
  window-lines と window-height は同一オブジェクトではありません。
  (eq #'window-lines #'window-height) =&gt; nil
</description>
<seealso>window-height</seealso>
<seealso>window-width</seealso>
<seealso>window-columns</seealso>
<seealso>get-window-line</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-width</title>
<type>Function</type>
<arguments>window-width &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウの幅をキャラクタ単位で返します。
文字を表示可能な領域の幅ではなく、「行番号」表示領域、「折り返しマーク」
表示領域を含んだ領域についての幅を返します。
キャラクタ幅に満たない幅については切り捨てますが、返す最小値は 1 です。
</description>
<seealso>window-columns</seealso>
<seealso>window-height</seealso>
<seealso>window-lines</seealso>
<seealso>screen-width</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>windowp</title>
<type>Function</type>
<arguments>windowp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがウィンドウかを返します。

  t     OBJECTがウィンドウ
  nil   OBJECTはウィンドウではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>with-hash-table-iterator</title>
<type>Macro</type>
<arguments>with-hash-table-iterator (MNAME HASH-TABLE) &amp;body BODY</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの要素を順番に返す関数を返してもらいます。

  MNAME      : 要素を順番に返す関数名を指定します。
               この関数は要素を列挙し終わるとnilを返します。
  HASH-TABLE : ハッシュテーブルを指定します。
  BODY       : フォームを記述します。

関数が順番に要素を返すので、loopを使ってnilが返るまで繰り返します。

使用例：
(with-hash-table-iterator (foo hsh)
  (loop
    (multiple-value-bind (f x y)
        (foo)
      (unless f (return))
      (format t "~S ~S~%" x y))))
</description>
<seealso>maphash</seealso>
<link></link>
<section>ハッシュ</section>
<file>hash.l</file>
</chapter>

<chapter>
<title>with-input-from-buffer</title>
<type>Macro</type>
<arguments>with-input-from-buffer (BUFFER &amp;optional POINT EOB) &amp;rest BODY</arguments>
<package>editor</package>
<description>
バッファを入力ストリームとして扱えるようになり、
*standard-input*から読み込まれるようになります。

使用例：
  ;;; *scratch*の内容を*Output*に吐き出す。
  (with-output-to-buffer ((switch-to-buffer "*Output*"))
    (with-input-from-buffer ((switch-to-buffer "*scratch*"))
      (while (setq line (read-line *standard-input* nil))
        (princ line)
        (princ "\n"))))
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-input-from-selected-buffer</title>
<type>Macro</type>
<arguments>with-input-from-selected-buffer &amp;rest BODY</arguments>
<package>editor</package>
<description>
現在のバッファを標準入力にして読み込みます。

使用例：
  ;;; 現在のバッファから読み込んで変数に入れる。
  (with-input-from-selected-buffer
    (setq name (read) count (read) exp (read)))
</description>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-open-file</title>
<type>Macro</type>
<arguments>with-open-file (STREAM FILENAME &amp;rest OPTIONS) &amp;body BODY</arguments>
<package>lisp</package>
<description>
指定されたファイルからストリームを作成し、本体を評価します。

  STREAM    : ストリームに束縛される変数
  FILENAME  : ストリームを作成するファイル名
  OPTIONS   : キーワード引数。open へ渡せるものと同じ
  BODY      : 実行する本体

使用例：
  (with-open-file (fp (merge-pathnames "lisp/henmi/c++-kwd.txt" (si:system-root)))
    (let ((line nil))
      (while (setq line (read-line fp nil nil nil))
        (push line *kekka*))))
</description>
<seealso>with-open-stream</seealso>
<seealso>open</seealso>
<link></link>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>with-open-stream</title>
<type>Macro</type>
<arguments>with-open-stream (VAR STREAM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
局所変数をストリームに束縛して本体を評価し、ストリームを閉じます。

参考：
  connect の例を参照のこと
</description>
<seealso>with-open-file</seealso>
<seealso>connect</seealso>
<link></link>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>with-output-to-buffer</title>
<type>Macro</type>
<arguments>with-output-to-buffer (BUFFER &amp;optional POINT) &amp;rest BODY</arguments>
<package>editor</package>
<description>
標準出力を指定されたバッファにリダイレクトします。

  BUFFER : 出力するバッファ
  POINT  : 出力をするポイントを指定します。
           指定しない場合には、バッファの先頭から出力されます。
  BODY   : 実行するフォーム

使用例：
  ;;; *scratch*に書き出してみる。
  (with-output-to-buffer ((find-buffer "*scratch*"))
     (format t "foo~%")
     (format t "bar~%"))
</description>
<seealso>with-output-to-selected-buffer</seealso>
<seealso>with-output-to-temp-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-output-to-selected-buffer</title>
<type>Function</type>
<arguments>with-output-to-selected-buffer &amp;rest BODY</arguments>
<package>editor</package>
<description>
標準出力をカレントバッファにリダイレクトします。
ポイントがある位置から出力されます。
  
使用例：
  ;;; カレントバッファに書き出してみる。
  (with-output-to-selected-buffer
     (format t "foo~%")
     (format t "bar~%"))
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-output-to-string</title>
<type>Macro</type>
<arguments>with-output-to-string (VAR &amp;optional STRING) &amp;body BODY</arguments>
<package>lisp</package>
<description>
文字列を出力するストリームを作成します。

使用例：
  ;;; ストリームを使って文字列を出力してみる。
  (setq var
        (with-output-to-string (out)
          (prin1 "test" out)))
  =&gt; "test"
</description>
<seealso>make-string-output-stream</seealso>
<seealso>with-input-from-string</seealso>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>with-output-to-temp-buffer</title>
<type>Macro</type>
<arguments>with-output-to-temp-buffer (BUFNAME &amp;optional (POPUP t)) &amp;rest BODY</arguments>
<package>editor</package>
<description>
指定されたバッファを作成し、標準出力をそのバッファにリダイレクトします。
同じ名前のバッファがあった場合には、そのバッファの内容は破棄されます。
単に処理結果だけを書き込むような場合に便利です。

  BUFNAME : バッファの名前を指定します。
  POPUP   : バッファを分割表示する際の行数／列数を指定します。
        t       ニ分割します。
        整数    指定行数／列数で分割します。
        nil     バッファを分割表示しません。
  VERT-P  : バッファの分割方法を指定します。
            POPUP が nil の場合は意味を持ちません。
        non-nil 左右にバッファを分割します。
        nil     上下にバッファを分割します。

使用例：
  ;;; *Help*を作ってそこに書き出してみる。
  (with-output-to-temp-buffer ("*Help*")
     (format t "foo~%")
     (format t "bar~%"))

互換性：
   muleにもCommon Lispにもありません。
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-package-iterator</title>
<type>Macro</type>
<arguments>with-package-iterator (MNAME PACKAGE-LIST &amp;rest SYMBOL-TYPE) &amp;body BODY</arguments>
<package>lisp</package>
<description>
指定されたパッケージのシンボルを列挙する関数を作ってもらいます。
作られた関数を呼び出すたびにシンボルが列挙されます。

  MNAME        : シンボルを返す関数名を指定します。
  PACKAGE-LIST : パッケージのリストを指定します。
  SYMBOL-TYPE  : どんなシンボルを返すかを指定するようです。

使用例：
  ;;; 全シンボルを列挙します。
  ;;; 呼ぶたびに次のシンボルを返すfooという関数を定義してもらう。
  (with-package-iterator (foo (list-all-packages) :internal :external)
    (loop
      (multiple-value-bind (f sym type package)
          (foo)             ; 呼ぶと次のシンボルが返ってくる。
        (unless f           ; なければ終わり。
          (return))
        (and (or (boundp sym)
                 (fboundp sym))
             (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S ~S~%"
                     (boundp sym)
                     (fboundp sym)
                     (macro-function sym)
                     (package-name package)
                     sym
                     type)))))
</description>
<seealso>do-all-symbols</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>write-char</title>
<type>Function</type>
<arguments>write-char CHARACTER &amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAM に CHARACTER を出力し、その CHARACTER を返します。
</description>
<seealso>read-char</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write-region</title>
<type>Function</type>
<arguments>write-region FROM TO FILENAME &amp;optional APPEND CHAR-ENCODING EOL-CODE</arguments>
<package>editor</package>
<description>
リージョンをファイルに書き込みます。
APPEND が non nil なら追加書き込みをします。
</description>
<seealso></seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write-registry</title>
<type>Function</type>
<arguments>write-registry SECTION KEY VALUE</arguments>
<package>editor</package>
<description>
レジストリに書き込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  VALUE   : 値を指定します。

使用例：
  ;;; HKEY_CURRENT_USER\Software\Free Software\Xyzzy の下にデータを書き込む
  (write-registry "software\\chombo\\altime" "aaa" 64)

  以下のように書き込まれます。
-----
REGEDIT4

[HKEY_CURRENT_USER\Software\Free Software\Xyzzy\software\chombo\altime]
"aaa"=dword:00000040
-----
</description>
<seealso>read-registry</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write</title>
<type>Function</type>
<arguments>write OBJECT &amp;key :stream :escape :pretty :base :radix :circle :level :length :readably</arguments>
<package>lisp</package>
<description>
OBJECTを印字表現でストリームに出力します。

  OBJECT       : 出力するオブジェクトを指定します。

  :stream      : 出力するストリームを指定します。
                 省略すると*standard-output*に出力します。

  :escape      : エスケープするかどうか指定します。
                 デフォルトの値は*print-escape*です。
        non-nil  prin1やformat指定子の~Sと同じように出力されます。
        nil      princやformat指定子の~Aと同じように出力されます。

  :pretty      : 式の表示を見やすくするかどうかを指定します。
                 デフォルトの値は*print-pretty*です。
        non-nil  見やすくします。
        nil      見やすくしません。

  :base        : 基数を指定します。
                 2〜36までを指定でき、それ以外は10進数になります。
                 デフォルトの値は*print-base*です。

  :radix       : 基数を主力するかどうかを指定します。
                 デフォルトの値は*print-radix*です。
        non-nil  #(基数)r(数)の形で出力します。
                 10進数の時はこの形ではなく、最後に . が付きます。
                 2進数,8進数,16進数の基数はそれぞれ、b,o,xと表示され、
                 それ以外の時は基数自体は10進数で表示されます。
        nil      数のみ出力します。

  :circle      : 循環リストを考慮するかどうかを指定します。
                 デフォルトの値は*print-circle*です。
        non-nil  考慮し、#1=(a . #1#) のような形で表示します。
        nil      考慮しません。無限に表示されるのでC-gで止める必要があります。

  :level       : リスト出力の深さの制限を指定します。
                 制限よりも深い位置にあるリストは、#で表示されます。
                 デフォルトの値は*print-level*です。

  :length      : リスト出力の長さの制限を指定します。
                 制限よりも長いリストは途中で打ち切られ、
                 ... で表示されます。
                 デフォルトの値は*print-length*です。

  :readably    : 読めるように出力します。
                 デフォルトの値は*print-readably*です。
        non-nil  :lengthや:levelのnon-nil指定を無効にし、
                 :escapeがnilでもnon-nilを指定したように出力します。
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>wrong-disk-pathname</title>
<type>Function</type>
<arguments>wrong-disk-pathname X</arguments>
<package>lisp</package>
<description>
注）どこにもみつからない？
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>wrong-disk</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
注）どこにもみつからない？
</description>
<seealso>wrong-disk-pathname</seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>xyzzy-dumped-p</title>
<type>Function</type>
<arguments>xyzzy-dumped-p</arguments>
<package>editor</package>
<description>
起動時にxyzzyがダンプ済みかどうかを返します。

  t     ダンプ済み
  nil   ダンプ済みではない

ダンプ作業をしても再起動するまでは戻り値はtになりません。
</description>
<seealso>dump-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>xyzzyで提供されているストリームの種類</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
（途中）
以下はxyzzyで提供されているストリームの種類です。

  Commonと同じ
  ---------------------------------------------
  file-input-stream       open
  file-output-stream      open
  file-io-stream          open
  string-input-stream     make-string-input-stream
  string-output-stream    make-string-output-stream
  synonym-stream          make-synonym-stream
  broadcast-stream        make-broadcast-stream
  concatenated-stream     make-concatenated-stream
  echo-stream             make-echo-stream
  two-way-stream          make-two-way-stream
  ---------------------------------------------

synonym-stream以降は使ったことないんで(^^;、動くかどうか分からないんです
が多分動くでしょう(^^)。

  独自
  ---------------------------------------------
  buffer-stream           make-buffer-stream
  status-window-stream    なし
  keyboard-stream         なし
  wstreams-stream         なし
  ---------------------------------------------

独自ストリームの概要：
  buffer-stream
    バッファをストリームとみなして入出力どっちでもできます。  
  status-window-stream
    ステータスウィンドウをストリームとみなして出力ができます。
    グローバル変数*status-window*の値です。
  keyboard-stream
    キーボードをストリームとみなして入力ができます。
    グローバル変数*keyboard*の値です。
  wstreams-stream
    formatからコールバックが呼ばれたときのstreamの実体。
</description>
<seealso>open</seealso>
<seealso>make-string-input-stream</seealso>
<seealso>make-string-output-stream</seealso>
<seealso>make-synonym-stream</seealso>
<seealso>make-broadcast-stream</seealso>
<seealso>make-concatenated-stream</seealso>
<seealso>make-echo-stream</seealso>
<seealso>make-two-way-stream</seealso>
<seealso>make-buffer-stream</seealso>
<seealso>connect</seealso>
<seealso>stream-encoding</seealso>
<seealso>set-stream-encoding</seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>y-or-n-p</title>
<type>Function</type>
<arguments>y-or-n-p FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ミニバッファにメッセージを表示してユーザーが'y'か'n'を入力するのを待ちます。

  t     'y'を押下した
  nil   'n'を押下した

使用例：
  ;;; "Foo: (y or n) "と表示して選択させる。
  (y-or-n-p "Foo: ")
  =&gt; t          ; 'y'を押下
</description>
<seealso>yes-or-no-p</seealso>
<seealso>no-or-yes-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<section>ミニバッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>yank-and-pop</title>
<type>Function</type>
<arguments>yank-and-pop &amp;optional PREFIX (ARG 0)</arguments>
<package>editor</package>
<description>
*kill-ring*の先頭の要素をyankした後に、先頭の要素を*kill-ring*からpopします。
*kill-ring*は一要素分短くなります。
</description>
<seealso>yank-pop</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>yank-pop</title>
<type>Function</type>
<arguments>yank-pop &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次の要素をyankします。 [ESC y]
直前のコマンドがyankならば*kill-ring*のポインターをずらして、次の要素
でyankをし直します。
</description>
<seealso>yank</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>yank-rectangle-as-region</title>
<type>Function</type>
<arguments>yank-rectangle-as-region</arguments>
<package>editor</package>
<description>
copy-rectangleで切り取った矩形領域を、
連続した一連の文字列として挿入します。

  ABCDEFG ;
  HIJKLMN ; JKL
  OPQRSTU ; QRS
  VWXYZ   ; XYZの領域をcopy-rectangle

  (yank-rectangle)
  =&gt;JKL
    QRS
    XYZ

  (yank-rectangle-as-region)
  =&gt;JKLQRSXYZ
</description>
<seealso>yank-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>yank-rectangle-selection</title>
<type>Function</type>
<arguments>yank-rectangle-selection &amp;optional ARG</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をyankします。[S-F9]
実行後にどのようにyankするかを質問されます。
  F6    Cancel                  yank中止
  F7    Append                  行末に追加
  F8    Overwrite               上書き
  F9    Insert                  挿入
  F10   Insert as region        文字列にして挿入
</description>
<seealso>yank-rectangle</seealso>
<seealso>kill-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>yank-rectangle</title>
<type>Function</type>
<arguments>yank-rectangle</arguments>
<package>editor</package>
<description>
copy-rectangleやkill-rectangleによって選択された領域を矩形挿入します。
yank-rectangle-selectionのInsert相当の機能のようです。
</description>
<seealso>kill-rectangle</seealso>
<seealso>yank-rectangle-selection</seealso>
<seealso>yank-rectangle-as-region</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>yank-selection-and-pop</title>
<type>Function</type>
<arguments>yank-selection-and-pop &amp;optional (ARG 0)</arguments>
<package>editor</package>
<description>
*selection-ring*の先頭の要素をyank-selectionした後に、
先頭の要素を*selection-ring*からpopします。
*selection-ring*は一要素分短くなります。
</description>
<seealso>yank-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>yank-selection</title>
<type>Function</type>
<arguments>yank-selection &amp;optional (ARG 0)</arguments>
<package>editor</package>
<description>
*selection-ring*の先頭の要素を貼り付けます。[F9]
*selection-ring*へはcopy-selectionもしくはkill-selectionで追加します。
</description>
<seealso>kill-selection</seealso>
<seealso>copy-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>yank-to-clipboard</title>
<type>Function</type>
<arguments>yank-to-clipboard &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
*kill-ring*の内容をクリップボードに複写します。
</description>
<seealso>copy-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>yank</title>
<type>Function</type>
<arguments>yank &amp;optional PREFIX (ARG 0)</arguments>
<package>editor</package>
<description>
*kill-ring*の先頭の要素を挿入します。[C-y]
</description>
<seealso>*kill-ring*</seealso>
<seealso>yank-pop</seealso>
<seealso>yank-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>yes-no-or-cancel-p</title>
<type>Function</type>
<arguments>yes-no-or-cancel-p FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」「キャンセル」のボタン付メッセージボックスを表示します。
デフォルトは「はい」です。「キャンセル」を選択した場合には、quitが実行されます。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-no-or-cancel-p "foo")
  =&gt; t          ; 「はい」を選択
  (yes-no-or-cancel-p "foo")
  =&gt; nil        ; 「いいえ」を選択
</description>
<seealso>yes-or-no-p</seealso>
<seealso>no-or-yes-p</seealso>
<seealso>y-or-n-p</seealso>
<section>ダイアログ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>zap-to-char</title>
<type>Function</type>
<arguments>zap-to-char C &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
ポイントから指定されたキャラクタまでをkillします。[ESC z]
</description>
<seealso>kill-region</seealso>
<link></link>
<section>文字</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>yes-or-no-p</title>
<type>Function</type>
<arguments>yes-or-no-p FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」のボタン付メッセージボックスを表示します。デフォルトは
「はい」です。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は以下のとおりです。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-or-no-p "foo")
  =&gt; t          ; 「はい」を選択
  (yes-or-no-p "~A" "hogehoge")  
  =&gt; nil        ; 「いいえ」を選択
</description>
<seealso>no-or-yes-p</seealso>
<seealso>y-or-n-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<seealso>message-box</seealso>
<section>ダイアログ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>zerop</title>
<type>Function</type>
<arguments>zerop NUMBER</arguments>
<package>lisp</package>
<description>
NUMBERがゼロならt、そうでなければnilを返します。

使用例：  
  (zerop 0)
  =&gt; t
  (zerop 1)
  =&gt; nil
  (zerop 0.0)
  =&gt; t
  (zerop -0.00)
  =&gt; t
</description>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tail-f</title>
<type>Function</type>
<arguments>tail-f FILENAME</arguments>
<package>editor</package>
<description>
tail コマンドの -f オプションのように、更新され続けるようなファイルを終
端まで読み込み続けようとします。
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>tail-f.l</file>
</chapter>

<chapter>
<title>current-line-columns</title>
<type>Function</type>
<arguments>current-line-columns</arguments>
<package>editor</package>
<description>
現在の表示行の桁数を返します。
改行文字 (#\LFD) は 2 桁と扱われます。
</description>
<seealso>current-column</seealso>
<seealso>char-columns</seealso>
<seealso>goto-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-after</title>
<type>Function</type>
<arguments>char-after POINT &amp;optional NOT-USED</arguments>
<package>editor</package>
<description>
カレントバッファの POINT 位置の文字を返します。
(point-min)以下の値が指定された場合(point-min)の文字を返す。
(point-max)以上の値が指定された場合 #\NUL を返す。

  POINT    : INTEGER か MARKER でポイントを指定
  NOT-USED : 不使用

戻り値：
  文字

使用例：
  ;;; ポイント c の位置で ESC ESC (char-after (point)) した場合
  abcdefg
    ^ このポイントで ESC ESC (char-after (point)) =&gt; #\c
</description>
<seealso>following-char</seealso>
<seealso>char-before</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-before</title>
<type>Function</type>
<arguments>char-before POINT &amp;optional NOT-USED</arguments>
<package>editor</package>
<description>
カレントバッファの POINT の前の位置の文字を返します。
(point-max)以上の値が指定された場合(point-max)の前の位置の文字を返す。
(point-min)以下の値が指定された場合 #\NUL を返す。

  POINT    : INTEGER か MARKER でポイントを指定
  NOT-USED : 不使用

戻り値:
  文字

使用例：
  ;;; ポイント c の位置で ESC ESC (char-before (point)) した場合
  abcdefg
    ^ このポイントで ESC ESC (char-before (point)) =&gt; #\b
</description>
<seealso>char-after</seealso>
<seealso>preceding-char</seealso>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-code-limit</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
文字コードの限界値を定めている定数(65536)です。
*character-name-hash-table* を設定する
(make-character-name-hash-table) 関数の定義中でのみ使用されています。
xyzzy ソース内で定義されています。
</description>
<seealso>*character-name-hash-table*</seealso>
<seealso>make-character-name-hash-table</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>char-columns</title>
<type>Function</type>
<arguments>char-columns CHAR</arguments>
<package>editor</package>
<description>
文字 CHAR の文字幅を返します。

使用例：
  (char-columns #\a)        =&gt; 1
  (char-columns #\あ)       =&gt; 2
  (char-columns #\asterisk) =&gt; 1
  ;;; UNICODE 半角表示時
  (setq *unicode-to-half-width* t)   =&gt; t
  (char-columns (unicode-char 180))  =&gt; 1
  ;;; UNICODE 全角表示時
  (setq *unicode-to-half-width* nil) =&gt; nil
  (char-columns (unicode-char 180))  =&gt; 2
</description>
<seealso>count-column</seealso>
<seealso>current-line-columns</seealso>
<seealso>*unicode-to-half-width*</seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*unicode-to-half-width*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil なら、UNICODE 文字の表示に半角文字を使用します。
デフォルトでは t が xyzzy ソース内で設定されています。

使用例：
  ;;; 半角文字で表示
  (setq *unicode-to-half-width* t)   =&gt; t
  (unicode-char 180)                 =&gt; #\x0134
  ;;; 全角文字で表示
  (setq *unicode-to-half-width* nil) =&gt; nil
  (unicode-char 180)                 =&gt; #\´
</description>
<seealso>unicode-char</seealso>
<seealso>char-columns</seealso>
<link></link>
<section>文字</section>
<file></file>
</chapter>

<chapter>
<title>standard-char-p</title>
<type>Function</type>
<arguments>standard-char-p CHAR</arguments>
<package>lisp</package>
<description>
文字が、改行文字もしくは [ -~] かどうかを判定します。
表示可能な文字は SJIS 文字コードで 10, 32-126 です。

  CHAR : 判定する文字

戻り値：
  t   standard-char である
  nil standard-char でない

補足：
  ;;; 改行文字(SJIS 10) 以外の standard-char 文字一覧出力 (SJIS 32-126)
  (do ((i (char-code #\SPC) (1+ i)))
      ((= i (char-code #\DEL)))
    (format t "~A" (code-char i)))
</description>
<seealso>characterp</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count-column</title>
<type>Function</type>
<arguments>count-column STRING &amp;optional START BUFFER</arguments>
<package>editor</package>
<description>
文字列 STRING を出力した場合の出力後の桁位置を返します。
START と BUFFER はタブ文字の幅の計算に影響を与えます。

  STRING : 対象文字列
  START  : 出力開始とする桁位置
        nil      桁位置 0 からの出力
        INTEGER  桁位置 INTEGER からの出力 (0 未満の場合 range-error)
  BUFFER : 出力バッファ
        nil      タブ幅として (tab-column) の値を用います。
                 (tab-column (selected-buffer)) の値ではありません。
        BUFFER   タブ幅として (tab-column BUFFER) の値を用います。

戻り値：
  INTEGER   文字列 STRING 出力後の桁位置

補足：
  改行文字 "\n" は桁位置の初期化としては働かず、幅 2 として扱われます。
</description>
<seealso>char-columns</seealso>
<seealso>current-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*paste-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>system</package>
<description>
クリップボードから貼り付けるときに実行されます。
</description>
<seealso>paste-from-clipboard</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>ed::build-summary-function</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファ中の関数の一覧を取得します。行及び関数名を要素に持つリス
トで得られます。list-functionで使用されています。

使用例：
  ; listfn.lで評価
  (funcall ed::build-summary-function)
  =&gt; ((10 "lisp-build-summary-of-functions") (39 "lisp-maketags"))
</description>
<seealso>list-function</seealso>
<link></link>
<section>関数</section>
<file></file>
</chapter>

<chapter>
<title>get-window-start-line</title>
<type>Function</type>
<arguments>get-window-start-line &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウの先頭行が表示行で何行目かを返します。

補足：
  どういった場合に起こりえるのか不明ですが、ウィンドウにバッファが関連付
  いていない場合は nil を返します。
</description>
<seealso>current-virtual-line-number</seealso>
<seealso>current-line-number</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*brackets-is-wildcard-character*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
non-nil ならばファイルパスとして渡した文字列中の [...] をワイルドーカー
ドとして扱います。
[共通設定] - [さまざま] - [[...]はワイルドカード(I)] で値を指定すること
ができます。
xyzzy ソース内で定義されており、デフォルト値は t です。
具体的には、wild-pathname-p, pathname-match-p 関数での判定の際に
*brackets-is-wildcard-character* の値が考慮されます。
</description>
<seealso>wild-pathname-p</seealso>
<seealso>pathname-match-p</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>save-some-buffers</title>
<type>Function</type>
<arguments>save-some-buffers &amp;optional VERBOSE (FN #'WRITE-FILE)</arguments>
<package>editor</package>
<description>
開いているバッファを保存します。[C-x s]
  VERBOSE : non-nilの場合保存するファイルごとにダイアログを表示して確認します。
</description>
<seealso>save-all-buffers</seealso>
<seealso>save-buffers-kill-xyzzy</seealso>
<seealso>save-buffer</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>si:www-url-encode</title>
<type>Function</type>
<arguments>www-url-encode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM LITERAL-CHARS</arguments>
<package>system</package>
<description>
RFC1738 に基づき文字列の URL エンコードを行います。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力ストリームです。
                           t を指定した場合は標準出力へ出力します。
                           省略もしくは nil を指定すると戻り値になります。
  LITERAL-CHARS          : エンコードしない文字群を指定します。
     t                       すべての文字をエンコードする
     nil                     "-A-Za-z0-9$_.+!*'(|),"と同値

使用例:
  ; 標準では Shift_JIS としてエンコード
  (si:www-url-encode "かめ")
  =&gt;"%82%A9%82%DF"
  
  ; EUC-JP としてエンコード
  (si:www-url-encode (map-internal-to-euc "かめ"))
  =&gt;"%A4%AB%A4%E1"
  
  ; 変換しない文字群を明示する
  (si:www-url-encode "www-url-encode" nil "0-9A-Za-z")
  =&gt;"www%2Durl%2Dencode"

補足:
  RFC1738は現在RFC3986によって更新されています。
  RFC3986で定義されている unreserved な文字の種類は "0-9A-Za-z---._~" です。

  xyzzy 0.2.2.233 では builtin.l 中の引数の記述が間違っています。
  0.2.2.234 で修正されました。
</description>
<seealso>si:www-url-decode</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:www-url-decode</title>
<type>Function</type>
<arguments>www-url-decode INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>system</package>
<description>
URL デコードを行います。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力ストリームです。
                           t を指定した場合は標準出力へ出力します。
                           省略もしくは nil を指定すると戻り値になります。

使用例:
  (si:www-url-decode "%82%D9%82%B0%82%D9%82%B0" nil)
  =&gt;"ほげほげ"

補足:
  xyzzy 0.2.2.233 では builtin.l 中の引数の記述が間違っています。
  0.2.2.234 で修正されました。
</description>
<seealso>si:www-url-encode</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>up-list</title>
<type>Function</type>
<arguments>up-list &amp;optional ARG NO-ERRORS</arguments>
<package>editor</package>
<description>
カーソルを ARG 個外側の括弧の後ろに移します。

  (setq lst '(a b c)) ; ここから
               ^
  (setq lst '(a b c)) ; ここへ
                    ^

ARG が負の場合には、前の方の括弧へ移動します。

  (setq lst '(a b c)) ; ここから
               ^
  (setq lst '(a b c)) ; ここへ
             ^

外側に括弧が見つからなかった場合、
NO-ERRORS が nil の場合にはエラーを、 t の場合には nil を返します。
</description>
<seealso>forward-sexp</seealso>
<seealso>forward-list</seealso>
<seealso>down-list</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>down-list</title>
<type>Function</type>
<arguments>down-list &amp;optional ARG NO-ERRORS</arguments>
<package>editor</package>
<description>
カーソルを前方にある ARG 個内側の括弧の後ろに移します。[ESC C-d]

  (setq lst '(a b c)) ; ここから
       ^
  (setq lst '(a b c)) ; ここへ
              ^

前方に括弧が見つからなかった場合、
NO-ERRORS が nil の場合にはエラーを、 t の場合には nil を返します。
また、直近にある括弧しか見つけられないようです。

  (defun test () (setq lst '(a b c))) ; ここから ARG = 2 で down-list すると
     ^                                ; エラーになる
</description>
<seealso>backward-sexp</seealso>
<seealso>backward-list</seealso>
<seealso>up-list</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rest</title>
<type>Function</type>
<arguments>rest LIST</arguments>
<package>lisp</package>
<description>
cdrの別名です。 
全く同じ動きをします。 

使用例： 
  ;;; cdrと同じ動きをする。 
  (cdr '(1 2 3))
  =&gt; (2 3)
  (rest '(1 2 3))
  =&gt; (2 3)
  (symbol-function 'cdr)
  =&gt; #&lt;function: cdr&gt;
  (symbol-function 'rest)
  =&gt; #&lt;function: cdr&gt;
 
参考： 
  ;;; evalmacs.lの定義
  (si:*fset 'rest #'cdr)
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>get-image-size</title>
<type>Function</type>
<arguments>get-image-size FILENAME</arguments>
<package>editor</package>
<description>
指定された画像ファイルの縦・横・フォーマットを取得することが可能です。

使用例：
  ;;; imageタグを挿入してみる
  (require "imagehdr")
  (defun html-write-image-tag (file)
    (interactive "fJPEG, GIF, PNG : ")
    (multiple-value-bind (width height fmt)
      (get-image-size file)
      (insert (format nil "&lt;IMG SRC=\"~a\" WIDTH=~d HEIGHT=~d&gt;" file width height))))
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>imagehdr.l</file>
</chapter>

<chapter>
<title>compile-file-pathname</title>
<type>Function</type>
<arguments>compile-file-pathname PATHNAME</arguments>
<package>lisp</package>
<description>
xyzzy でバイトコンパイルした時の出力ファイル名を返します。
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-list</title>
<type>Function</type>
<arguments>forward-list &amp;optional ARG NO-ERRORS</arguments>
<package>editor</package>
<description>
前方のリストの終端へ移動します。[ESC C-n]
  
  使用例:
    ;;; forward-list で移動する
    ;;; 
    ;;; ^ でポイント位置を表す
    (let ((hoge '(1 2))) (foo hoge) ...)
      ^ 最初はこの位置
    (let ((hoge '(1 2))) (foo hoge) ...)
                        ^ 一回
    (let ((hoge '(1 2))) (foo hoge) ...)
                              二回 ^
</description>
<seealso>forward-sexp</seealso>
<seealso>up-list</seealso>
<seealso>backward-list</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-virtual-line</title>
<type>Function</type>
<arguments>forward-virtual-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
表示行で次行へ移動します。
</description>
<seealso>forward-line</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>next-window</title>
<type>Function</type>
<arguments>next-window WINDOW &amp;optional MINIBUF</arguments>
<package>editor</package>
<description>
WINDOW の次のウィンドウを返します。

  MINIBUF : ミニバッファウィンドウを候補に入れるか
       nil    無視する
   non-nil    候補に入れる
</description>
<seealso>previous-window</seealso>
<seealso>set-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>previous-window</title>
<type>Function</type>
<arguments>previous-window WINDOW &amp;optional MINIBUF</arguments>
<package>editor</package>
<description>
WINDOW の前のウィンドウを返します。
  
  MINIBUF : ミニバッファウィンドウを候補に入れるか
       nil    無視する
   non-nil    候補に入れる
</description>
<seealso>next-window</seealso>
<seealso>set-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rational</title>
<type>Function</type>
<arguments>rational NUMBER</arguments>
<package>lisp</package>
<description>
実数を有理数に変換します。もしも、 NUMBER がすでに有理数だったら、そのま
ま返します。 rational の場合は、浮動小数点数を全く誤差を含まないものとし
て扱い、その浮動小数点数を数学的に有理数化します。
  
  ;;; 0.5 は2進数でちょうど表せる
  (rational 0.5)
  =&gt;1/2
  ;;; 0.1 は2進数では誤差を含む
  (rational 0.1)
  =&gt;13421773/134217728
  ;;; 倍精度だとまた違う
  (rational 0.1d0)
  =&gt;3602879701896397/36028797018963968
</description>
<seealso>rationalize</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rationalize</title>
<type>Function</type>
<arguments>rationalize NUMBER</arguments>
<package>lisp</package>
<description>
実数を有理数に変換します。もしも、 NUMBER がすでに有理数だったら、そのま
ま返します。 rationalize の場合は、浮動小数点数を表示される範囲までの精
度で扱い、近似して有理数化します。
</description>
<seealso>rational</seealso>
<seealso>float</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>screen-width</title>
<type>Function</type>
<arguments>screen-width</arguments>
<package>editor</package>
<description>
xyzzyのウィンドウ全体の幅が何桁になるのかを返します。
</description>
<seealso>screen-height</seealso>
<seealso>window-width</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>scroll-window-horizontally</title>
<type>Function</type>
<arguments>scroll-window-horizontally ARG</arguments>
<package>editor</package>
<description>
ウィンドウを指定桁数分、右にスクロールします。
負の数値を指定すると逆方向にスクロールします。
</description>
<seealso>scroll-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sinh</title>
<type>Function</type>
<arguments>sinh Z</arguments>
<package>lisp</package>
<description>
双曲線正弦関数を計算します。 
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>tanh</title>
<type>Function</type>
<arguments>tanh Z</arguments>
<package>lisp</package>
<description>
双曲線正接関数を計算します。 
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>selection-whole-buffer</title>
<type>Function</type>
<arguments>selection-whole-buffer</arguments>
<package>editor</package>
<description>
バッファ全体をセレクションにします。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-start-end</title>
<type>Macro</type>
<arguments>selection-start-end (START END) &amp;body BODY</arguments>
<package>editor</package>
<description>
セレクションの開始位置、終了位置を取得します。
セレクションが存在すれば、
局所的にSTARTに開始位置、ENDに終了位置をセットされた環境を作り
BODYを順次評価します。

使用例:
  ;;; セレクションに含まれる文字列を返します。
  (selection-start-end (start end)
    (buffer-substring start end))
  =&gt;"foo"
</description>
<seealso>ed::get-selection-start-end</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-end-of-virtual-line</title>
<type>Function</type>
<arguments>selection-end-of-virtual-line</arguments>
<package>editor</package>
<description>
表示行の末尾までをセレクションにします。
</description>
<seealso>end-of-virtual-line</seealso>
<seealso>selection-beginning-of-virtual-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-end-of-line</title>
<type>Function</type>
<arguments>selection-end-of-line</arguments>
<package>editor</package>
<description>
行末までをセレクションにします。
</description>
<seealso>selection-beginning-of-line</seealso>
<seealso>end-of-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-end-of-buffer</title>
<type>Function</type>
<arguments>selection-end-of-buffer</arguments>
<package>editor</package>
<description>
バッファの最後までをセレクションにします。
end-of-bufferと違いマーク自体は変化しません。
</description>
<seealso>end-of-buffer</seealso>
<seealso>selection-beginning-of-buffer</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-beginning-of-virtual-line</title>
<type>Function</type>
<arguments>selection-beginning-of-virtual-line</arguments>
<package>editor</package>
<description>
表示行の先頭までをセレクションにします。
</description>
<seealso>beginning-of-virtual-line</seealso>
<seealso>selection-end-of-virtual-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-beginning-of-line</title>
<type>Function</type>
<arguments>selection-beginning-of-line</arguments>
<package>editor</package>
<description>
行頭までをセレクションにします。
</description>
<seealso>beginning-of-line</seealso>
<seealso>selection-end-of-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-beginning-of-buffer</title>
<type>Function</type>
<arguments>selection-beginning-of-buffer</arguments>
<package>editor</package>
<description>
カーソル位置からバッファの先頭までをセレクションにします。
beginning-of-bufferと違いマーク自体は変化しません。
</description>
<seealso>beginning-of-buffer</seealso>
<seealso>selection-end-of-buffer</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>*char-encoding-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
文字エンコーディングのリストです。ミニバッファからの入力補完候補のリスト
や file-name-dialog のエンコーディングのリストとして使われたりするみたい
です。
文字エンコーディングはクオートしてはいけないみたいですので、定義しなおす
時は注意してください。
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*keyboard*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
キーボードからの入力を表すストリームです。
</description>
<seealso>*standard-input*</seealso>
<link></link>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>*print-circle*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
循環リストの表示を省略形にします

標準はnilです。read-eval-printのループでの
表示は常にtのようです。

(setq *print-circle* nil) =&gt; nil
(setq x (list 'a))        =&gt; (a)
(setf (cdr x) x)          =&gt; #1=(a . #1#)
(princ x)
=&gt; (a a a ...
;;無限に続くのでC-gで終了
(setq *print-circle* t)   =&gt; t
(princ x)
#1=(a . #1#)
=&gt; #1=(a . #1#)
</description>
<seealso>*print-length*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*print-length*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
長いリストの表示を途中で打ち切ります。

(setq *print-length* nil) =&gt; nil
(princ '(a b c d e f g h i j))
=&gt;(a b c d e f g h i j)

(setq *print-length* 5)   =&gt; 5
(princ '(a b c d e f g h i j))
=&gt;(a b c d e ...)
</description>
<seealso>*print-circle*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*print-pretty*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
式の表示を見やすくします。

標準はtです。

(flet ((f (x) (princ x) (terpri)))
  (let ((*print-pretty* t))
    (f '('a #'b))  ;;tの時の表示
    (setq *print-pretty* nil)
    (f '('a #'b))));;nilの時の表示
=&gt; ('a #'b)
   ((quote a) (function b))
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*random-state*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
現在の乱数の状態を保持してます。
random が STATE 無しで呼ばれたとき使われます。
</description>
<seealso>random</seealso>
<seealso>make-random-state</seealso>
<link></link>
<section>数値</section>
<file></file>
</chapter>

<chapter>
<title>*standard-input*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
標準入力を表すストリームです。
普段はキーボードからの入力になっています。
</description>
<seealso>*standard-output*</seealso>
<seealso>*keyboard*</seealso>
<link></link>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>delete-command-bar</title>
<type>Function</type>
<arguments>delete-command-bar SYM</arguments>
<package>editor</package>
<description>
ツールバーを削除します。
</description>
<seealso>define-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>delete-hook</title>
<type>Function</type>
<arguments>delete-hook HOOK FN</arguments>
<package>editor</package>
<description>
フック変数から関数を削除します。

  HOOK : フック変数のシンボルを指定します。
  FN   : 関数のシンボルを指定します。
</description>
<seealso>add-hook</seealso>
<link></link>
<section>モード</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>display-rest-tab-char</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
タブの表示に使用する文字を設定します。
詳しくは display-first-tab-char を参照してください。
</description>
<seealso>display-first-tab-char</seealso>
<link></link>
<section>文字</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>ed::*last-search-regexp*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
前回の正規表現検索パターンが保存されています。
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>ed::*last-search-string*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
前回の検索語が保存されています。
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>eval-buffer</title>
<type>Function</type>
<arguments>eval-buffer BUFFER</arguments>
<package>editor</package>
<description>
バッファ全体を評価します。
eval-region を使って実装されています。
</description>
<seealso>eval-region</seealso>
<link></link>
<section>評価</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>make-random-state</title>
<type>Function</type>
<arguments>make-random-state &amp;optional STATE</arguments>
<package>lisp</package>
<description>
乱数の状態を初期化します

  STATE:
    nil          初期化はせずに現在の*random-state*のコピーを返します。
    t            時刻に基づいて新しい状態を作ります。
    random-state この関数(make-random-state)の戻り値を渡すとコピーが返ります。

使用例:
 ;;;乱数列の再現
 (let ((rs1 (make-random-state nil))
       (rs2 (make-random-state nil)))   ;;現状の乱数状態のコピーを二つ作る
   (dotimes (i 10)
     (format t "~A " (random 100 rs1))) ;;一つ目
   (terpri)
   (dotimes (i 10)
     (format t "~A " (random 100 rs1))) ;;一つ目やりすぎて
   (terpri)
   (dotimes (i 10)
     (format t "~A " (random 100 rs2))) ;;二つ目を少し見てみる。
   (terpri))
 =&gt;3 41 81 70 73 66 32 72 2 55   ;ここと
   21 97 83 14 86 26 99 69 18 46 
   3 41 81 70 73 66 32 72 2 55   ;ここが同じになる
</description>
<seealso>*random-state*</seealso>
<seealso>random-state-p</seealso>
<seealso>random</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>re-search-backward-again</title>
<type>Function</type>
<arguments>re-search-backward-again</arguments>
<package>editor</package>
<description>
前回の正規表現検索パターンで後方検索します。
</description>
<seealso>ed::*last-search-regexp*</seealso>
<seealso>re-search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>re-search-forward-again</title>
<type>Function</type>
<arguments>re-search-forward-again</arguments>
<package>editor</package>
<description>
前回の正規表現検索パターンで前方検索します。
</description>
<seealso>ed::*last-search-regexp*</seealso>
<seealso>re-search-backward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>read-buffer-name</title>
<type>Function</type>
<arguments>read-buffer-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがバッファ名を入力するのを待ち
ます。ユーザーの入力したバッファを返します。入力したバッファが存在しない
場合は、文字列をそのまま返します。
(interactive "B") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例:
  ;;; ミニバッファからバッファ名を読み込む
  (read-buffer-name "Buffer: ")   ; ←*scratch* と入力
  =&gt;#&lt;buffer: *scratch*&gt;
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-char-encoding</title>
<type>Function</type>
<arguments>read-char-encoding PROMPT &amp;key :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが文字エンコーディングを入力す
るのを待ちます。ユーザーの入力した文字エンコーディングを返します。補完の
リストは *char-encoding-list* を参照しているようです。
(interactive "z") に相当します。

  PROMPT     : プロンプト
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します

使用例:
  ;;; ミニバッファから文字エンコーディングを読み込む
  (read-char-encoding "Encoding: ") ; ←utf8n と入力
  =&gt;#.(make-utf8-encoding "utf8n" "Unicode (UTF-8N)" :signature nil :windows t :byte-order nil :cjk :jp)
</description>
<seealso>read-exact-char-encoding</seealso>
<seealso>*char-encoding-list*</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-command-name</title>
<type>Function</type>
<arguments>read-command-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがコマンドを入力するのを待ちま
す。ユーザーの入力したコマンドのシンボルを返します。<!-- 多値で返ってくるけど二つめは説明する自信が無いので省略 -->
(「コマンド」は「interactive宣言された関数」の意味で使ってます)
(interactive "C") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-exact-char-encoding</title>
<type>Function</type>
<arguments>read-exact-char-encoding PROMPT &amp;key :history</arguments>
<package>editor</package>
<description>
read-char-encodingとほぼ同じですが、自動判定が候補から除外されます。
(interactive "Z") に相当します。
</description>
<seealso>read-char-encoding</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-exist-buffer-name</title>
<type>Function</type>
<arguments>read-exist-buffer-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
read-buffer-name とほとんど同じですが、 read-exist-buffer-name はすでに
存在するバッファ名しか指定できません。
(interactive "b") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>read-buffer-name</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-exist-file-name</title>
<type>Function</type>
<arguments>read-exist-file-name PROMPT &amp;key :default :title :history</arguments>
<package>editor</package>
<description>
read-file-name とほとんど同じですが、 read-exist-file-name はすでに存在
しているファイルしか指定できません。
(interactive "f") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>read-file-name</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-file-name-list</title>
<type>Function</type>
<arguments>read-file-name-list PROMPT &amp;key :default :title :history</arguments>
<package>editor</package>
<description>
read-file-name とほとんど同じですが、 read-file-name-list は複数のファイ
ルを指定できます。複数のファイルを指定した場合は、そのリストを返します。
(interactive "l") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :title     : 一画面ファイラのタイトル
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>read-file-name</seealso>
<seealso>interactive</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-function-name</title>
<type>Function</type>
<arguments>read-function-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが関数名を入力するのを待ちます。
ユーザーの入力した関数のシンボルを返します。<!-- 多値で返ってくるけど二つめは説明する自信が無いので省略 -->
(interactive "a") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-symbol-name</title>
<type>Function</type>
<arguments>read-symbol-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがシンボルを入力するのを待ちます。
ユーザーの入力したシンボルを返します。<!-- 多値で返ってくるけど二つめは説明する自信が無いので省略 -->
(interactive "S") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-variable-name</title>
<type>Function</type>
<arguments>read-variable-name PROMPT &amp;key :default :history</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが変数を入力するのを待ちます。
ユーザーの入力した変数のシンボルを返します。<!-- 多値で返ってくるけど二つめは説明する自信が無いので省略 -->
(interactive "v") に相当します。

  PROMPT     : プロンプト
  :default   : 初期値とする文字列
  :history   : 履歴情報
               minibuffer-history-variableプロパティを持つシンボルを指定します
</description>
<seealso>interactive</seealso>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>search-backward-again</title>
<type>Function</type>
<arguments>search-backward-again</arguments>
<package>editor</package>
<description>
前回の検索語で後方検索します。
</description>
<seealso>ed::*last-search-string*</seealso>
<seealso>search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>search-forward-again</title>
<type>Function</type>
<arguments>search-forward-again</arguments>
<package>editor</package>
<description>
前回の検索語で前方検索します。
</description>
<seealso>ed::*last-search-string*</seealso>
<seealso>search-backward-again</seealso>
<seealso>*wrap-search*</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>with-input-from-string</title>
<type>Macro</type>
<arguments>with-input-from-string (VAR STRING &amp;key :index :start :end) &amp;body BODY</arguments>
<package>lisp</package>
<description>
文字列を標準入力にして読み込みます。
</description>
<seealso>make-string-input-stream</seealso>
<seealso>with-output-to-string</seealso>
<link></link>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>mouse-menu-popup</title>
<type>Function</type>
<arguments>mouse-menu-popup &amp;optional APPS</arguments>
<package>editor</package>
<description>
ポップアップメニューを表示します。[RBtnUp]

  APPS  : メニューの表示位置を指定します。
     nil      マウスカーソル位置
     non-nil  カーソル位置
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>mouse.l</file>
</chapter>

<chapter>
<title>dabbrev-expand</title>
<type>Function</type>
<arguments>dabbrev-expand &amp;optional ARG</arguments>
<package>editor</package>
<description>
動的略称展開により候補を順番に表示します。[C-x /]
</description>
<seealso>dabbrev-popup</seealso>
<link></link>
<section>テキスト</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>expand-abbrev</title>
<type>Function</type>
<arguments>expand-abbrev</arguments>
<package>editor</package>
<description>
カーソル位置で静的略称展開を行います。[C-x ']
abbrev-mode の時は self-insert-command でも実行されます。
</description>
<seealso>abbrev-mode</seealso>
<link></link>
<section>テキスト</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>auto-fill-mode</title>
<type>Function</type>
<arguments>auto-fill-mode &amp;optional (ARG () SARG)</arguments>
<package>editor</package>
<description>
自動詰め込みモードの開始と終了をトグルします。
</description>
<seealso>fill-column</seealso>
<seealso>auto-fill-hook</seealso>
<link></link>
<section>テキスト</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>*detect-char-encoding-mode*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
detect-char-encoding での文字エンコーディングの判別方法を設定します。

  :xyzzy    : xyzzy オリジナルの判別方法を利用します。
              Shift_JIS や半角カタカナに強いですが、
              EUC-JP や UTF-8 では誤判定することが多いです。

  :libguess : libguess (Gauche) の判別方法を利用します。
              Shift_JIS や半角カタカナの判別では
              xyzzy オリジナルの判別方法より劣りますが、
              全体的に誤判定は少ないです。

備考：
  guess-char-encoding はこの変数の影響は受けません。
  常に libguess を利用した判別結果を返します。
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>detect-char-encoding</seealso>
<seealso>*detect-char-encoding-buffer-size*</seealso>
<link></link>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>*detect-char-encoding-buffer-size*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイルオープン時の文字エンコーディングの判別に利用するバッファサイズを
指定します。

ファイルの先頭から指定サイズ分を読み込んで、文字エンコーディングを
判別します。

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>detect-char-encoding</seealso>
<seealso>*detect-char-encoding-mode*</seealso>
<link></link>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>detect-char-encoding</title>
<type>Function</type>
<arguments>detect-char-encoding STRING-OR-STREAM</arguments>
<package>editor</package>
<description>
STRING-OR-STREAM の文字エンコーディングを判定します。
</description>
<seealso>set-stream-encoding</seealso>
<seealso>stream-encoding</seealso>
<seealso>convert-encoding-from-internal</seealso>
<seealso>convert-encoding-to-internal</seealso>
<seealso>guess-char-encoding</seealso>
<seealso>*detect-char-encoding-mode*</seealso>
<seealso>*detect-char-encoding-buffer-size*</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>guess-char-encoding</title>
<type>Function</type>
<arguments>guess-char-encoding STRING-OR-STREAM</arguments>
<package>editor</package>
<description>
STRING-OR-STREAM の文字エンコーディングを判定して、文字エンコーディングの
候補とスコアを返します。

例:
  (guess-char-encoding (convert-encoding-from-internal *encoding-utf8n* "スレ違い"))
  =&gt; ((#.(make-utf8-encoding "utf8n" "Unicode (UTF-8N)" :signature nil :windows t :byte-order nil :cjk :jp) . 1.0d0)
      (#.(make-sjis-encoding "sjis" "日本語(Shift_JIS)") . 0.6400000000000001d0))

備考：
  xyzzy 0.2.2.238 から利用可能です。
</description>
<seealso>detect-char-encoding</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>map-char-encoding-region</title>
<type>Function</type>
<arguments>map-char-encoding-region P1 P2 &amp;optional ENCODING</arguments>
<package>editor</package>
<description>
リージョンの文字列データを文字エンコーディングが ENCODING のデータとして、
xyzzy内部コードへ変換します。
ENCODING が指定されない時は自動判定します。
</description>
<seealso>detect-char-encoding</seealso>
<seealso>map-char-encoding-selection</seealso>
<seealso>parse-char-encoding-region</seealso>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>*lisp-popup-completion-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
lisp-complete-symbol 時の補完候補をポップアップ表示するかを設定します。 

動作:
  *lisp-popup-completion-list*
    :always   ポップアップ表示
    :never    *Completion*バッファで表示

    *popup-completion-list-default*
      :always ポップアップ表示
      :never  *Completion*バッファで表示

    non-nil   ポップアップ表示
    nil       *Completion*バッファで表示
</description>
<seealso>lisp-complete-symbol</seealso>
<seealso>*popup-completion-list-default*</seealso>
<link></link>
<section>変数と定数</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>*gmark-keep-column*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil なら、global-mark-goto と back-tag-jump の移動の時に行頭へ移動し
ないようになります。
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>gmark.l</file>
</chapter>

<chapter>
<title>*print-option-show-dialog*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
nilの場合は、コマンドラインオプションで -p を指定した時、印刷ダイアログ
を表示しません。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*minor-mode-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
マイナモードがオンのときにモードラインに表示する文字列の連想リストです。
各要素の car はシンボル、 cdr は文字列かシンボルです。

car に指定したシンボルの値が non-nil であって、 cdr が文字列かまたは値が
文字列であるようなシンボルならば、その文字列がモードラインに表示されます。

使用例：
  (pushnew '(edict-mode . "Edict") *minor-mode-alist* :key #'car)

  (pushnew '(async-grep-mode . async-grep-status)
           *minor-mode-alist* :key #'car)
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>coerce</title>
<type>Function</type>
<arguments>coerce OBJECT TYPE</arguments>
<package>lisp</package>
<description>
OBJECT を TYPE 型に変換します。

TYPE はシンボルまたはリストで、それぞれ以下の型に変換されます。
  'list         ──→ リスト
  'array        ─┬→ 配列
  'simple-array ─┘
  'character    ──→ 文字
  'float        ─┬→ 単精度浮動小数点数
  'short-float  ─┤
  'single-float ─┘
  'double-float ─┬→ 倍精度浮動小数点数
  'long-float   ─┘
  'complex      ──→ 複素数
  'function     ──→ 関数
リストの場合、その最初の要素で型が決まります。
2番目以降の要素は、最初の要素が array、simple-array、complex の場合のみ
意味を持ち、それぞれ以下のように動作します。
  '(array ...)        ─┬→ make-sequence の TYPE と同じ
  '(simple-array ...) ─┘
  '(complex ...)      ──→ 実部、虚部を二番目の要素の型に変換
  
使用例:
  (coerce "abc" 'list)                         ; 文字列を文字のリストに
  =&gt; (#\a #\b #\c)
  (coerce #(1 2 3) 'list)                      ; 配列をリストに
  =&gt; (1 2 3)
  (coerce '(a b c) '(array t 1))               ; リストを配列に
  =&gt; #(a b c)
  (coerce "abc" '(array t 1))                  ; 文字列を文字の配列に
  =&gt; #(#\a #\b #\c)
  (coerce '(#\a #\b #\c) '(array character 1)) ; 文字のリストを文字列に
  =&gt; "abc"
  (coerce "abc" '(array character 1))          ; 意味なし
  =&gt; "abc"

  (coerce "a" 'character)                      ; 文字列を文字に
  =&gt; #\a
  
  (coerce 1 'float)
  =&gt; 1.0
  (coerce 1 'double-float)
  =&gt; 1.0d0
  (coerce 1.0 'complex)
  =&gt; #C(1.0 0.0)
  (coerce #C(1 2) '(complex float))            ; 単精度の複素数に
  =&gt; #C(1.0 2.0)
  
  (coerce 'let 'function)                      ; シンボル名の関数を返す
  =&gt; #&lt;function: let&gt;
  (coerce '(lambda (x) (* x 2)) 'function)     ; 関数を作ることも
  =&gt; #&lt;lexical-closure: (anonymous)&gt;
  (funcall (coerce '(lambda (x) (* x 2)) 'function) 12)
  =&gt; 24
</description>
<seealso>type-of</seealso>
<link></link>
<section>データ型</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>map</title>
<type>Function</type>
<arguments>map RESULT-TYPE FUNCTION SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCE に FUNCTION を適用して、RESULT-TYPE に応じたシーケンスを返します。
mapcar との違いは、リストだけでなく文字列や配列等のシーケンスにも適用できる
ことと、RESULT-TYPE の指定が必要なことです。

  RESULT-TYPE : nil、又は make-sequence の TYPE と同じものが使えます。
                nil の場合 戻り値は常に nil で、通常 副作用を目的として
                使用されます。
  FUNCTION    : mapcar と同様、SEQUENCE の各要素をひとつずつ取り出したも
                のとなります。 MORE-SEQUENCES がある場合もやはり mapcar 
                と同じように適用されます。

使用例:
  ;;; 文字列の場合は一つ一つの要素が string ではなく char になることに注意
  (map 'list #'char-code "abc")
  =&gt; (97 98 99)
</description>
<seealso>map-into</seealso>
<seealso>make-sequence</seealso>
<seealso>mapcar</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>map-into</title>
<type>Function</type>
<arguments>map-into RESULT-SEQUENCE FUNCTION &amp;rest SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCES に map と同じように FUNCTION を適用し、その結果を 
RESULT-SEQUENCE に埋め込みます。RESULT-SEQUENCE が一番短い SEQUENCE より
も長い場合には RESULT-SEQUENCE の後部の余った要素は変化しません。
  
使用例:
  (map-into "abcde" #'char-upcase "fgh")
  =&gt; "FGHde"
  (map-into '(1 2 3) #'- '(4 5 6 7 8))
  =&gt; (-4 -5 -6)
</description>
<seealso>map</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>lambda-parameters-limit</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
lambdaに与えることのできる引数の個数の限界値

参照例： 
  lambda-parameters-limit
  =&gt; 536870911
</description>
<seealso>call-arguments-limit</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>call-arguments-limit</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
関数に与えることのできる引数の個数の限界値

参照例： 
  call-arguments-limit
  =&gt; 536870911
</description>
<seealso>lambda-parameters-limit</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*load-pathname*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
現在読み込み中のファイル名（もしくはストリーム名）が入ります。

load-file内でバインドされます。
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>featurep</title>
<type>Function</type>
<arguments>featurep FEATURE</arguments>
<package>lisp</package>
<description>
FEATURE が *features* の要素であればそれ以降のリストを返します。
そうでなければ nil を返します。

使用例：
 ;;; process.l より
 (let ((shell (if (featurep :windows-nt) "cmd.exe" "command.com")))
   (defvar *shell* shell)
   (defvar *eshell* shell))
</description>
<seealso>*features*</seealso>
<link></link>
<section>システム</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>*features*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
実装の特徴を表すキーワードをリストとして格納しています。
#+ と #- の評価に影響します。

候補：
  :xyzzy
  :ieee-floating-point
  :win32s
  :windows-95
  :windows-98
  :windows-me
  :windows-nt
  :windows-2000
  :windows-xp
  :windows-vista
  :windows-7
  :windows-8
  :x86
  :x64
  :ia64
  :wow64

使用例：
  (+ 2 #+xyzzy 3 #+foo 4)
  =&gt; 5
  (push :foo *features*)
  =&gt; (:foo :wow64 :x64 :windows-7 :windows-vista :windows-xp :windows-2000 :windows-nt :xyzzy :ieee-floating-point)
  (+ 2 #+xyzzy 3 #+foo 4)
  =&gt; 9
  (pop *features*)
  =&gt; :foo
  (+ 2 #+xyzzy 3 #+foo 4)
  =&gt; 5

備考：
  以下の値は xyzzy 0.2.2.236 から利用可能です。
  :windows-vista
  :windows-7
  :windows-8
  :x86
  :x64
  :ia64
  :wow64
</description>
<seealso>featurep</seealso>
<link></link>
<section>システム</section>
<file></file>
</chapter>

<chapter>
<title>*gensym-counter*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
gensym で作られるシンボルの名前につく数字です。
使われるたびにインクリメントされます。
</description>
<seealso>gensym</seealso>
<link></link>
<section>シンボル</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>gensym</title>
<type>Function</type>
<arguments>gensym &amp;optional X</arguments>
<package>lisp</package>
<description>
uninterned なシンボルを生成します。印字名は G の後に *gensym-counter* の
値をつなげたものです。

引数 X を指定すると、
  X が整数のときは *gensym-counter* の代わりに X の値が使われます。
  X が文字列のときは "G" の代わりに X の値が使われます。
</description>
<seealso>*gensym-counter*</seealso>
<seealso>make-symbol</seealso>
<seealso>unintern</seealso>
<seealso>uninterned</seealso>
<link></link>
<section>シンボル</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>copy-rectangle-to-register</title>
<type>Function</type>
<arguments>copy-rectangle-to-register R START END &amp;optional DELETE</arguments>
<package>editor</package>
<description>
START と END で指定される矩形領域をレジスタ R へコピーします。[C-x r r]
DELETE が non-nil ならば同時に領域を削除します。
コピーした矩形領域の yank には、 insert-register を使います。 
</description>
<seealso>copy-rectangle</seealso>
<seealso>kill-rectangle</seealso>
<seealso>insert-register</seealso>
<link></link>
<section>リージョン</section>
<file>register.l</file>
</chapter>

<chapter>
<title>string-rectangle-selection</title>
<type>Function</type>
<arguments>string-rectangle-selection STRING</arguments>
<package>editor</package>
<description>
矩形選択されたセレクションの各行を文字列 STRING で置き換えます。
</description>
<seealso>string-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>string-rectangle</title>
<type>Function</type>
<arguments>string-rectangle P1 P2 STRING</arguments>
<package>editor</package>
<description>
P1 と P2 で指定される矩形領域の各行を文字列 STRING で置き換えます。
</description>
<seealso>string-rectangle-selection</seealso>
<seealso>operate-on-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>delete-rectangle-selection</title>
<type>Function</type>
<arguments>delete-rectangle-selection</arguments>
<package>editor</package>
<description>
矩形選択されたセレクションの領域を削除します。
</description>
<seealso>kill-rectangle-selection</seealso>
<seealso>delete-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>delete-rectangle</title>
<type>Function</type>
<arguments>delete-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1 と P2 で指定される矩形領域を削除します。
</description>
<seealso>kill-rectangle</seealso>
<seealso>delete-rectangle-selection</seealso>
<seealso>operate-on-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>open-rectangle-selection</title>
<type>Function</type>
<arguments>open-rectangle-selection</arguments>
<package>editor</package>
<description>
矩形選択されたセレクションの領域に #\SPC を挿入します。
</description>
<seealso>clear-rectangle-selection</seealso>
<seealso>open-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>open-rectangle</title>
<type>Function</type>
<arguments>open-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1 と P2 で指定される矩形領域に #\SPC を挿入します。
</description>
<seealso>clear-rectangle</seealso>
<seealso>open-rectangle-selection</seealso>
<seealso>operate-on-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>clear-rectangle-selection</title>
<type>Function</type>
<arguments>clear-rectangle-selection</arguments>
<package>editor</package>
<description>
矩形選択されたセレクションの領域を #\SPC で上書きします。
</description>
<seealso>open-rectangle-selection</seealso>
<seealso>clear-rectangle</seealso>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>clear-rectangle</title>
<type>Function</type>
<arguments>clear-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1 と P2 で指定される矩形領域を #\SPC で上書きします。
</description>
<seealso>open-rectangle</seealso>
<seealso>clear-rectangle-selection</seealso>
<seealso>operate-on-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>operate-on-rectangle-selection</title>
<type>Function</type>
<arguments>operate-on-rectangle-selection &amp;key :copy :delete :clear :open :string</arguments>
<package>editor</package>
<description>
矩形選択されたセレクションの領域に対してキーワードで指定された操作を行
います。

  :copy     コピーする
  :delete   削除する
  :clear    #\SPC で上書き
  :open     #\SPC を挿入
  :string   削除して各行に STRING を挿入
</description>
<seealso>operate-on-rectangle</seealso>
<seealso>copy-rectangle-selection</seealso>
<seealso>kill-rectangle-selection</seealso>
<seealso>delete-rectangle-selection</seealso>
<seealso>clear-rectangle-selection</seealso>
<seealso>open-rectangle-selection</seealso>
<seealso>string-rectangle-selection</seealso>
<seealso>*dont-clear-selection*</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>operate-on-rectangle</title>
<type>Function</type>
<arguments>operate-on-rectangle P1 P2 C1 C2 &amp;key :copy :delete :clear :open :string</arguments>
<package>editor</package>
<description>
P1 と P2 で指定されるリージョン中の、 C1 と C2 で定まる矩形領域に対し
てキーワードで指定された操作を行います。

  :copy     コピーする
  :delete   削除する
  :clear    #\SPC で上書き
  :open     #\SPC を挿入
  :string   削除して各行に STRING を挿入

C1, C2 には nil を指定することもできます。この場合、リージョンの開始位
置と終了位置の表示桁が使われます。

-rectangle 系のコマンドの多くはこれを用いて実装されています。


矩形についての補足：
  例えば次の図で / がリージョンの場合 * の部分が操作の対象となります。
         C1             C2                     C1             C2
  -------│-------------│--------      -------│-------------│--------
  -------│------/////////////////      -------│------*******│--------
  ////////////////////////////////      -------│*************│--------
  ////////////////////////////////      -------│*************│--------
  ////////////////////////////////      -------│*************│--------
  /////////////////////////-------      -------│*************│--------
  -------│-------------│--------      -------│-------------│--------
  
  C1, C2 を明示的に指定することはあまりなく、次のいずれかの形になる場合がほとんどでしょう。
  --------------------      --------------------
  ------------////////      ------********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////*******////////      //////********//////
  /////---------------      //////********------
  --------------------      --------------------
</description>
<seealso>operate-on-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>*rectangle-kill-buffer*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コピーした矩形を格納します。
中身は矩形の各行の文字列を並べたリストです。
</description>
<seealso>copy-rectangle</seealso>
<seealso>kill-rectangle</seealso>
<seealso>yank-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>overwrite-rectangle</title>
<type>Function</type>
<arguments>overwrite-rectangle</arguments>
<package>editor</package>
<description>
コピーしている矩形を貼り付けます。既存のテキストに上書きされます。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>restore-window-configuration-register</title>
<type>Function</type>
<arguments>restore-window-configuration-register R</arguments>
<package>editor</package>
<description>
レジスタ R に保存したウィンドウ状態に戻します。[C-x r c]
R に window-configuration が入っていないとエラーになります。
</description>
<seealso>save-window-configuration-to-register</seealso>
<link></link>
<section>ウィンドウ</section>
<file>register.l</file>
</chapter>

<chapter>
<title>save-window-configuration-to-register</title>
<type>Function</type>
<arguments>save-window-configuration-to-register R</arguments>
<package>editor</package>
<description>
レジスタ R に現在のウィンドウの状態を保存します。[C-x r w]
中身は current-window-configuration で得られるものと同じです。
保存した状態に戻すには restore-window-configuration-register を使います。
</description>
<seealso>restore-window-configuration-register</seealso>
<seealso>current-window-configuration</seealso>
<link></link>
<section>ウィンドウ</section>
<file>register.l</file>
</chapter>

<chapter>
<title>view-register</title>
<type>Function</type>
<arguments>view-register R</arguments>
<package>editor</package>
<description>
レジスタ R の中身をバッファ *output* に表示します。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>register.l</file>
</chapter>

<chapter>
<title>prepend-to-register</title>
<type>Function</type>
<arguments>prepend-to-register R START END &amp;optional DELETE</arguments>
<package>editor</package>
<description>
START と END で指定されるリージョンを、レジスタ R に格納されているテキ
ストの先頭へ追加します。
R にテキストが入っていないとエラーになります。
DELETE が non-nil ならば同時にリージョンをを削除します。
</description>
<seealso>append-to-register</seealso>
<link></link>
<section>リージョン</section>
<file>register.l</file>
</chapter>

<chapter>
<title>append-to-register</title>
<type>Function</type>
<arguments>append-to-register R START END &amp;optional DELETE</arguments>
<package>editor</package>
<description>
START と END で指定されるリージョンを、レジスタ R に格納されているテキ
ストの末尾へ追加します。 [C-x r a]
R にテキストが入っていないとエラーになります。
DELETE が non-nil ならば同時にリージョンをを削除します。
</description>
<seealso>prepend-to-register</seealso>
<link></link>
<section>リージョン</section>
<file>register.l</file>
</chapter>

<chapter>
<title>copy-to-register</title>
<type>Function</type>
<arguments>copy-to-register R START END &amp;optional DELETE</arguments>
<package>editor</package>
<description>
START と END で指定されるリージョンをレジスタ R へコピーします。[C-x r s]
DELETE が non-nil ならば同時にリージョンをを削除します。

コピーしたテキストの yank には、 insert-register を使います。 
</description>
<seealso>insert-register</seealso>
<seealso>append-to-register</seealso>
<link></link>
<section>リージョン</section>
<file>register.l</file>
</chapter>

<chapter>
<title>insert-register</title>
<type>Function</type>
<arguments>insert-register R</arguments>
<package>editor</package>
<description>
レジスタ R の内容をバッファに挿入します。[C-x r i], [C-x r g]
R にテキストまたは矩形領域が入っていないとエラーになります。
</description>
<seealso>copy-to-register</seealso>
<link></link>
<section>リージョン</section>
<file>register.l</file>
</chapter>

<chapter>
<title>prog2</title>
<type>Macro</type>
<arguments>prog2 FIRST SECOND &amp;body BODY</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して二番目のフォームの結果を返します。

使用例：
  (prog2 (print "The first form")
         (print "The second form")
         (print "The third form"))
  -&gt; "The first form"
  -&gt; "The second form"
  -&gt; "The third form"
  =&gt; "The second form"
</description>
<seealso>progn</seealso>
<seealso>prog1</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>jump-to-register</title>
<type>Function</type>
<arguments>jump-to-register R</arguments>
<package>editor</package>
<description>
レジスタ R に格納されたマーカーの位置へジャンプします。[C-x r j]
R にマーカーが入っていないとエラーになります。
</description>
<seealso>point-to-register</seealso>
<link></link>
<section>ポジション</section>
<file>register.l</file>
</chapter>

<chapter>
<title>point-to-register</title>
<type>Function</type>
<arguments>point-to-register R</arguments>
<package>editor</package>
<description>
新しいマーカーを作って現在位置にセットし、レジスタ R に格納します。
[C-x r SPC]
</description>
<seealso>jump-to-register</seealso>
<link></link>
<section>ポジション</section>
<file>register.l</file>
</chapter>

<chapter>
<title>ed::get-register</title>
<type>Function</type>
<arguments>get-register R</arguments>
<package>editor</package>
<description>
レジスタ R の値を返します。何も入ってない場合の戻り値は nil です。
</description>
<seealso>ed::set-register</seealso>
<seealso>view-register</seealso>
<link></link>
<section>その他</section>
<file>register.l</file>
</chapter>

<chapter>
<title>ed::set-register</title>
<type>Function</type>
<arguments>set-register R VALUE</arguments>
<package>editor</package>
<description>
レジスタ R に値 VALUE を格納します。
</description>
<seealso>ed::get-register</seealso>
<seealso>view-register</seealso>
<link></link>
<section>その他</section>
<file>register.l</file>
</chapter>

<chapter>
<title>ed::*register-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
レジスタに格納されている値を保持する変数。
中身は (name . datum) の形の連想リストです。
emacs と違い name にはどんな文字でも入るようです。

datum としては(通常は)以下のものが使用できます。
  マーカー
  文字列
  矩形領域(文字列のリスト)
  window configuration
</description>
<seealso>ed::get-register</seealso>
<seealso>ed::set-register</seealso>
<link></link>
<section>変数と定数</section>
<file>register.l</file>
</chapter>

<chapter>
<title>find-name-buffer</title>
<type>Function</type>
<arguments>find-buffer BUFFER-NAME</arguments>
<package>editor</package>
<description>
名前がBUFFER-NAMEもしくはBUFFER-NAME&lt;数字&gt;なバッファのリストを返します。
存在しなければnilを返します。

使用例：
  (find-name-buffer " *TAGS*")
  =&gt; (#&lt;buffer:  *TAGS*&lt;2&gt;&gt; #&lt;buffer:  *TAGS*&gt;)
  (find-name-buffer "*hoge hoge*")
  =&gt; nil
</description>
<seealso>find-buffer</seealso>
<seealso>get-file-buffer</seealso>
<seealso>create-new-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>execute-subprocess</title>
<type>Function</type>
<arguments>execute-subprocess CMD &amp;optional ARG BUFNAME ENVIRON DIRECTORY</arguments>
<package>editor</package>
<description>
プログラムを BUFFNAME で指定したバッファ上で実行します。[C-x &amp;]
結果は， BUFFNAME で指定されたバッファ上に表示されます。

  CMD        : 実行するコマンドをオプション付で指定します。
  ARG        : (詳細不明)
  BUFNAME    : 関連付けるバッファ名を指定します。デフォルトは "*Command Output*" です。
               指定したバッファが存在しないとき，新しくバッファを作ります。
  ENVIRON    : 設定する環境変数を連想リスト形式で渡します。
                  (("HOME" . "C:/applications/xyzzy/")
                   ("TOPDIR" . "C:/spool/"))
  DIRECTORY  : 実行するディレクトリを指定します。 

指定されたバッファは command-output-mode になります。

使用例：
  ;;; cmd.exe をバッファ上で実行します。 シンプルなシェルとして動作します。
  (execute-subprocess "cmd.exe")
  =&gt;#&lt;buffer: *Command Output*&gt;
</description>
<seealso>make-process</seealso>
<seealso>execute-shell-command</seealso>
<seealso>filter-region</seealso>
<seealso>command-output-mode</seealso>
<seealso>shell-command-line</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>clear-minibuffer-message</title>
<type>Function</type>
<arguments>clear-minibuffer-message</arguments>
<package>editor</package>
<description>
ミニバッファに表示された文字列を消去します。
</description>
<seealso>minibuffer-message</seealso>
<seealso>minibuffer-prompt</seealso>
<link></link>
<section>ミニバッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>minibuffer-message</title>
<type>Function</type>
<arguments>minibuffer-message FMT &amp;rest ARGS</arguments>
<package>editor</package>
<description>
書式に従ってミニバッファにメッセージを表示します。 
ミニバッファにカーソルが表示されない以外は minibuffer-prompt と同じ？

  FMT  : format 同様の書式
  ARGS : 出力書式へのパラメタ
</description>
<seealso>clear-minibuffer-message</seealso>
<seealso>minibuffer-prompt</seealso>
<seealso>format</seealso>
<link></link>
<section>ミニバッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-interval-message</title>
<type>Macro</type>
<arguments>with-interval-message (INTERVAL) &amp;body BODY</arguments>
<package>editor</package>
<description>
BODY 内で message コマンドによる表示の更新間隔を制限します。

  INTERVAL : 表示の最低更新間隔（ミリ秒）。
             前回 message を実行したときから INTERVAL ミリ秒以上経過していない場合、
             新たなメッセージを表示しません。

使用例:
  ;; 更新間隔を 100 ミリ秒にしてみる。
  (with-interval-message (100)
    (dotimes (i 100000)
      (message "~D" i)))
</description>
<seealso>message</seealso>
<link></link>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-selected-window</title>
<type>Macro</type>
<arguments>with-selected-window &amp;body BODY</arguments>
<package>editor</package>
<description>
BODY の前後でカレントウィンドウを保存します。
すなわち、BODY 実行中にウィンドウを移動しても、実行後に元のウィンドウに戻ります。
</description>
<seealso>set-window</seealso>
<seealso>save-window-excursion</seealso>
<link></link>
<section>ウィンドウ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-set-buffer</title>
<type>Macro</type>
<arguments>with-set-buffer &amp;body BODY</arguments>
<package>editor</package>
<description>
BODY を実行する際に、ポイントがミニバッファ以外にあることを保証します。
ポイントがミニバッファにあった場合、BODY を実行した後ポイントはミニバッファに戻ります。

ミニバッファで set-buffer するとエラーが起きるので、それを回避するためにあるようです。

使用例:
  ;; lisp/misc.l より
  (defun setup-temp-buffer (buffer)
    (with-set-buffer
      (save-excursion
        (set-buffer buffer)
        (setq buffer-read-only nil)
        (setq need-not-save t)
        (setq kept-undo-information nil)
        (setq auto-save nil))))
</description>
<seealso>set-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>toggle-trace-on-error</title>
<type>Function</type>
<arguments>toggle-trace-on-error &amp;optional (ARG () SVAR)</arguments>
<package>editor</package>
<description>
エラーをトレースするかどうかをトグルします。
On にする時にトレース用のバッファ *Trace Output* が無ければ新しく作ります。

前置引数をつけた場合、toggle-mode と同じような挙動をします。
</description>
<seealso>ed::toggle-mode</seealso>
<link></link>
<section>エラー</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>trap-errors</title>
<type>Macro</type>
<arguments>trap-errors &amp;body BODY</arguments>
<package>editor</package>
<description>
BODY 内でエラーが起こった場合もしくは中断（quit）された場合、
キャッチして trap-errors の外に影響がでないようにします。
handler-case の簡易版といえます。
ignore-errors と違い、エラーが発生したら表示されます。

使用例:
  ;; エラーが起きたらとりあえずキャッチして、その後の処理は続ける。
  (progn
    (trap-errors
      (/ 1 0))
    (msgbox "done."))
</description>
<seealso>handler-case</seealso>
<seealso>ignore-errors</seealso>
<link></link>
<section>エラー</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>setup-temp-buffer</title>
<type>Function</type>
<arguments>setup-temp-buffer BUFFER</arguments>
<package>editor</package>
<description>
BUFFER を一時バッファ用に初期化します。
具体的には以下のようにバッファローカル変数を設定します。

  buffer-read-only      -&gt; nil
  need-not-save         -&gt; t
  kept-undo-information -&gt; nil
  auto-save             -&gt; nil
</description>
<seealso>buffer-read-only</seealso>
<seealso>need-not-save</seealso>
<seealso>kept-undo-information</seealso>
<seealso>auto-save</seealso>
<link></link>
<section>バッファ</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>execute-extended-command</title>
<type>Function</type>
<arguments>execute-extended-command COMMAND &amp;optional RAW ARG</arguments>
<package>editor</package>
<description>
ミニバッファからコマンドを対話的に入力して実行します。[ESC x]
</description>
<seealso>command-execute</seealso>
<seealso>repeat-complex-command</seealso>
<link></link>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>load-file</title>
<type>Function</type>
<arguments>load-file FILENAME</arguments>
<package>lisp</package>
<description>
ファイルを対話的に読み込みます。
load-library と異なり、*load-path* にないファイルも読み込めます。
</description>
<seealso>load-library</seealso>
<seealso>load</seealso>
<seealso>mc-load-file</seealso>
<link></link>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>cd</title>
<type>Function</type>
<arguments>cd DIRECTORY</arguments>
<package>editor</package>
<description>
バッファが作業しているディレクトリをインタラクティブに変更します。
</description>
<seealso>set-default-directory</seealso>
<link></link>
<section>ファイルシステム</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>clear-message</title>
<type>Function</type>
<arguments>clear-message</arguments>
<package>editor</package>
<description>
ステータスバーのメッセージを消去します。
</description>
<seealso>message</seealso>
<link></link>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>vconcat</title>
<type>Function</type>
<arguments>vconcat &amp;rest SEQ</arguments>
<package>editor</package>
<description>
ベクタを連結します。

使用例:
  (vconcat #(1 3) #(2 5 7))
  =&gt; #(1 3 2 5 7)
</description>
<seealso>concatenate</seealso>
<link></link>
<section>配列</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>mc-autoload</title>
<type>Function</type>
<arguments>mc-autoload FN FILE &amp;optional COMMANDP MACROP ENCODING</arguments>
<package>lisp</package>
<description>
Shift_JIS 以外のエンコーディングのファイルに定義された関数を autoload するよう設定します。

  FN       : 関数シンボル
  FILE     : 関数が定義されたファイル名
  COMMANDP : interactive 関数かどうか
  MACROP   : マクロかどうか
  ENCODING : FILE を読み込む際のエンコーディング
</description>
<seealso>autoload</seealso>
<seealso>mc-load-library</seealso>
<seealso>mc-load-file</seealso>
<link></link>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>mc-load-library</title>
<type>Function</type>
<arguments>mc-load-library FILENAME &amp;key :encoding :no-suffix (:if-does-not-exist :error)</arguments>
<package>lisp</package>
<description>
Shift_JIS 以外のエンコーディングのファイルを読み込みます。

  FILENAME           : ファイル名
  :encoding          : 読み込むファイルのエンコーディング
  :no-suffix         : ファイルを *load-path* から探すかどうか指定します。
        t                ファイルを find-load-path で探します。
        nil              FILENAME をそのまま使います。
  :if-does-not-exist : ファイルが見つからなかった場合の挙動を指定します。
        :error           エラーを返します。デフォルトの挙動です。
        それ以外         nil を返します。
</description>
<seealso>load-library</seealso>
<seealso>mc-autoload</seealso>
<seealso>mc-load-file</seealso>
<link></link>
<section>評価</section>
<file>misc.l</file>
</chapter>


<chapter>
<title>mc-load-file</title>
<type>Function</type>
<arguments>mc-load-file FILENAME &amp;optional ENCODING</arguments>
<package>lisp</package>
<description>
Shift_JIS 以外のエンコーディングのファイルを読み込みます。
mc-load-library と違い、*load-path* にないファイルも読み込めます。
  
  FILENAME : ファイル名（フルパス）
  ENCODING : 読み込むファイルのエンコーディング
</description>
<seealso>load-file</seealso>
<seealso>mc-autoload</seealso>
<seealso>mc-load-library</seealso>
<link></link>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>quote-char</title>
<type>Function</type>
<arguments>quote-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
プロンプトを表示して、入力に従ってバッファに文字を挿入します。[C-q]
制御文字の入力などに使われます。
文字コードによる入力も可能です。
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>universal-argument</title>
<type>Function</type>
<arguments>universal-argument RAW &amp;optional ARG</arguments>
<package>editor</package>
<description>
後に続くコマンドに前置引数として 'universal-argument を渡します。[C-u]

'universal-agument を数値として処理する場合は 4 と解釈されます。
</description>
<seealso>digit-argument</seealso>
<seealso>negative-argument</seealso>
<seealso>*prefix-args*</seealso>
<seealso>*prefix-value*</seealso>
<link></link>
<section>関数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>negative-argument</title>
<type>Function</type>
<arguments>negative-argument RAW &amp;optional ARG</arguments>
<package>editor</package>
<description>
後に続くコマンドに負の前置引数を渡します。[ESC -]
</description>
<seealso>universal-argument</seealso>
<seealso>digit-argument</seealso>
<link></link>
<section>関数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>digit-argument</title>
<type>Function</type>
<arguments>digit-argument RAW &amp;optional ARG</arguments>
<package>editor</package>
<description>
後に続くコマンドに前置引数を渡します。[ESC 0 ... ESC 9]
</description>
<seealso>universal-argument</seealso>
<seealso>negative-argument</seealso>
<link></link>
<section>関数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>quit</title>
<type>Function</type>
<arguments>quit</arguments>
<package>editor</package>
<description>
コマンドの実行などを中止します。[C-g]

実行に時間がかかりすぎる場合や無限ループに陥ったときなどに使われます。
</description>
<seealso>error</seealso>
<link></link>
<section>エラー</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>undefined</title>
<type>Function</type>
<arguments>undefined</arguments>
<package>editor</package>
<description>
ベルを鳴らします。 ding の interactive 版です。

キーにコマンドが割り当てられてないことを表すのに使われることがあるようです。
</description>
<seealso>ding</seealso>
<link></link>
<section>その他</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>repeat-complex-command</title>
<type>Function</type>
<arguments>repeat-complex-command SEXP</arguments>
<package>editor</package>
<description>
execute-extended-command（いわゆるM-x）でのコマンド実行をそのままの引数
で再度実行します。[ESC p]
</description>
<seealso>execute-extended-command</seealso>
<link></link>
<section>ミニバッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>set-variable</title>
<type>Function</type>
<arguments>set-variable VAR</arguments>
<package>editor</package>
<description>
変数 VAR をプロンプトから入力した値に設定します。[C-x a]
VAR の値が文字列なら文字列として、それ以外なら S 式として入力を読み取ります。

VAR が boundp でないとエラーになります。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>eval-expression</title>
<type>Function</type>
<arguments>eval-expression X</arguments>
<package>editor</package>
<description>
lisp 式 X を評価します。[ESC ESC]
対話的に呼び出された場合はミニバッファで入力された式を評価します。
</description>
<seealso>interactive</seealso>
<link></link>
<section>評価</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>overwrite-mode</title>
<type>Function</type>
<arguments>overwrite-mode &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
上書き用マイナーモードを制御します。 toggle-over と同じです。
</description>
<seealso>toggle-over</seealso>
<link></link>
<section>モード</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>mark-whole-buffer</title>
<type>Function</type>
<arguments>mark-whole-buffer &amp;optional ARG</arguments>
<package>editor</package>
<description>
バッファ全体をリージョンにします。

ARG が
  nil ならバッファの末尾にマークを設定し、バッファの先頭に移動
  non-nil ならバッファの先頭にマークを設定し、バッファの末尾に移動
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>goto-last-modified-line</title>
<type>Function</type>
<arguments>goto-last-modified-line</arguments>
<package>editor</package>
<description>
現在のバッファで最近変更された行の先頭に移動します。
</description>
<seealso>last-modified-point</seealso>
<seealso>exchange-point-and-mark</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-left</title>
<type>Function</type>
<arguments>scroll-left &amp;optional ARG</arguments>
<package>editor</package>
<description>
ウィンドウを指定桁数分、左にスクロールします。[C-x &lt;]
負の数値を指定すると逆方向にスクロールします。
</description>
<seealso>scroll-right</seealso>
<seealso>scroll-window-horizontally</seealso>
<seealso>scroll-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-right</title>
<type>Function</type>
<arguments>scroll-right &amp;optional ARG</arguments>
<package>editor</package>
<description>
ウィンドウを指定桁数分、右にスクロールします。[C-x &gt;]
負の数値を指定すると逆方向にスクロールします。
</description>
<seealso>scroll-left</seealso>
<seealso>scroll-window-horizontally</seealso>
<seealso>scroll-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-down-other-window</title>
<type>Function</type>
<arguments>scroll-down-other-window &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次のウィンドウを指定行数分上スクロールします。
</description>
<seealso>scroll-window</seealso>
<seealso>scroll-down-both-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-up-other-window</title>
<type>Function</type>
<arguments>scroll-up-other-window &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次のウィンドウを指定行数分スクロールします。
</description>
<seealso>scroll-window</seealso>
<seealso>scroll-up-both-window</seealso>
<seealso>scroll-other-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-other-window</title>
<type>Function</type>
<arguments>scroll-other-window &amp;optional ARG</arguments>
<package>editor</package>
<description>
次のウィンドウをスクロールします。[ESC C-v]
ARG が nil なら下スクロールし、 non-nil であれば上スクロールします。
</description>
<seealso>scroll-window</seealso>
<seealso>scroll-up-other-window</seealso>
<seealso>scroll-down-other-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>set-mark</title>
<type>Function</type>
<arguments>set-mark &amp;optional POINT</arguments>
<package>editor</package>
<description>
ポイントの位置にマークを設定します。

  POINT: マークを設定する位置を指定します。
         範囲外の値を指定してもエラーにはならないようです。
</description>
<seealso>mark</seealso>
<seealso>set-mark-command</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subsetp</title>
<type>Function</type>
<arguments>subsetp LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 が LIST2 のサブセットなら t、そうでないなら nil を返します。

使用例:
  (subsetp '(1 5 7) '(1 3 5 7 9))
  =&gt; t
  (subsetp '(1 5 8) '(1 3 5 7 9))
  =&gt; nil
</description>
<seealso>set-difference</seealso>
<seealso>intersection</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nset-exclusive-or</title>
<type>Function</type>
<arguments>nset-exclusive-or LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 のいずれか一方にのみ含まれる要素のリストを作って返します。
set-exclusive-or と違い引数 LIST2 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  =&gt; (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  =&gt; (2 3 5 7 11)
  (nset-exclusive-or x y)
  =&gt; (9 1 2 11)
  x
  =&gt; (1 3 5 7 9)
  y
  =&gt; (2 11)
</description>
<seealso>set-exclusive-or</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>set-exclusive-or</title>
<type>Function</type>
<arguments>set-exclusive-or LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 のいずれか一方にのみ含まれる要素のリストを作って返します。
nset-exclusive-or と違い引数 LIST2 は保存されます。

使用例:
  (set-exclusive-or '(1 3 5 7 9) '(2 3 5 7 11))
  =&gt; (9 1 11 2)
</description>
<seealso>nset-exclusive-or</seealso>
<seealso>intersection</seealso>
<seealso>union</seealso>
<seealso>set-difference</seealso>
<seealso>ldiff</seealso>
<seealso>subsetp</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nintersection</title>
<type>Function</type>
<arguments>nintersection LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 の両方に含まれる要素のリストを作って返します。
intersection と違い引数 LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  =&gt; (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  =&gt; (2 3 5 7 11)
  (nintersection x y)
  =&gt; (3 5 7)
  x
  =&gt; (1 3 5 7)
  y
  =&gt; (2 3 5 7 11)
</description>
<seealso>intersection</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>intersection</title>
<type>Function</type>
<arguments>intersection LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 の両方に含まれる要素のリストを作って返します。
nintersection と違い引数 LIST1 は保存されます。

使用例:
  (intersection '(1 3 5 7 9) '(2 3 5 7 11))
  =&gt; (7 5 3)
</description>
<seealso>nintersection</seealso>
<seealso>union</seealso>
<seealso>set-difference</seealso>
<seealso>set-exclusive-or</seealso>
<seealso>ldiff</seealso>
<seealso>subsetp</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nunion</title>
<type>Function</type>
<arguments>nunion LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 を併せたリストを作って返します。
union と違い LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  =&gt; (1 3 5 7 9)
  (setq y '(2 3 5 7 11))
  =&gt; (2 3 5 7 11)
  (nunion x y)
  =&gt; (1 9 2 3 5 7 11)
  x
  =&gt; (1 9 2 3 5 7 11)
  y
  =&gt; (2 3 5 7 11)
</description>
<seealso>union</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>union</title>
<type>Function</type>
<arguments>union LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 と LIST2 を併せたリストを作って返します。
nunion と違い引数 LIST1 は保存されます。

使用例:
  (union '(1 3 5 7 9) '(2 3 5 7 11))
  =&gt; (1 9 2 3 5 7 11)
</description>
<seealso>merge</seealso>
<seealso>nunion</seealso>
<seealso>intersection</seealso>
<seealso>set-difference</seealso>
<seealso>set-exclusive-or</seealso>
<seealso>ldiff</seealso>
<seealso>subsetp</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>ldiff</title>
<type>Function</type>
<arguments>ldiff LIST OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT が LIST の一部であるなら、LIST から OBJECT の部分を除いたリストを返します。

LIST の一部分であるかどうかの判定は eq で行います。
OBJECT が LIST の tailp であれば LIST の一部であるとみなされるとも言えます。

使用例:
  (setq x '(a b c d e))
  =&gt; (a b c d e)
  (setq y (cddr x))
  =&gt; (c d e)
  (ldiff x y)
  =&gt; (a b)
  ;; 見た目は同じでも x の一部分でないならダメ
  (ldiff x '(c d e))
  =&gt; (a b c d e)
</description>
<seealso>tailp</seealso>
<seealso>intersection</seealso>
<seealso>set-difference</seealso>
<seealso>set-exclusive-or</seealso>
<seealso></seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nset-difference</title>
<type>Function</type>
<arguments>nset-difference LIST1 LIST2 &amp;rest REST &amp;key :test :test-not :key</arguments>
<package>lisp</package>
<description>
LIST1 から LIST2 にも含まれる要素を除き、そのリストを返します。
set-difference と違い引数 LIST1 は破壊されます。

使用例:
  (setq x '(1 3 5 7 9))
  =&gt; (1 3 5 7 9)
  (setq y '(2 3 7))
  =&gt; (2 3 7)
  (nset-difference x y)
  =&gt; (1 5 9)
  x
  =&gt; (1 5 9)
</description>
<seealso>set-difference</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>indent-for-comment</title>
<type>Function</type>
<arguments>indent-for-comment</arguments>
<package>editor</package>
<description>
行末にコメント文字列 (comment-start, comment-end) を挿入します。[ESC ;]
コメント位置は comment-indent-function を呼び出した結果で決まります。

コメント挿入後のカーソル位置は comment-start-skip か
comment-start-skip-function で指定できます。
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>clear-all-text-colors</title>
<type>Function</type>
<arguments>clear-all-text-colors</arguments>
<package>editor</package>
<description>
set-text-color で付けた属性を消します。

補足:
  この関数は Version 0.0.0.92 にて set-text-color とともに obsolete と
  なりました。
</description>
<seealso>delete-text-attributes</seealso>
<seealso>set-text-color</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>indent-relative</title>
<type>Function</type>
<arguments>indent-relative</arguments>
<package>editor</package>
<description>
半角スペースやタブ以外の文字を後方へ向かって検索し、最初に見つかった
場所の行のインデント幅と同じだけ現在行をインデントします。

ちなみに emacs の同名のコマンドとは挙動が違います。
</description>
<seealso>newline-and-indent</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>tabify</title>
<type>Function</type>
<arguments>tabify FROM TO</arguments>
<package>editor</package>
<description>
FROM と TO の間にある半角スペースを可能な限りタブ文字で置き換えます。
</description>
<seealso>untabify</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>untabify</title>
<type>Function</type>
<arguments>untabify FROM TO</arguments>
<package>editor</package>
<description>
FROM と TO の間にあるタブ文字を適当な数の半角スペースで置き換えます。
</description>
<seealso>tabify</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>transpose-lines</title>
<type>Function</type>
<arguments>transpose-lines &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのある行の一つ前の行と、そこから ARG 行先の行とを入れ換えます。[C-x C-t]
ただし ARG が 0 の場合にはマークの前の行と入れ換えます。
</description>
<seealso>transpose-region</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-blank-lines</title>
<type>Function</type>
<arguments>delete-blank-lines</arguments>
<package>editor</package>
<description>
カーソルのある行またはその次の行の前後に続く空行を削除します。[C-x C-o]
複数の空行が続く場合は改行文字を一つだけ残します。

なお空行とは半角スペースおよびタブのみからなる行のことです。
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>just-one-space</title>
<type>Function</type>
<arguments>just-one-space</arguments>
<package>editor</package>
<description>
カーソル位置の前後にある半角スペースとタブを削除した後、半角スペース
をひとつだけ挿入します。[ESC /]
</description>
<seealso>delete-horizontal-spaces</seealso>
<seealso>delete-indentation</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-delete-char-untabify-or-selection</title>
<type>Function</type>
<arguments>backward-delete-char-untabify-or-selection &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
セレクションで選択中ならばセレクション全体を、そうでなければカーソルの
後方の文字を指定文字数分だけ削除します。タブ文字を削除する際は、適当な
数の半角スペースに置き換えられてから削除されます。
</description>
<seealso>delete-backward-char</seealso>
<seealso>backward-delete-char-untabify</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-delete-char-untabify</title>
<type>Function</type>
<arguments>backward-delete-char-untabify &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル後方の文字を指定文字数分だけ削除します。タブ文字を削除する際は、
適当な数の半角スペースに置き換えられてから削除されます。
</description>
<seealso>delete-backward-char</seealso>
<seealso>backward-delete-char-untabify-or-selection</seealso>
<seealso>untabify</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-backward-char</title>
<type>Function</type>
<arguments>delete-backward-char &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
カーソル後方の文字を指定文字数分だけ削除します。
</description>
<seealso>delete-backward-char-or-selection</seealso>
<seealso>delete-char</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>:key</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
assoc や member、find などの関数で検索をする際に
各要素に適用する関数を指定します。
言い換えると、:test や :test-not で指定された関数に渡す値を
各要素から“取り出す”方法をこの関数で指定します。

使用例:
  ;; car が 'a である要素を除去する
  (remove 'a '((a . b) (b . x) (c d e) (a f h i) (x y)) :key #'car)
  =&gt; ((b . x) (c d e) (x y))
  ;; :test と組み合わせることも可能
  (remove "a" '(("a" . "b") ("b" . "c") ("d" . "a") ("a" . "e") ("b". "b"))
          :test #'string= :key #'car)
  =&gt; (("b" . "c") ("d" . "a") ("b" . "b"))
</description>
<seealso>:test</seealso>
<seealso>:test-not</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:test-not</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
assoc や member、find などの関数で検索をする際に、
このキーワードに設定した関数の逆（not）を用いて真偽の判定をします。
  
なお :test と同時に指定することはできません。

使用例:
  ;; "abc" を含む文字列を選ぶ = "abc" を含まない文字列を除去する
  (remove "abc" '("abcd" "test" "xabcx" "abc" "xyz") :test-not #'string-match)
  =&gt; ("abcd" "xabcx" "abc")
</description>
<seealso>:test</seealso>
<seealso>:key</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:test</title>
<type>Keyword</type>
<arguments></arguments>
<package>keyword</package>
<description>
assoc や member、find などの関数で検索をする際に、
このキーワードに設定した関数を用いて真偽の判定をします。

なお :test-not と同時に指定することはできません。

使用例:
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)))
  =&gt; nil
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)) :test #'string=)
  =&gt; ("b" . 3)
  (assoc "b" '(("a" . 1) ("B" . 2) ("b" . 3) ("c" . 4)) :test #'string-equal)
  =&gt; ("B" . 2)
</description>
<seealso>:test-not</seealso>
<seealso>:key</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>array-row-major-index</title>
<type>Function</type>
<arguments>array-row-major-index ARRAY &amp;rest SUBSCRIPTS</arguments>
<package>lisp</package>
<description>
ARRAY の SUBSCRIPTS で表される要素が、ARRAY を一次元の配列とみなしたときに
何番目の要素にあたるかのインデックスを返します。

SUBSCRIPTS の数は ARRAY の次元と等しい必要があり、
また各引数は ARRAY の各次元のサイズ未満である必要があります。

使用例:
  (setf x (make-array '(2 3)))
  =&gt; #2A((nil nil nil) (nil nil nil))
  (array-row-major-index x 0 2)
  =&gt; 2
  (array-row-major-index x 1 1)
  =&gt; 4

  上の例はこんな感じです。

        0   1   2
     ┌─┬─┬─┐
   0 │ 0│ 1│ 2│
     ├─┼─┼─┤
   1 │ 3│ 4│ 5│
     └─┴─┴─┘
</description>
<seealso>row-major-aref</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>row-major-aref</title>
<type>Function</type>
<arguments>row-major-aref ARRAY INDEX</arguments>
<package>lisp</package>
<description>
ARRAY を一次元の配列とみなしたときに、INDEX 番目になる要素を返します。

使用例:
  (setf x (make-array '(2 3) :initial-contents '((a b c) (d e f))))
  =&gt; #2A((a b c) (d e f))
  (row-major-aref x 0)
  =&gt; a
  (row-major-aref x 2)
  =&gt; c
  (row-major-aref x 3)
  =&gt; d
</description>
<seealso>aref</seealso>
<seealso>svref</seealso>
<seealso>array-row-major-index</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>adjustable-array-p</title>
<type>Function</type>
<arguments>adjustable-array-p ARRAY</arguments>
<package>lisp</package>
<description>
ARRAY がサイズ変更可能なら t、不可能なら nil を返します。
</description>
<seealso>vector-push-extend</seealso>
<seealso>make-array</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>array-element-type</title>
<type>Function</type>
<arguments>array-element-type ARRAY</arguments>
<package>lisp</package>
<description>
ARRAY の要素のタイプを判別します。
配列なら t、文字列なら character を返します。
</description>
<seealso>make-array</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>array-total-size</title>
<type>Function</type>
<arguments>array-total-size ARRAY</arguments>
<package>lisp</package>
<description>
配列 ARRAY の全要素数を返します。

使用例:
  (setf x (make-array '(2 3)))
  =&gt; #2A((nil nil nil) (nil nil nil))
  (array-total-size x)
  =&gt; 6
</description>
<seealso>array-dimension</seealso>
<seealso>array-dimensions</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>array-dimension</title>
<type>Function</type>
<arguments>array-dimension ARRAY AXIS-NUMBER</arguments>
<package>lisp</package>
<description>
配列 ARRAY の AXIS-NUMBER 番目の次元のサイズを返します。
AXIS-NUMBER は 0 から始まる整数値です。
なお、フィルポインタを持っているベクタに関しても、本来のサイズを返します。

使用例:
  (setf x (make-array '(2 3)))
  =&gt; #2A((nil nil nil) (nil nil nil))
  (array-dimension x 0)
  =&gt; 2
  (array-dimension x 1)
  =&gt; 3

  ;; フィルポインタつきのベクタ
  (setf x (make-array 5 :initial-contents '(a b c d e) :fill-pointer 3))
  =&gt; #(a b c)
  (array-dimension x 0)
  =&gt; 5
  (length x) ; length だとフィルポインタまでの長さになる
  =&gt; 3
</description>
<seealso>array-dimensions</seealso>
<seealso>array-total-size</seealso>
<link></link>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>array-dimensions</title>
<type>Function</type>
<arguments>array-dimensions ARRAY</arguments>
<package>lisp</package>
<description>
配列 ARRAY の各次元のサイズをリストにして返します。

使用例:
  (setf x (make-array '(2 3)))
  =&gt; #2A((nil nil nil) (nil nil nil))
  (array-dimensions x)
  =&gt; (2 3)
</description>
<seealso>array-dimension</seealso>
<seealso>array-total-size</seealso>
<seealso>make-array</seealso>
<link></link>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>array-rank</title>
<type>Function</type>
<arguments>array-rank ARRAY</arguments>
<package>lisp</package>
<description>
配列 ARRAY の次元を返します。

使用例:
  (setf x (make-array '(2 3)))
  =&gt; #2A((nil nil nil) (nil nil nil))
  (array-rank x)
  =&gt; 2
</description>
<seealso>make-array</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>array-has-fill-pointer-p</title>
<type>Function</type>
<arguments>array-has-fill-pointer-p ARRAY</arguments>
<package>lisp</package>
<description>
配列 ARRAY がフィルポインタを持っているなら t、
持っていないなら nil を返します。
</description>
<seealso>fill-pointer</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fill-pointer</title>
<type>Function</type>
<arguments>fill-pointer VECTOR</arguments>
<package>lisp</package>
<description>
ベクタ（一次元配列） VECTOR のフィルポインタの位置を返します。
VECTOR がフィルポインタを持たない場合、エラーとなります。
  
備考:
  フィルポインタは、ベクタの見た目上の最後の位置を決めます。
  make-array では与えられた DIMENSION の配列を作りますが、
  フィルポインタを与えた場合、画面に表示されたり vector-pop などの関数が
  作用したりするのはフィルポインタの位置までとなります。

  なお、aref を使えばフィルポインタ以降の要素にもアクセスできます。
  また、フィルポインタに関係ないベクタ本来の長さを知りたい場合は
  array-dimension （または array-dimensions）を使います。
</description>
<seealso>array-has-fill-pointer-p</seealso>
<seealso>make-array</seealso>
<seealso>vector-pop</seealso>
<seealso>vector-push</seealso>
<seealso>length</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>vector-push</title>
<type>Function</type>
<arguments>vector-push NEW-ELEMENT VECTOR</arguments>
<package>lisp</package>
<description>
ベクタ（一次元配列） VECTOR のフィルポインタの次の位置に
新しい要素 NEW-ELEMENT を追加します。

VECTOR はフィルポインタを持っているベクタである必要があります。
フィルポインタが VECTOR の最後に達している場合には何もせず nil を返します。

使用例:
  ;; フィルポインタがベクタの長さに一致
  (setf x (make-vector 5 :initial-contents '(a b c d e) :fill-pointer t))
  =&gt; #(a b c d e)
  (fill-pointer x)
  =&gt; 5
  (vector-push 'xyz x)
  =&gt; nil
  x
  =&gt;#(a b c d e)

  ;; フィルポインタがベクタの長さより小さい
  (setf x (make-vector 5 :initial-contents '(a b c d e) :fill-pointer 3))
  =&gt; #(a b c)
  (fill-pointer x)
  =&gt; 3
  (vector-push 'xyz x)
  =&gt; 3
  x
  =&gt; #(a b c xyz)
</description>
<seealso>fill-pointer</seealso>
<seealso>vector-pop</seealso>
<seealso>vector-push-extend</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>vector-pop</title>
<type>Function</type>
<arguments>vector-pop VECTOR</arguments>
<package>lisp</package>
<description>
ベクタ（一次元配列） VECTOR のフィルポインタの位置の要素を取り除き、
その要素を返します。

VECTOR はフィルポインタを持っているベクタである必要があります。

使用例:
  ;; フィルポインタなし
  (setf x (make-array 5 :initial-contents '(a b c d e)))
  =&gt; #(a b c d e)
  (vector-pop x)
  =&gt; エラー

  ;; フィルポインタあり
  (setf x (make-array 5 :initial-contents '(a b c d e) :fill-pointer t))
  =&gt; #(a b c d e)
  (vector-pop x)
  =&gt; e
  x
  =&gt; #(a b c d)
</description>
<seealso>fill-pointer</seealso>
<seealso>vector-push</seealso>
<link></link>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>what-cursor-position</title>
<type>Function</type>
<arguments>what-cursor-position</arguments>
<package>editor</package>
<description>
カーソル位置の情報をステータスバーに表示します。[C-x =]
カーソル位置の文字の内部コード値、UNICODE値、
カーソル位置のバッファにおける位置、
桁数などが表示されます。

使用例:
  "w"の位置で情報を見る
  Char: w (0x77 / U+0077 / 0x77[us-ascii])  point=46 of 518(8%)  column 7

  "カ"の位置で情報を見る
  Char: カ (0x834a / U+30ab / 0x252b[jisx0208])  point=152 of 395(38%)  column 0
</description>
<seealso>iso-char-code</seealso>
<seealso>point</seealso>
<seealso>current-column</seealso>
<seealso>*status-bar-format*</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>exchange-point-and-mark</title>
<type>Function</type>
<arguments>exchange-point-and-mark</arguments>
<package>editor</package>
<description>
カーソルとマークの位置を入れ替えます。[C-x C-x]
</description>
<seealso>mark</seealso>
<seealso>goto-last-modified-line</seealso>
<seealso>goto-last-mouse-point</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>point-marker</title>
<type>Function</type>
<arguments>point-marker</arguments>
<package>editor</package>
<description>
新しいマーカーを作成し、現在のカーソル位置にセットして返します。
</description>
<seealso>set-marker</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>beginning-of-virtual-line</title>
<type>Function</type>
<arguments>beginning-of-virtual-line</arguments>
<package>editor</package>
<description>
表示行の行頭に移動します。
goto-virtual-bol の interactive 版です。
</description>
<seealso>goto-virtual-bol</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>end-of-virtual-line</title>
<type>Function</type>
<arguments>end-of-virtual-line</arguments>
<package>editor</package>
<description>
表示行の行末に移動します。
goto-virtual-eol の interactive 版です。
</description>
<seealso>goto-virtual-eol</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>previous-word</title>
<type>Function</type>
<arguments>previous-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを後方の単語の先頭に移動します。
</description>
<seealso>backward-word</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>next-word</title>
<type>Function</type>
<arguments>next-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを前方の単語の先頭に移動します。
</description>
<seealso>forward-word</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-virtual-line</title>
<type>Function</type>
<arguments>backward-virtual-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
表示行で N 行後方へ移動します。
</description>
<seealso>forward-virtual-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-line</title>
<type>Function</type>
<arguments>backward-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N 行後方へ移動します。
移動の前後で goal-column を保存しません。

(backward-line n) と (forward-line (- n)) は同じです。
</description>
<seealso>forward-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>mismatch</title>
<type>Function</type>
<arguments>mismatch SEQUENCE1 SEQUENCE2 &amp;key :from-end :test :test-not (:key #'identity) (:start1 0) (:start2 0) :end1 :end2</arguments>
<package>lisp</package>
<description>
SEQUENCE1 と SEQUENCE2 を比較し、一致しない要素のインデックスを返します。

  :start1  SEQUENCE1 の比較開始位置
  :start2  SEQUENCE2 の比較開始位置
  :end1    SEQUENCE1 の比較終了位置
  :end2    SEQUENCE2 の比較終了位置

:start1 と :start2 の値が異なる場合、SEQUENCE1 内でのインデックスを返します。

使用例:
  (mismatch "abcd" "abxd")
  =&gt; 2

備考:
  :from-end は実装されていないようです。
</description>
<seealso></seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>delete-duplicates</title>
<type>Function</type>
<arguments>delete-duplicates SEQUENCE &amp;key :from-end :test :test-not (:start 0) (:end (length SEQUENCE)) (:key #'identity)</arguments>
<package>lisp</package>
<description>
SEQUENCE の中から重複する要素を削除したシーケンスを返します。
delete 同様、引数 SEQUENCE は破壊されます。

 :from-end  non-nil ならシーケンスの終わりから重複する要素を削除していきます。
</description>
<seealso>delete</seealso>
<seealso>remove-duplicates</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>remove-duplicates</title>
<type>Function</type>
<arguments>remove-duplicates SEQUENCE &amp;key :from-end :test :test-not (:start 0) :end (:key #'identity)</arguments>
<package>lisp</package>
<description>
SEQUENCE の中から重複する要素を削除したシーケンスを返します。
remove 同様、引数 SEQUENCE は保存されます。

  :from-end  non-nil ならシーケンスの終わりから重複する要素を削除していきます。
</description>
<seealso>remove</seealso>
<seealso>delete-duplicates</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>complement</title>
<type>Function</type>
<arguments>complement FN</arguments>
<package>lisp</package>
<description>
FN と逆の結果（not）を返す関数を作り、その関数を返します。

使用例:
  (funcall (complement 'oddp) 4)
  =&gt; t
</description>
<seealso>not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>pseudo-frame-selector</title>
<type>Function</type>
<arguments>pseudo-frame-selector</arguments>
<package>editor</package>
<description>
ダイアログからフレームを選択します。
</description>
<seealso>switch-pseudo-frame</seealso>
<seealso>select-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>switch-pseudo-frame</title>
<type>Function</type>
<arguments>switch-pseudo-frame NAME</arguments>
<package>editor</package>
<description>
対話的にフレームを選択します。
</description>
<seealso>select-pseudo-frame</seealso>
<seealso>pseudo-frame-selector</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>rename-pseudo-frame</title>
<type>Function</type>
<arguments>rename-pseudo-frame NAME</arguments>
<package>editor</package>
<description>
現在選択しているフレームの名前を NAME に変更します。
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>delete-all-pseudo-frames</title>
<type>Function</type>
<arguments>delete-all-pseudo-frames &amp;optional (CREATE-NEW t)</arguments>
<package>editor</package>
<description>
フレームをすべて削除します。

  CREATE-NEW : すべて削除した後に、新しいフレームを作るかどうか
        t        作る
        nil      作らない

各フレームごとにスロット deleted-fn に登録された関数が実行されます。
</description>
<seealso>delete-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>delete-pseudo-frame</title>
<type>Function</type>
<arguments>delete-pseudo-frame &amp;optional (FRAME ed::*current-pseudo-frame*)</arguments>
<package>editor</package>
<description>
フレームを削除します。[C-x 6 0]
最後のひとつを削除した場合、即座に新しいフレームが作られます。

  FRAME : 削除するフレーム

FRAME のスロット deleted-fn に関数が設定されている場合、FRAME が削除される前に funcall されます。
</description>
<seealso>new-pseudo-frame</seealso>
<seealso>delete-all-pseudo-frames</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>previous-pseudo-frame</title>
<type>Function</type>
<arguments>previous-pseudo-frame</arguments>
<package>editor</package>
<description>
前のフレームに移動します。[C-x 6 p]
</description>
<seealso>next-pseudo-frame</seealso>
<seealso>other-pseudo-frame</seealso>
<seealso>switch-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>next-pseudo-frame</title>
<type>Function</type>
<arguments>next-pseudo-frame</arguments>
<package>editor</package>
<description>
other-pseudo-frame の別名です。
</description>
<seealso>previous-pseudo-frame</seealso>
<seealso>other-pseudo-frame</seealso>
<seealso>switch-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>other-pseudo-frame</title>
<type>Function</type>
<arguments>other-pseudo-frame</arguments>
<package>editor</package>
<description>
次のフレームに移動します。[C-x 6 o]
</description>
<seealso>previous-pseudo-frame</seealso>
<seealso>next-pseudo-frame</seealso>
<seealso>switch-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>select-pseudo-frame</title>
<type>Function</type>
<arguments>select-pseudo-frame FRAME</arguments>
<package>editor</package>
<description>
フレーム FRAME を選択します。

FRAME のスロット selected-fn に関数が設定されている場合、それを funcall します。
最後に *select-pseudo-frame-hook* を実行します。
</description>
<seealso>switch-pseudo-frame</seealso>
<seealso>pseudo-frame-selector</seealso>
<seealso>find-pseudo-frame</seealso>
<seealso>new-pseudo-frame</seealso>
<seealso>*select-pseudo-frame-hook*</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>find-pseudo-frame</title>
<type>Function</type>
<arguments>find-pseudo-frame NAME</arguments>
<package>editor</package>
<description>
現在のフレームの中から名前が NAME であるものを探して返します。
</description>
<seealso>select-pseudo-frame</seealso>
<seealso>selected-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>new-pseudo-frame</title>
<type>Function</type>
<arguments>new-pseudo-frame NAME &amp;optional SAVE-P SELECTED-FN DELETED-FN</arguments>
<package>editor</package>
<description>
新しいフレームを作って返します。[C-x 6 2]

  NAME        : フレームの名前
  SAVE-P      : セッション保存時にこのフレームを保存するかどうか
  SELECTED-FN : このフレームを選択した時に実行される関数
  DELETED-FN  : このフレームを削除した時に実行される関数

フレームは構造体として定義されており、これらの引数はそれぞれ
同名のスロットに設定されます。

インタラクティブに呼んだ場合 NAME は自動的に割り振られ、SAVE-P は t に設定されます。
前置引数をつけて呼べば NAME を対話的に入力できます。
</description>
<seealso>select-pseudo-frame</seealso>
<seealso>delete-pseudo-frame</seealso>
<seealso>*select-pseudo-frame-hook*</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>selected-pseudo-frame</title>
<type>Function</type>
<arguments>selected-pseudo-frame</arguments>
<package>editor</package>
<description>
現在選択しているフレームを返します。
</description>
<seealso>find-pseudo-frame</seealso>
<link></link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>ed::pseudo-frame</title>
<type>Struct</type>
<arguments></arguments>
<package>editor</package>
<description>
フレームは pseudo-frame という構造体として、pframe.l 内で定義されています。
この構造体は以下のようなスロットを持っています。
  name        : フレームの名前
  winconf     : このフレームにおけるウィンドウの状態
  save-p      : セッション保存時にこのフレームを保存するかどうか
  selected-fn : このフレームを選択したときに実行される関数
  deleted-fn  : このフレームを削除するときに実行される関数

フレームを新しく作成するには new-pseudo-frame を使えばよく、
winconf 以外のスロットは new-pseudo-frame の引数として指定できます。
winconf はフレーム作成時や移動時に自動的に設定されます。

selected-fn および delete-fn に設定された関数は funcall によって呼び出されます。
*select-pseudo-frame-hook* と異なり、フレームごとに異なる関数を割り当てることができます。
また、selected-fn の関数は *select-pseudo-frame-hook* より先に実行されます。
</description>
<seealso>new-pseudo-frame</seealso>
<seealso>select-pseudo-frame</seealso>
<seealso>delete-pseudo-frame</seealso>
<seealso>*select-pseudo-frame-hook*</seealso>
<link>http://xyzzy.s53.xrea.com/qanda/wiki.cgi?p=e1d59f7af8a5ebd071340560b6ed41a2</link>
<link>http://xyzzy.s53.xrea.com/wiki/index.php?QuickTour%2Fframe</link>
<section>ウィンドウ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>ctl-x-6-prefix</title>
<type>Function</type>
<arguments>ctl-x-6-prefix</arguments>
<package>editor</package>
<description>
C-x 6 プレフィックスです。 [C-x 6]
デフォルトではフレーム関係のコマンドが登録されています。

ctl-x-6-prefix の関数セルは普通のコマンドではなく ctl-x-6-map というキ
ーマップを保持しています。
</description>
<seealso>ctl-x-6-map</seealso>
<link></link>
<section>キーマップ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>ctl-x-6-map</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
C-x 6 に続くキーシーケンスのバインディングを格納するキーマップです。
</description>
<seealso>ctl-x-6-prefix</seealso>
<link></link>
<section>キーマップ</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>ctl-x-4-prefix</title>
<type>Function</type>
<arguments>ctl-x-4-prefix</arguments>
<package>editor</package>
<description>
C-x 4 プレフィックスです。 [C-x 4]
デフォルトでは
  C-x 4 b      switch-to-buffer-other-window
  C-x 4 f      find-file-other-window
の二つが設定されています。

ctl-x-4-prefix の関数セルは普通のコマンドではなく ctl-x-4-map というキ
ーマップを保持しています。
</description>
<seealso>ctl-x-4-map</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>ctl-x-4-map</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
C-x 4 に続くキーシーケンスのバインディングを格納するキーマップです。
</description>
<seealso>ctl-x-4-prefix</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>specific-command-prefix</title>
<type>Function</type>
<arguments>specific-command-prefix</arguments>
<package>editor</package>
<description>
C-c プレフィックスです。 [C-c]

specific-command-prefix の関数セルは普通のコマンドではなく spec-map と
いうキーマップを保持しています。
</description>
<seealso>spec-map</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>spec-map</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
C-c に続くキーシーケンスのバインディングを格納するキーマップです。
</description>
<seealso>specific-command-prefix</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>meta-prefix</title>
<type>Function</type>
<arguments>meta-prefix</arguments>
<package>editor</package>
<description>
ESC プレフィックスです。 [ESC]

meta-prefix の関数セルは普通のコマンドではなく esc-map というキーマッ
プを保持しています。
</description>
<seealso>esc-map</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>esc-map</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ESC に続くキーシーケンスのバインディングを格納するキーマップです。
</description>
<seealso>meta-prefix</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>ctl-x-prefix</title>
<type>Function</type>
<arguments>ctl-x-prefix</arguments>
<package>editor</package>
<description>
C-x プレフィックスです。 [C-x]

ctl-x-prefix の関数セルは普通のコマンドではなく ctl-x-map というキーマ
ップを保持しています。

参考:
  ;;; keymap.l
  (defvar ctl-x-map (make-keymap))
  (setf (symbol-function 'ctl-x-prefix) ctl-x-map)
</description>
<seealso>ctl-x-map</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>ctl-x-map</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
C-x に続くキーシーケンスのバインディングを格納するキーマップです。
</description>
<seealso>ctl-x-prefix</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>*global-keymap*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
グローバルなキーマップです。モード毎のキーマップに何も割り当てられてい
ない場合に使われます。

global-set-key はこのキーマップにバインディングをセットします。
</description>
<seealso>global-set-key</seealso>
<link></link>
<section>キーマップ</section>
<file></file>
</chapter>

<chapter>
<title>append-rectangle</title>
<type>Function</type>
<arguments>append-rectangle</arguments>
<package>editor</package>
<description>
コピーしている矩形の各行を現在行以下の行末へ追加します。

使用例：
  こんなのをコピーしているときに
          ┌────┐
          │A       │
          │BC      │
          │DEF     │
          │GHIJ    │
          └────┘
  * の位置で append-rectangle すると
   ┌─────┐      ┌─────┐
   │*-lmn     │      │--lmnA    │
   │--op      │  →  │--opBC    │
   │--        │      │--DEF     │
   │--q       │      │--qGHIJ   │
   └─────┘      └─────┘
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>modify-text-attributes-if-not</title>
<type>Function</type>
<arguments>modify-text-attributes-if-not TEST &amp;key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たさないものすべてについて、属性を変更します。
属性は引き継がれません。
範囲を指定した場合、開始点が範囲に含まれるもののみ変更されます。

  :bold        ボールドで表示するかどうか
  :underline   下線付きで表示するかどうか
  :strike-out  取り消し線を表示するかどうか
  :foreground  文字色を整数で指定
  :background  背景色を整数で指定
  :prefix      行番号部分に表示する文字
  :extend      行末の改行文字以降も変えるかどうか
  :start       検索開始位置
  :end         検索終了位置
  :key         TEST に渡す前にタグに適用する関数
</description>
<seealso>modify-text-attributes</seealso>
<seealso>modify-text-attributes-if</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>modify-text-attributes-if</title>
<type>Function</type>
<arguments>modify-text-attributes-if TEST &amp;key :foreground :background :bold :underline :strike-out :prefix :extend :start :end :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たすものすべてについて、属性を変更します。
属性は引き継がれません。
範囲を指定した場合、開始点が範囲に含まれるもののみ変更されます。

  :bold        ボールドで表示するかどうか
  :underline   下線付きで表示するかどうか
  :strike-out  取り消し線を表示するかどうか
  :foreground  文字色を整数で指定
  :background  背景色を整数で指定
  :prefix      行番号部分に表示する文字
  :extend      行末の改行文字以降も変えるかどうか
  :start       検索開始位置
  :end         検索終了位置
  :key         TEST に渡す前にタグに適用する関数
</description>
<seealso>modify-text-attributes-if-not</seealso>
<seealso>modify-text-attributes</seealso>
<seealso>set-text-attribute</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-text-attributes-if-not</title>
<type>Function</type>
<arguments>delete-text-attributes-if-not TEST &amp;key :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たさないものをすべて削除します。
</description>
<seealso>delete-text-attributes-if</seealso>
<seealso>delete-text-attributes</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-text-attributes-if</title>
<type>Function</type>
<arguments>delete-text-attributes-if TEST &amp;key :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たすものをすべて削除します。
</description>
<seealso>delete-text-attributes-if-not</seealso>
<seealso>delete-text-attributes</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-text-attribute-point</title>
<type>Function</type>
<arguments>delete-text-attribute-point POINT</arguments>
<package>editor</package>
<description>
POINT の位置のテキスト属性を削除します。
テキスト属性のうち POINT の位置を範囲に含むものを削除します。
</description>
<seealso>delete-text-attributes</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-text-attribute-if-not</title>
<type>Function</type>
<arguments>find-text-attribute-if-not TEST &amp;key :start :end :from-end :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たさないものを探し、最初に見つかったものを返します。
多値で、テキスト属性の開始位置・終了位置・タグを返します。

  :start     検索開始位置（デフォルトでは point-min?）
  :end       検索終了位置（デフォルトでは point-max?）
  :from-end  後ろから検索するかどうか
  :key       TEST に渡す前にタグに適用する関数
</description>
<seealso>find-text-attribute-if</seealso>
<seealso>find-text-attribute</seealso>
<seealso>find-text-attribute-point</seealso>
<seealso>set-text-attribute</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>prog*</title>
<type>Macro</type>
<arguments>prog* VARLIST &amp;body BODY</arguments>
<package>lisp</package>
<description>
prog とよく似ていますが、 VARLIST の中で先に定義した他の変数を参照でき
る点が異なります。
</description>
<seealso>tagbody</seealso>
<seealso>prog</seealso>
<seealso>let*</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>find-text-attribute-if</title>
<type>Function</type>
<arguments>find-text-attribute-if TEST &amp;key :start :end :from-end :key</arguments>
<package>editor</package>
<description>
テキスト属性のうち、タグが TEST を満たすものを探し、最初に見つかったものを返します。
多値で、テキスト属性の開始位置・終了位置・タグを返します。

  :start     検索開始位置（デフォルトでは point-min?）
  :end       検索終了位置（デフォルトでは point-max?）
  :from-end  後ろから検索するかどうか
  :key       TEST に渡す前にタグに適用する関数
</description>
<seealso>find-text-attribute-if-not</seealso>
<seealso>find-text-attribute</seealso>
<seealso>find-text-attribute-point</seealso>
<seealso>set-text-attribute</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-text-attributes</title>
<type>Function</type>
<arguments>list-text-attributes &amp;optional START END</arguments>
<package>editor</package>
<description>
バッファ中のテキスト属性をすべて探し、リストにして返します。
範囲を指定した場合、その範囲中に一部でも含まれるものをリストにします。

  START : 検索範囲の開始点
  END   : 検索範囲の終了点
</description>
<seealso>find-text-attribute</seealso>
<seealso>set-text-attribute</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>local-set-key</title>
<type>Function</type>
<arguments>local-set-key KEY COMMAND</arguments>
<package>editor</package>
<description>
カレントバッファのローカルキーマップにキーを登録します。
引数の意味は global-set-key と同じです。
</description>
<seealso>local-unset-key</seealso>
<seealso>local-keymap</seealso>
<seealso>global-set-key</seealso>
<seealso>define-key</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>ed::*auto-save-session-file*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
セッションの自動保存フラグです。

  nil     : 自動保存しない
  non-nil : 自動保存する
</description>
<seealso>toggle-session-auto-save</seealso>
<seealso>close-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>*buffer-info-variable-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
セッションファイルに保存しておくバッファローカル変数のリストです。

このリストに含まれる変数のバッファごとの値はセッションファイルに保存さ
れ、ロードした際に復元されます。(正確には、バッファローカルになってい
る場合だけそのバッファの情報として保存されます)
</description>
<seealso>save-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>close-session-dialog</title>
<type>Function</type>
<arguments>close-session-dialog &amp;optional NOASK</arguments>
<package>editor</package>
<description>
close-session とほぼ同じですが、変更されたバッファを保存する際に
ダイアログを表示して保存先を指定します。 [C-x 6 K]

  NOASK      : nil の場合ファイルごとに保存するかどうか確認
</description>
<seealso>close-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>close-session</title>
<type>Function</type>
<arguments>close-session &amp;optional NOASK (CREATE-NEW t) (FN #'write-file)</arguments>
<package>editor</package>
<description>
すべてのフレームと *scratch* を除くすべてのバッファを削除します。
保存していないバッファがあれば保存します。 [C-x 6 k]

ed::*auto-save-session-file* が non-nil であり、現在セッションを開いて
いるならば同時にセッションファイルを上書きします。

  NOASK      : nil の場合ファイルごとに保存するかどうか確認
  CREATE-NEW : non-nil であれば最後に新しいフレームをひとつ作る
  FN         : ファイルの保存に使われる関数
</description>
<seealso>ed::auto-save-session-file</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>toggle-session-auto-save</title>
<type>Function</type>
<arguments>toggle-session-auto-save &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
セッションの自動保存フラグ (ed::*auto-save-session-file*) を切り替え
ます。 non-nil のときは、セッションを終了する際に自動でセッションファ
イルを上書きします。

ARG が与えられたとき (SV が non-nil のとき) は
  nil または負の整数 : nil にする
  それ以外           : t にする
</description>
<seealso>close-session</seealso>
<seealso>ed::*auto-save-session-file*</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>*default-session-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
セッションファイルの保存・ロードの際にファイル名を読むときにデフォルト
で表示されるディレクトリです。
</description>
<seealso>load-session</seealso>
<seealso>save-session</seealso>
<seealso>ed::session-directory</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>save-session-dialog</title>
<type>Function</type>
<arguments>save-session-dialog</arguments>
<package>editor</package>
<description>
ダイアログからセッションファイル名を指定してセッションを保存します。
[C-x 6 S]
</description>
<seealso>save-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>open-session-dialog</title>
<type>Function</type>
<arguments>open-session-dialog</arguments>
<package>editor</package>
<description>
ダイアログからセッションファイル名を指定してセッションを開きます。
[C-x 6 F]
</description>
<seealso>load-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>load-session</title>
<type>Function</type>
<arguments>load-session FILENAME &amp;optional NOT-CLOSE</arguments>
<package>editor</package>
<description>
セッションファイルに保存されている状態を復元します。 [C-x 6 f]

  NOT-CLOSE : ロード前に開いているバッファを削除するかどうか
        nil       *scratch* を除いてすべて削除してからロード
        non-nil   残したままロード
</description>
<seealso>save-session</seealso>
<seealso>*default-session-directory*</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>save-session</title>
<type>Function</type>
<arguments>save-session FILENAME &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
現在のバッファと各フレームのウィンドウの状態をセッションファイルに保存
します。ただし file-visited でないバッファと save-p が nil なフレーム
は保存されません。 [C-x 6 s]

保存した状態は load-session で復元することができます。

  NOWARN : 指定されたファイルがすでに存在するときの動作
        non-nil   黙って上書きする
        nil       メッセージボックスを表示して確認する
</description>
<seealso>load-session</seealso>
<link></link>
<section>バッファ</section>
<file>session.l</file>
</chapter>

<chapter>
<title>package-used-by-list</title>
<type>Function</type>
<arguments>package-used-by-list PACKAGE</arguments>
<package>lisp</package>
<description>
指定されたパッケージが使用されているパッケージを返します

  PACKAGE : パッケージそのものもしくはパッケージ名の文字列

使用例:
  (package-used-by-list (find-package "lisp"))
  =&gt;(#&lt;package: system&gt; #&lt;package: editor&gt; #&lt;package: user&gt;)
</description>
<seealso>use-package</seealso>
<seealso>package-use-list</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>package-use-list</title>
<type>Function</type>
<arguments>package-use-list PACKAGE</arguments>
<package>lisp</package>
<description>
指定されたパッケージが使用しているパッケージを返します

  PACKAGE : パッケージそのものもしくはパッケージ名の文字列

使用例：
  (package-use-list "user")
  =&gt;(#&lt;package: lisp&gt; #&lt;package: editor&gt;)
</description>
<seealso>package-used-by-list</seealso>
<seealso>use-package</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>prog</title>
<type>Macro</type>
<arguments>prog VARLIST &amp;body BODY</arguments>
<package>lisp</package>
<description>
let と block と tagbody を合わせた制御構造です。

VARLIST によって局所変数を作り BODY を評価する点は let と同じですが、
BODY の中で return が使える点、ラベルを作ってジャンプできる点が異なります。

例：
  (let ((x 1)) (return x))
  =&gt; `return-from'のキャッチャを参照できません: nil

  (prog ((x 1)) (return x))
  =&gt; 1

  (prog ((x 0))
    tag
    (princ x)
    (incf x)
    (if (= x 10)
        (return x)
      (go tag)))
  -&gt; 0123456789
  =&gt; 10
</description>
<seealso>prog*</seealso>
<seealso>let</seealso>
<seealso>tagbody</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>open-stream-p</title>
<type>Function</type>
<arguments>streamp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが開いたストリームか否かを返します。
  t    OBJECTは開いたストリームです。
  nil  OBJECTはストリームでないか、閉じています。
</description>
<seealso>streamp</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-visited-p</title>
<type>Function</type>
<arguments>file-visited-p &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
BUFFER がファイル名を持つとき t となります。
デフォルトでは BUFFER は 現在のバッファです。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pipe-command</title>
<type>Function</type>
<arguments>pipe-command CMD</arguments>
<package>editor</package>
<description>
CMD を実行し、プロセスの終了を待って標準出力を *Shell output* バッファ
に出力します。[C-x @]
</description>
<seealso>execute-shell-command</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>filter-buffer</title>
<type>Function</type>
<arguments>filter-buffer COMMAND</arguments>
<package>editor</package>
<description>
バッファ全体の内容を標準入力につなげて COMMAND を実行します。[C-x #]
COMMAND の終了を待ち、終了するとバッファの内容は一旦全て消去され、
COMMAND の標準出力がバッファに出力されます。
</description>
<seealso>filter-region</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>filter-region</title>
<type>Function</type>
<arguments>filter-region COMMAND &amp;optional START END</arguments>
<package>editor</package>
<description>
リージョンの内容を標準入力につなげて COMMAND を実行します。[C-x |]
COMMAND の終了を待ち、終了するとリージョンの内容は一旦全て消去され、
COMMAND の標準出力がリージョンにに出力されます。

リージョンが指定されていないときは、COMMANDの結果を単にカーソル位置
に出力します。
</description>
<seealso>filter-buffer</seealso>
<seealso>call-process</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>command-output-send-input</title>
<type>Function</type>
<arguments>command-output-send-input &amp;optional EOL</arguments>
<package>editor</package>
<description>
現在のバッファに関連付けられたプロセスに対して、マーカーと現在行の行末
の間の文字と EOL をつなげて送ります。 EOL のデフォルトは \n です。

マーカーは、プロセスが最後に出力したバッファの位置につけられています。
</description>
<seealso>command-output-alternate-send-input</seealso>
<seealso>marker-point</seealso>
<seealso>process-send-string</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>command-output-alternate-send-input</title>
<type>Function</type>
<arguments>command-output-alternate-send-input</arguments>
<package>editor</package>
<description>
現在のバッファに関連付けられたプロセスに対して、マーカーと現在行の行末
の間の文字と \r をつなげて送ります。

マーカーは、プロセスが最後に出力したバッファの位置につけられています。
</description>
<seealso>command-output-send-input</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>command-output-mode</title>
<type>Function</type>
<arguments>command-output-mode</arguments>
<package>editor</package>
<description>
バッファを command-output-mode にします。
自動保存とundo情報を記録しなくなります。

また、以下のように設定された *command-output-mode-map* がキーマップ
として使われます。
  RET : command-output-send-input 
  C-j : command-output-alternate-send-input
</description>
<seealso>command-output-send-input</seealso>
<seealso>command-output-alternate-send-input</seealso>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>get-next-buffer</title>
<type>Function</type>
<arguments>get-next-buffer &amp;optional BUFFER REVERSE TAB-ORDER INTERNAL</arguments>
<package>editor</package>
<description>
次のバッファを返します。

  BUFFER    : 
       :top     先頭のバッファを返します。
       :bottom  最後尾のバッファを返します。
       バッファ 指定したバッファの次のバッファを返します。
  REVERSE   : non-nil なら一つ前のバッファを返します。
  TAB-ORDER : nil ならバッファの生成順で、non-nil ならバッファタブ順で
              次のバッファを返します。
  INTERNAL  : non-nil なら非表示バッファも含めて次のバッファを返します。
</description>
<seealso>next-buffer</seealso>
<seealso>buffer-list</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*scroll-bar-step*</title>
<type>Variable</type>
<arguments>*scroll-bar-step*</arguments>
<package>editor</package>
<description>
スクロールバーについている▲・▼ボタンを押したときのスクロール量です。
デフォルトは 2 です。
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>internal-time-units-per-second</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
get-internal-real-time で取得した値の、1秒あたりの量を表します。
Windowsの種類により、この値が変わるかどうかは不明です。
</description>
<seealso>get-internal-real-time</seealso>
<link></link>
<section>日付・時間</section>
<file></file>
</chapter>

<chapter>
<title>string-looking-at</title>
<type>Function</type>
<arguments>string-looking-at REGEXP STRING &amp;key :start :end :case-fold</arguments>
<package>editor</package>
<description>
STRING が、REGEXP とマッチするかを調べます。

string-match は、REGEXP が STRING のどこかにマッチすれば、その位置を返し
ますが、string-looking-at は指定された位置でマッチするかを返します。

  :start       : チェックする文字列の開始位置を指定します。
                 適正な値でないとき、戻り値は nil となります。
  :end         : チェックする文字列の終了位置を指定します。
                 適正な値でないとき、戻り値は nil となります。
  :case-fold   : ASCII 文字の大文字小文字の区別の方法を指定します。
                 REGEXP が[コンパイル済み正規表現]の場合は、:case-fold
                 指定は意味を持ちません。
        nil     - 大文字小文字を区別して検索します。
        :smart  - REGEXP に大文字が含まれていない場合、大文字小文字を区
                  別せずに検索します。
        上記以外- 大文字小文字を区別せずに検索します。

例:
  (string-looking-at "a+b" "aaab")
  =&gt; 0

  (string-looking-at "a+b" "baaab")
  =&gt; nil

  (string-looking-at "a+b" "aaab" :start 2)
  =&gt; 2

  (string-looking-at "a+b" "aaab" :start 3 :end 6)
  =&gt; nil

  (string-looking-at "a+b" "AaAAB" :case-fold :smart)
  =&gt; 0
</description>
<seealso>string-match</seealso>
<seealso>string-matchp</seealso>
<seealso>looking-at</seealso>
<seealso>match-string</seealso>
<seealso>正規表現の表記</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compare-buffer-substrings</title>
<type>Function</type>
<arguments>compare-buffer-substrings BUFFER1 START1 END1 BUFFER2 START2 END2 &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
BUFFER1 と BUFFER2 の指定された区間の内容が等しいか比べます。
両者の内容が与えられた区間のうち短い方の長さの間等しいとき、
戻り値の絶対値はその長さ + 1 です。
戻り値が 0 となる事はありません。

  CASE-FOLD : non-nil で、大文字・小文字を区別しません。
</description>
<seealso>compare-windows</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-marker</title>
<type>Function</type>
<arguments>process-marker PROCESS</arguments>
<package>editor</package>
<description>
プロセスに関連付けられたマーカーを返します。
プロセスの出力はマーカー位置に挿入され、
マーカー位置は挿入したテキスト長だけ進みます。

process-filter をセットした場合は、マーカーに対する処理は起こりません。
必要な場合は、通常 process-filter で自分で処理します。
プロセスに関連付けられたマーカーは、 delete-marker で削除することはできません。
</description>
<seealso>make-marker</seealso>
<seealso>make-process</seealso>
<seealso>delete-marker</seealso>
<seealso>process-filter</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>convert-encoding-to-internal</title>
<type>Function</type>
<arguments>convert-encoding-to-internal ENCODING INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>editor</package>
<description>
与えられた文字列やストリームをENCODINGから内部コードに変換します。

　ENCODING               : 入力ストリームのエンコーディング
                           encoding.lに大量に定義してある
                           *encoding-euc-jp*などやdetect-char-encodingの
                           戻り値を利用するのも良いでしょう
  INPUT-STRING-OR-STREAM : 変換する文字列またはストリーム
  OUTPUT-STREAM          : 出力するストリーム

戻り値は以下の通りです。

  文字列 OUTPUT-STREAMがnilの時(指定しないときもnilとみなされます)
  t      ストリームに出力したとき
</description>
<seealso>convert-encoding-from-internal</seealso>
<seealso>detect-char-encoding</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>convert-encoding-from-internal</title>
<type>Function</type>
<arguments>convert-encoding-from-internal ENCODING INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<package>editor</package>
<description>
与えられた文字列やストリームを内部コードからENCODINGに変換します。

　ENCODING               : 出力ストリームのエンコーディング
                           encoding.lに大量に定義してある*encoding-euc-jp*など
  INPUT-STRING-OR-STREAM : 変換する文字列またはストリーム
  OUTPUT-STREAM          : 出力するストリーム

戻り値は以下の通りです。

  文字列 OUTPUT-STREAMがnilの時(指定しないときもnilとみなされます)
  t      ストリームに出力したとき
</description>
<seealso>convert-encoding-to-internal</seealso>
<seealso>detect-char-encoding</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-shortcut-to-desktop</title>
<type>Function</type>
<arguments>create-shortcut-to-desktop PATH &amp;rest REST</arguments>
<package>editor</package>
<description>
デスクトップに PATH へのショートカットを作ります。
</description>
<seealso>create-shortcut</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>save-all-buffers-kill-xyzzy</title>
<type>Function</type>
<arguments>save-all-buffers-kill-xyzzy</arguments>
<package>editor</package>
<description>
すべてのバッファを保存して xyzzy を終了します。
save-all-buffers と kill-xyzzy の組み合わせです。
</description>
<seealso>save-buffers-kill-xyzzy</seealso>
<seealso>kill-xyzzy</seealso>
<seealso>save-some-buffers</seealso>
<seealso>save-all-buffers</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>save-all-buffers</title>
<type>Function</type>
<arguments>save-all-buffers</arguments>
<package>editor</package>
<description>
すべてのバッファを保存します。
ファイル名があるバッファに対しては確認せずに保存します。
ファイル名がないバッファに対しては、ダイアログで保存するファイルを指定させます。
</description>
<seealso>save-all-buffers-kill-xyzzy</seealso>
<seealso>save-some-buffers</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>save-buffers-kill-xyzzy</title>
<type>Function</type>
<arguments>save-buffers-kill-xyzzy &amp;optional VERBOSE</arguments>
<package>editor</package>
<description>
開いているバッファを保存して xyzzy を終了します。
save-some-buffers と kill-xyzzy の組み合わせです。

  VERBOSE : non-nil の場合保存するファイルごとにダイアログを表示して確認します。
</description>
<seealso>save-all-buffers-kill-xyzzy</seealso>
<seealso>kill-xyzzy</seealso>
<seealso>save-some-buffers</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>new-file</title>
<type>Function</type>
<arguments>new-file</arguments>
<package>editor</package>
<description>
ファイルに関連付けられていない新しいバッファ *untitled* を作ります。
</description>
<seealso>get-buffer-create</seealso>
<seealso>create-new-buffer</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>append-file</title>
<type>Function</type>
<arguments>append-file FILENAME &amp;optional NOMSG CHAR-ENCODING EOL-CODE</arguments>
<package>editor</package>
<description>
バッファの内容を FILENAME に追加書き込みします。
write-file で APPEND を non-nil にした場合と同じです。

  NOMSG         : non-nil ならステータスバーに経過メッセージを表示しません。
  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。
</description>
<seealso>write-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>save-buffer</title>
<type>Function</type>
<arguments>save-buffer &amp;optional CHAR-ENCODING EOL-CODE</arguments>
<package>editor</package>
<description>
バッファの内容を、バッファに関連付けられたファイルに書き込みます。[C-x C-s]

バッファに変更が無かった場合は何もしません。
バッファに変更があり、関連付けられたファイルがない場合、エラーになります。

  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。
</description>
<seealso>emacs-write-file</seealso>
<seealso>write-file</seealso>
<seealso>*before-save-buffer-hook*</seealso>
<seealso>*after-save-buffer-hook*</seealso>
<seealso>*save-buffer-no-filenames-hook*</seealso>
<seealso>make-backup-files</seealso>
<seealso>buffer-truncated-p</seealso>
<seealso>buffer-modified-p</seealso>
<seealso>save-all-buffers</seealso>
<seealso>save-some-buffers</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>emacs-write-file</title>
<type>Function</type>
<arguments>emacs-write-file FILENAME</arguments>
<package>editor</package>
<description>
バッファの内容を FILENAME に書き込みます。
同時にバッファ名およびバッファに関連付けられたファイルも変更します。
</description>
<seealso>save-buffer</seealso>
<seealso>write-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>write-file</title>
<type>Function</type>
<arguments>write-file FILENAME &amp;optional NOMSG APPEND CHAR-ENCODING EOL-CODE</arguments>
<package>editor</package>
<description>
バッファの内容を FILENAME に書き込みます。[C-x C-w]
バッファ名およびバッファに関連付けられたファイルは変更しません。

  NOMSG         : non-nil ならステータスバーに経過メッセージを表示しません。
  APPEND        : non-nil ならファイルに追加します。
  CHAR-ENCODING : エンコーディングを指定します。
  EOL-CODE      : 改行コードを指定します。
</description>
<seealso>append-file</seealso>
<seealso>save-buffer</seealso>
<seealso>emacs-write-file</seealso>
<seealso>*default-write-file-directory*</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>read-file</title>
<type>Function</type>
<arguments>read-file FILENAME &amp;optional ENCODING NOMSG</arguments>
<package>editor</package>
<description>
バッファをクリアして FILENAME の内容を書き込みます。[C-x C-r]
バッファ名およびバッファに関連付けられたファイルは変更しません。

  ENCODING : エンコーディングを指定します。
  NOMSG    : non-nil ならステータスバーに経過メッセージを表示しません。
</description>
<seealso>find-file</seealso>
<seealso>insert-file-contents</seealso>
<seealso>insert-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-file-read-only</title>
<type>Function</type>
<arguments>find-file-read-only FILENAME &amp;optional ENCODING NOMSG</arguments>
<package>editor</package>
<description>
ファイル FILENAME を read-only で開きます。
FILENAME はファイルのリストであってもかまいません。

すでに FILENAME を読み込んでいるバッファがある場合、そのバッファを read-only に設定します。
FILENAME を読み込んでいるバッファがない場合は find-file と同様にファイルを読み込み、
バッファを read-only に設定して *find-file-hooks* を実行します。

いずれの場合も最後に *find-file-read-only-hook* を実行します。

  ENCODING : エンコーディングを指定します。
  NOMSG    : non-nil ならステータスバーに経過メッセージを表示しません。
</description>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-file-no-auto-encoding*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil なら、*auto-encoding-alist* によるエンコーディングの判定が行われず、
ファイルの先頭にエンコーディング情報(-*- Encoding: EUC-JP -*-など)が記述され
ていても無視されます。
</description>
<seealso>*auto-encoding-alist*</seealso>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*auto-encoding-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
エンコーディング判定用の連想リストです。(key . datum) の組で登録します。
find-file または find-file-read-only の際に ENCODING が指定されず、
*find-file-no-auto-encoding* が nil の時、
(string-matchp key filename) が non-nil となった場合、datum をfuncallします。
datum にはエンコーディングもしくはエンコーディングを表す文字列を返す関数を指定します。
</description>
<seealso>*find-file-no-auto-encoding*</seealso>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-file-auto-mode-function*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-file の際にモードを設定するための関数を登録します。

ファイルの先頭のパラメータ（-*- Mode: LISP -*- など）や 
*auto-mode-alist* よりも優先されます。
</description>
<seealso>*auto-mode-parameter-alist*</seealso>
<seealso>*auto-mode-alist*</seealso>
<seealso>find-file</seealso>
<link></link>
<section>モード</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*auto-mode-parameter-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイルの先頭のパラメータに対し、実行する関数を指定する alist です。
書式は (文字列 . 関数) となっています。

ファイルの先頭にパラメータ -*- aaa: bbb -*- がある場合、
"aaa" に string-equal な文字列が *auto-mode-parameter-alist* に登録されていれば、
対応する関数を "bbb" を引数にして funcall します。

デフォルト値は
  '(("mode" . find-file-auto-mode)
    ("package" . find-file-buffer-package))
です。
</description>
<seealso>*find-file-auto-mode-function*</seealso>
<seealso>*auto-mode-alist*</seealso>
<seealso>*buffer-package*</seealso>
<seealso>find-file</seealso>
<link></link>
<section>モード</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-other-file-requires-file-name*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil なら find-other-file のプロンプト時に現在のバッファ名を表示します。
</description>
<seealso>find-other-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*default-write-file-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
write-file および emacs-write-file 時のデフォルトのディレクトリを指定します。
</description>
<seealso>emacs-write-file</seealso>
<seealso>write-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>make-condition</title>
<type>Function</type>
<arguments>make-condition TYPE &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
TYPE 型のコンディションを作成して返します。
作成するだけで、エラーにはなりません。
エラーを発生させるには error などで投げる必要があります。

使用例:
  (make-condition 'simple-error)
  =&gt; #S(simple-error format-string nil format-arguments nil)
</description>
<seealso>handler-case</seealso>
<seealso>error</seealso>
<seealso>エラー処理関係</seealso>
<seealso>define-condition</seealso>
<link></link>
<section>エラー</section>
<file>condition.l</file>
</chapter>

<chapter>
<title>define-condition</title>
<type>Macro</type>
<arguments>define-condition NAME (PARENT-TYPE) &amp;rest BODY</arguments>
<package>lisp</package>
<description>
新しいコンディションを定義します。
新しく定義したコンディションは error で投げたり
handler-case で処理したりできます。

コンディションは構造体からできています。
親となるコンディションにスロットが定義されている場合、
新しいコンディションにもそれらのスロットが引き継がれます。

  NAME        : コンディションの名前
  PARENT-TYPE : 親となるコンディション
  BODY
    第一要素  コンディションに追加するスロットの名前のリスト
    それ以降  以下のどれか一つを car として持つリスト
      :documentation  コンディションの説明を設定します。
      :report         エラー報告用の関数を指定します。
      :important      important な構造体になる？（詳細不明）

使用例:
  ;; lisp/condition.l より
  (define-condition check-type-error (type-error)
    (string place)
    (:report (lambda (c s)
               (format s "`~A'の値`~S'は~:[~S~;~:*~A~]ではありません"
                       (check-type-error-place c)
                       (check-type-error-datum c)
                       (check-type-error-string c)
                       (check-type-error-expected-type c)))))

  ;; 自分で定義してみる
  (define-condition my-error (error)
    (string) ; 新しいスロット :string を追加
    (:documentation "自分で定義したコンディション")
    (:report (lambda (c s) ; c はコンディション、s は出力ストリーム
               (format s "エラーです: ~A"
                       (my-error-string c))))
    (:important t))
  =&gt; t
  (error 'my-error :string "test")
  =&gt; エラーです: test
  (documentation 'my-error 'type)
  =&gt; "自分で定義したコンディション"
</description>
<seealso>handler-case</seealso>
<seealso>error</seealso>
<seealso>エラー処理関係</seealso>
<seealso>make-condition</seealso>
<link></link>
<section>エラー</section>
<file>condition.l</file>
</chapter>

<chapter>
<title>list*</title>
<type>Function</type>
<arguments>list* &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
list とよく似て ARGS を要素とするリストを作りますが、 最後の要素だけは
コンスセルの cdr部に直接つなげます。

使用例:
  (setq a (list 1 2 3))
  =&gt; (1 2 3)            ; (1 . (2 . (3 . nil)))

  (setq b (list* 1 2 3))
  =&gt; (1 2 . 3)          ; (1 . (2 . 3))

  (setq c (list* 4 5 6 a))
  =&gt; (4 5 6 1 2 3)
</description>
<seealso>list</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>next-xyzzy-window</title>
<type>Function</type>
<arguments>next-xyzzy-window</arguments>
<package>editor</package>
<description>
次のxyzzyに移動します。
移動順は起動した順です。
</description>
<seealso>previous-xyzzy-window</seealso>
<seealso>list-xyzzy-windows</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>previous-xyzzy-window</title>
<type>Function</type>
<arguments>previous-xyzzy-window</arguments>
<package>editor</package>
<description>
前のxyzzyに移動します。
移動順は起動した順の逆です。
</description>
<seealso>next-xyzzy-window</seealso>
<seealso>list-xyzzy-windows</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-xyzzy-windows</title>
<type>Function</type>
<arguments>list-xyzzy-windows</arguments>
<package>editor</package>
<description>
起動中のxyzzyの一覧をリスト形式で返します。
  
  (list-xyzzy-windows)
  =&gt;((0 . "*scratch* - xyzzy 0.2.2.235@XYZZY") (1 . "*untitled* - xyzzy 0.2.2.235@XYZZY") (2 . "*untitled*&lt;2&gt; - xyzzy 0.2.2.235@XYZZY"))
</description>
<seealso>next-xyzzy-window</seealso>
<seealso>previous-xyzzy-window</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>activate-xyzzy-window</title>
<type>Function</type>
<arguments>activate-xyzzy-window INSTANCE</arguments>
<package>editor</package>
<description>
指定したxyzzyをアクティブにします。
  
  INSTANCE : 起動中のxyzzyに割り当てられた非負の整数
</description>
<seealso>si:*instance-number</seealso>
<seealso>list-xyzzy-windows</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lambda-list-keywords</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ラムダリストキーワードとして使えるシンボルのリストです。

参照例:
  lambda-list-keywords
  =&gt;(&amp;optional &amp;rest &amp;key &amp;aux &amp;body &amp;whole &amp;environment)
</description>
<seealso>interactive</seealso>
<link></link>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>do-external-symbols</title>
<type>Macro</type>
<arguments>do-external-symbols (VAR &amp;optional (PACKAGE () SV) RESULT-FORM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
do-symbols と似ていますが、外部シンボルのみに対して繰り返しを行います。
</description>
<seealso>do-all-symbols</seealso>
<seealso>do-symbols</seealso>
<link></link>
<section>制御構造</section>
<file>package.l</file>
</chapter>

<chapter>
<title>do-symbols</title>
<type>Macro</type>
<arguments>do-symbols (VAR &amp;optional (PACKAGE () SV) RESULT-FORM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
シンボルすべてについて繰り返しを行います。
動作としては dolist に似ています。

do-all-symbols と違って特定のパッケージだけを探します。正確にはパッケ
ージの外部シンボル・内部シンボルおよび、そのパッケージが use している
他パッケージの外部シンボルが対象になります。

  VAR           : BODY 実行中に各シンボルに束縛される変数
  PACKAGE       : シンボルを探すパッケージ (デフォルトは *package*)
  RESULT-FORM   : do-symbols の戻り値
  BODY          : 繰り返しの本体
</description>
<seealso>do-external-symbols</seealso>
<seealso>do-all-symbols</seealso>
<seealso>dolist</seealso>
<link></link>
<section>制御構造</section>
<file>package.l</file>
</chapter>

<chapter>
<title>find-all-symbols</title>
<type>Function</type>
<arguments>find-all-symbols NAME</arguments>
<package>lisp</package>
<description>
印字名が NAME であるようなシンボルを各パッケージから探します。
戻り値は見つかったシンボルのリストです。

使用例：
  (find-all-symbols "y")
  =&gt; (editor::y system::y lisp::y winapi::y)

  (find-all-symbols "system-root")
  =&gt; (system:system-root)

  (find-all-symbols "test")
  =&gt; (editor::test test :test lisp::test)
</description>
<seealso>find-symbol</seealso>
<link></link>
<section>シンボル</section>
<file>package.l</file>
</chapter>

<chapter>
<title>multiple-value-prog1</title>
<type>Special Form</type>
<arguments>multiple-value-prog1 FORM {FORM}*</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最初のフォームの結果を多値で返します。

prog1 に似ていますが、最初のフォームが多値を返した場合でも prog1 の戻
り値は多値になりません。
</description>
<seealso>prog1</seealso>
<seealso>values</seealso>
<seealso>multiple-value-bind</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>multiple-value-call</title>
<type>Special Form</type>
<arguments>multiple-value-call FUNCTION {FORM}*</arguments>
<package>lisp</package>
<description>
FORM の戻り値を引数として FUNCTION を呼びます。
apply と違って多値で返された二番目以降の戻り値も渡します。

使用例：
  (multiple-value-call #'+ (values 1 2 3) (values 4 5))
  =&gt; 15
</description>
<seealso>multiple-value-bind</seealso>
<seealso>apply</seealso>
<seealso>values</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lisp-indent-hook</title>
<type>Misc</type>
<arguments></arguments>
<package>editor</package>
<description>
シンボルにプロパティを設定することで lisp-indent-line でのインデント量を制御します。

  数値 n   : n 番目以降の引数を *lisp-body-indent* だけ、
             それより前の引数を (* *lisp-body-indent* 2) だけインデント
  nil      : 通常のインデント
             ただし1番目の引数のインデント量は *lisp-indent-offset* に従う
  それ以外 : すべての引数を *lisp-body-indention* だけインデント

使用例：
  ;;; $XYZZY/lisp/lispmode.l から
  (setf (get 'lambda 'lisp-indent-hook) 'defun)
  (setf (get 'interactive 'lisp-indent-hook) 1)
  (setf (get 'progn 'lisp-indent-hook) 0)
  (setf (get 'if 'lisp-indent-hook) 2)
  (setf (get 'let 'lisp-indent-hook) 1)
  (setf (get 'let* 'lisp-indent-hook) 1)
</description>
<seealso></seealso>
<link></link>
<section>シンボル</section>
<file></file>
</chapter>

<chapter>
<title>lisp-implementation-type</title>
<type>Function</type>
<arguments>lisp-implementation-type</arguments>
<package>lisp</package>
<description>
Lisp 処理系の実装名を返します。

使用例：
  (lisp-implementation-type)
  =&gt; "xyzzy"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lisp-implementation-version</title>
<type>Function</type>
<arguments>lisp-implementation-version</arguments>
<package>lisp</package>
<description>
Lisp 処理系のバージョンを返します。

使用例：
  (lisp-implementation-version)
  =&gt; "0.2.2.236"

補足：
  xyzzy 0.2.2.236 から利用可能です。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-alternate-file-buffer</title>
<type>Function</type>
<arguments>get-alternate-file-buffer FILENAME &amp;key (:test #'equalp)</arguments>
<package>editor</package>
<description>
ファイル名の別名が FILENAME であるようなバッファを返します。
</description>
<seealso>get-buffer-alternate-file-name</seealso>
<seealso>set-buffer-alternate-file-name</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>get-ime-mode</title>
<type>Function</type>
<arguments>get-ime-mode</arguments>
<package>editor</package>
<description>
IMEのON/OFF状態を返します。

戻り値は以下の通りです
  t   変換モード
  nil 直接入力モード
</description>
<seealso>toggle-ime</seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>html-highlight-mode</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nilならばシンタックスの :tag が利用可能になります。
</description>
<seealso>set-syntax-tag</seealso>
<seealso>parse-point-syntax</seealso>
<link></link>
<section>シンタックス</section>
<file></file>
</chapter>

<chapter>
<title>kinsoku-extend-limit</title>
<type>Function</type>
<arguments>kinsoku-extend-limit &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
禁則処理でぶら下げる文字数を返します。
</description>
<seealso>kinsoku-bol-chars</seealso>
<seealso>kinsoku-shorten-limit</seealso>
<seealso>set-kinsoku-chars</seealso>
<seealso>kinsoku-goto-column</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kinsoku-shorten-limit</title>
<type>Function</type>
<arguments>kinsoku-shorten-limit &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
禁則処理で追い出す文字数を返します。
</description>
<seealso>kinsoku-eol-chars</seealso>
<seealso>kinsoku-extend-limit</seealso>
<seealso>set-kinsoku-chars</seealso>
<seealso>kinsoku-goto-column</seealso>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-kinsoku-chars</title>
<type>Function</type>
<arguments>set-kinsoku-chars BOL-CHARS EOL-CHARS &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
禁則文字をセットします。
[ツール] - [共通設定] - [禁則処理] からでも、設定できます。

  BOL-CHARS: 行頭にきてはいけない文字の集合。
  EOL-CHARS: 行末にきてはいけない文字の集合。
  BUFFER:    nil ならば共通設定として、バッファが指定されれば
             そのバッファに対してローカルに設定。
</description>
<seealso>kinsoku-bol-chars</seealso>
<seealso>kinsoku-eol-chars</seealso>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kinsoku-eol-chars</title>
<type>Function</type>
<arguments>kinsoku-eol-chars &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
行末禁則文字の集合を文字列で返します。
</description>
<seealso>kinsoku-bol-chars</seealso>
<seealso>set-kinsoku-chars</seealso>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kinsoku-bol-chars</title>
<type>Function</type>
<arguments>kinsoku-bol-chars &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
行頭禁則文字の集合を文字列で返します。
</description>
<seealso>kinsoku-eol-chars</seealso>
<seealso>set-kinsoku-chars</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kinsoku-mode</title>
<type>Function</type>
<arguments>kinsoku-mode &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
禁則処理の状態を表す4ビットのフラグを返します。

  8: 禁則処理を行うとき t
  4: ワードラップするとき t
  2: 改行文字をぶら下げるとき t
  1: 空白文字をぶら下げるとき t
</description>
<seealso>set-kinsoku-chars</seealso>
<seealso>*fill-kinsoku-mode*</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kinsoku-goto-column</title>
<type>Function</type>
<arguments>kinsoku-goto-column COLUMN &amp;optional KINSOKU-MODE</arguments>
<package>editor</package>
<description>
COLUMN桁で禁則処理を施したときの行末に移動します。
</description>
<seealso>kinsoku-bol-chars</seealso>
<seealso>kinsoku-extend-limit</seealso>
<seealso>kinsoku-eol-chars</seealso>
<seealso>kinsoku-shorten-limit</seealso>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>extended-alphabet-char-p</title>
<type>Function</type>
<arguments>extended-alphabet-char-p CHAR</arguments>
<package>editor</package>
<description>
CHAR が欧文(ISO8859)の単語構成文字かを判定します。
</description>
<seealso>characterp</seealso>
<link></link>
<section>データ型</section>
<file></file>
<!--  builtin.l??? -->
</chapter>

<chapter>
<title>graphic-char-p</title>
<type>Function</type>
<arguments>graphic-char-p CHAR</arguments>
<package>lisp</package>
<description>
CHAR が印字文字かどうかを判定します。

  (graphic-char-p #\A)
  =&gt;t
  (graphic-char-p #\SPC)
  =&gt;t
  (graphic-char-p #\TAB)
  =&gt;nil
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>word-char-p</title>
<type>Function</type>
<arguments>word-char-p CHAR</arguments>
<package>editor</package>
<description>
CHAR が単語構成文字かどうかを判定します。
</description>
<seealso>syntax-word-p</seealso>
<seealso>characterp</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>typep</title>
<type>Function</type>
<arguments>typep OBJECT TYPE</arguments>
<package>lisp</package>
<description>
OBJECT が TYPE の型であれば、non-nil な値を返します。

TYPE に与えることのできる引数には以下のようなものがあります。

1. 一般の型 
  builtin 関数（characterp、listp など）で判定します。

  'atom                'null           'ed:buffer
  'base-character      'number         'ed:marker
  'bignum              'package        'ed:process
  'character           'random-state   'ed:regexp
  'compiled-function   'ratio          'ed:syntax-table
  'cons                'real           'ed:menu
  'fixnum              'readtable      'ed:dde-handle
  'function            'sequence       'ed:window
  'hash-table          'stream         'ed:oledata
  'keyword             'symbol
  'list

2. 条件式・複合型
  条件を満たす場合に non-nil な値を返します。

  '(satisfies FUNC)      OBJECT を引数に FUNC を funcall した結果を返す
  '(member ELEMENTS)     OBJECT が ELEMENTS に含まれる
  '(eql OBJ)             OBJECT が OBJ に等しい
  '(not TYPE1)           OBJECT が TYPE2 の型でない
  '(and TYPE1 TYPE2 ...) OBJECT が TYPE1, TYPE2, ... すべての型である
  '(or TYPE1 TYPE2 ...)  OBJECT が TYPE1, TYPE2, ... いずれかの型である
  't                     常に真
  'nil                   常に偽

3. 文字
  'standard-char         文字のうち standard-char-p なもの
  'extended-char (*)     常に nil を返す（extended-char は存在しない？）

4. 数値
  範囲を指定できます。省略することも可能。
  MIN および MAX に、数値の代わりに * を与えると、
  下限（上限）を指定しなかったとみなされます。

  '(integer MIN MAX)
  '(float MIN MAX)
  '(rational MIN MAX)
  '(short-float MIN MAX)
  '(single-float MIN MAX)
  '(double-float MIN MAX)
  '(long-float MIN MAX)

  '(complex TYPE1)      integer 型、float 型などで区別可能。範囲指定はできない。

5. 一次元配列
  長さを指定できます。
  長さには整数値か * を指定します。省略も可能。

  '(simple-vector LENGTH)
  '(simple-string LENGTH)
  '(string LENGTH)
  
  '(vector TYPE1 LENGTH)       TYPE1 は t（普通のベクタ）または character（文字列）
  
6. 一次元以上の配列
  '(simple-array TYPE1 DIM)    TYPE1 は t（普通のベクタ）または character（文字列）
  '(array TYPE1 DIM)           DIM は次元

  '(simple-array TYPE1 (DIMS)) TYPE1 は t（普通のベクタ）または character（文字列）
  '(array TYPE1 (DIMS))        DIMS は各次元のサイズ（たとえば 2x3 なら (2 3) ）

7. defstruct で定義された構造体

使用例:
  ;; 一般の型
  (typep #\a 'character)
  =&gt; t
  (typep (selected-buffer) 'buffer)
  =&gt; t

  ;; 複合型
  (typep 3 '(satisfies oddp))       ; 奇数（関数 oddp による判定）
  =&gt; t
  (typep 'b '(member a b c))        ; a b c がリストとしてまとめられる
  =&gt; (b c)
  (typep 3 '(and atom number))      ; atom かつ number
  =&gt; t
  (typep 3 '(and atom number list)) ; atom かつ number かつ list
  =&gt; nil
  (typep 3 '(or atom number list))  ; atom または number または list
  =&gt; t

  ;; 数値
  (typep 3 'integer)                ; 範囲指定しないならリストにする必要なし
  =&gt; t
  (typep 3 '(integer 1 5))
  =&gt; t
  (typep x '(integer * 5))
  =&gt; t
  (typep x '(integer 5 *))
  =&gt; nil
  
  (typep #C(1 2) 'complex)
  =&gt; t
  (typep #C(1 2) '(complex float))
  =&gt; nil

  ;; 一次元配列
  (typep #(1 2 3) '(simple-vector 3))
  =&gt; t
  (typep #(1 2 3) '(vector t 3))
  =&gt; t
  (typep "abc" '(vector character 3))
  =&gt; t

  ;; 一次元以上の配列
  (setf a (make-array '(3 4)))
  =&gt; #2A((nil nil nil nil) (nil nil nil nil) (nil nil nil nil))
  (typep a '(array t *))     ; 次元を指定しない
  =&gt; t
  (typep a '(array t 2))     ; 2 次元配列
  =&gt; t
  (typep a '(array t (3 4))) ; サイズも一致
  =&gt; t
  (typep a '(array t (* 4))) ; サイズの一部だけを指定することも可能
  =&gt; t

  ;; 構造体
  (typep (selected-pseudo-frame) 'ed::pseudo-frame)
  =&gt; t
</description>
<seealso>si:canonicalize-type</seealso>
<seealso>type-of</seealso>
<seealso>subtypep</seealso>
<seealso>deftype</seealso>
<seealso>型一覧</seealso>
<link></link>
<section>データ型</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>deftype</title>
<type>Macro</type>
<arguments>deftype NAME (&amp;rest LAMBDA-LIST) &amp;rest BODY</arguments>
<package>lisp</package>
<description>
NAME と言う名前のデータ型を定義します。
定義したデータ型は typep や subtypep などで使うことができます。
ただし typep で使う場合には、使用前に si:canonicalize-type で
処理することが必要なようです。

使用例:
  ;; lisp/typespec.l より
  ;; mod という型を定義
  (deftype mod (n)
    `(integer 0 ,(1- n))) ; 0 以上 n 未満の整数
  (typep 3 (si:canonicalize-type '(mod 5)))
  =&gt; t

  ;; 奇数型を作ってみる
  (deftype odd ()
    `(and integer
          (satisfies oddp)))
  (typep 3 (si:canonicalize-type 'odd))
  =&gt; t
  (subtypep 'odd 'integer)
  =&gt; t
  =&gt; t
</description>
<seealso>si:canonicalize-type</seealso>
<seealso>subtypep</seealso>
<seealso>typep</seealso>
<seealso>型一覧</seealso>
<link></link>
<section>データ型</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>si:canonicalize-type</title>
<type>Function</type>
<arguments>canonicalize-type TYPE</arguments>
<package>system</package>
<description>
deftype で宣言されたデータ型 TYPE を展開し、標準の型に直します。

たとえば typep は標準の型しか処理しないため、
deftype で宣言された型を使いたい場合にはこの関数で処理する必要があります。

使用例:
  (si:canonicalize-type '(mod 5))
  =&gt; (integer 0 4)
</description>
<seealso>deftype</seealso>
<seealso>typep</seealso>
<link></link>
<section>データ型</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>filer-cancel</title>
<type>Function</type>
<arguments>filer-cancel</arguments>
<package>editor</package>
<description>
ファイラを閉じます。
「閉じる」ボタンや「キャンセルボタン」を押したときと同じ効果が得られます。

(defun filer-cancel ()
 (filer-close nil))
と定義されています。
<!--
例:
  ;;; ESCキーでファイラを閉じる
  (define-key filer-keymap #\ESC 'filer-cancel) -->
</description>
<seealso>filer-close</seealso>
<link></link>
<section>ファイラ</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>set-dispatch-macro-character</title>
<type>Function</type>
<arguments>set-dispatch-macro-character DISP-CHAR SUB-CHAR FUNCTION &amp;optional READTABLE</arguments>
<package>lisp</package>
<description>
ディスパッチマクロ文字を設定します。
SUB-CHAR は大文字小文字を区別しません。

DISP-CHAR がディスパッチマクロ文字でなければエラーとなります。
また SUB-CHAR に [0-9] は指定できません。
</description>
<seealso>make-dispatch-macro-character</seealso>
<seealso>get-dispatch-macro-character</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-dispatch-macro-character</title>
<type>Function</type>
<arguments>make-dispatch-macro-character CHAR &amp;optional NON-TERMINATING-P READTABLE</arguments>
<package>lisp</package>
<description>
ディスパッチマクロ文字を新たに作成します。
CHAR が既にディスパッチマクロ文字であれば何もしません。
</description>
<seealso>set-dispatch-macro-character</seealso>
<seealso>get-dispatch-macro-character</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-dispatch-macro-character</title>
<type>Function</type>
<arguments>get-dispatch-macro-character DISP-CHAR SUB-CHAR &amp;optional READTABLE</arguments>
<package>lisp</package>
<description>
ディスパッチマクロを取得します。
SUB-CHAR は大文字小文字を区別しません。

DISP-CHAR がディスパッチマクロ文字でなければエラーとなります。
</description>
<seealso>make-dispatch-macro-character</seealso>
<seealso>set-dispatch-macro-character</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-macro-character</title>
<type>Function</type>
<arguments>get-macro-character CHAR &amp;optional READTABLE</arguments>
<package>lisp</package>
<description>
マクロ文字 CHAR に割り当てられている関数を返します。マクロ文字でない
場合は nil を返します。
また、マクロ文字である場合には二番目の戻り値として CHAR が 
non-terminating かどうかを返します。

使用例：
  ;;; # は non-terminating macro character
  (get-macro-character #\#)
  =&gt; system:|#-reader|
  =&gt; t
  ;;; ' は terminating macro character
  (get-macro-character #\')
  =&gt; system:|'-reader|
  =&gt; nil
  ;;; A はマクロ文字ではない
  (get-macro-character #\A)
  =&gt; nil
</description>
<seealso>set-macro-character</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:*set-readtable-case</title>
<type>Function</type>
<arguments>*set-readtable-case READTABLE CASE</arguments>
<package>system</package>
<description>
READTABLE の case sensitivity を CASE に設定します。
</description>
<seealso>readtable-case</seealso>
<seealso>*readtable*</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>readtable-case</title>
<type>Function</type>
<arguments>readtable-case READTABLE</arguments>
<package>lisp</package>
<description>
READTABLE の case sensitivity を返します。
この値はシンボルの read および print の際の挙動に影響します。

戻り値
  :upcase       read の際にアルファベットを大文字に変換
                print の際に小文字を含むシンボル名をエスケープ
  :downcase     read の際にアルファベットを小文字に変換
                print の際に大文字を含むシンボル名をエスケープ
  :preserve     大文字小文字の変換・エスケープをしない (デフォルト)
  :invert       read 時は :preserve と同じ？
                print の際にアルファベットを含むシンボル名をエスケープ

リードテーブルの case sensitivity を変更するには si:*set-readtable-case
または setf を使います。

例:
  (let ((*readtable* (copy-readtable *readtable*)))
    (dolist (rtc '(:upcase :downcase :preserve :invert))
      (setf (readtable-case *readtable*) rtc)
      (print (read-from-string "Foo"))))
  -&gt; FOO
  -&gt; foo
  -&gt; Foo
  -&gt; |Foo|
  =&gt; nil
</description>
<seealso>si:*set-readtable-case</seealso>
<seealso>*readtable*</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*readtable*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
現在のリードテーブルを格納している変数です。
</description>
<seealso>si:*set-readtable-case</seealso>
<seealso>readtable-case</seealso>
<seealso>readtablep</seealso>
<seealso>copy-readtable</seealso>
<seealso>*ole-readtable*</seealso>
<link></link>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>copy-readtable</title>
<type>Function</type>
<arguments>copy-readtable &amp;optional FROM-READTABLE TO-READTABLE</arguments>
<package>lisp</package>
<description>
リードテーブルをコピーします。

  FROM-READTABLE : コピー元 (デフォルトは *readtable*)
                   nil を明示的に与えるとデフォルトのリードテーブルをコピー。
  TO-READTABLE   : コピー先。省略時は新しく作成。
</description>
<seealso>*readtable*</seealso>
<seealso></seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>readtablep</title>
<type>Function</type>
<arguments>readtablep OBJECT</arguments>
<package>lisp</package>
<description>
OBJECT がリードテーブルなら t 、それ以外なら nil を返します。
</description>
<seealso>*readtable*</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>execute-region</title>
<type>Function</type>
<arguments>execute-region FROM TO</arguments>
<package>editor</package>
<description>
リージョンの内容をバッチファイルとして実行します。
</description>
<seealso></seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>run-console</title>
<type>Function</type>
<arguments>run-console</arguments>
<package>editor</package>
<description>
xyzzy の外部でコンソールを起動します。
変数 *eshell* または *shell* の値が実行されるコマンドとして使われます。
</description>
<seealso></seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>launch-application</title>
<type>Function</type>
<arguments>launch-application APP</arguments>
<package>editor</package>
<description>
プログラムを xyzzy の外部で実行します。
</description>
<seealso></seealso>
<link></link>
<section>プロセス</section>
<file>dialogs.l</file>
</chapter>

<chapter>
<title>process-send-n</title>
<type>Function</type>
<arguments>process-send-n</arguments>
<package>editor</package>
<description>
バッファに結び付けられているプロセスに "n\n" を送ります。
</description>
<seealso>process-send-y</seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>process-send-y</title>
<type>Function</type>
<arguments>process-send-y</arguments>
<package>editor</package>
<description>
バッファに結び付けられているプロセスに "y\n" を送ります。
</description>
<seealso>process-send-n</seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>read-as-string</title>
<type>Function</type>
<arguments>read-as-string STREAM &amp;optional EOF-ERROR-P EOF-VALUE</arguments>
<package>editor</package>
<description>
ストリームからトークンを読み込んで文字列として返します。
マクロ文字やエスケープ文字は読み取りません。
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-line-into</title>
<type>Function</type>
<arguments>read-line-into STRING &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE</arguments>
<package>editor</package>
<description>
指定された入力ストリームから一行読み込んで、指定された文字列に格納します。
格納先の文字列は破壊されます。

  STRING       : 結果を埋め込む先の文字列。
                 フィルポインタを持ち、かつアジャスタブルでなければならない
  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : non-nil なら、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値

INPUT-STREAM が終端に達していた場合を除いて戻り値は STRING です。
また二つ目の戻り値として、改行文字を読み込んだ場合は nil を、終端に達
した場合は t を返します。

使用例：
  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0 :adjustable t)))
    (read-line-into x (make-string-input-stream "abcdef")))
  =&gt; "abcdef"
  =&gt; t

  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0 :adjustable t)))
    (read-line-into x (make-string-input-stream "abc\ndef")))
  =&gt; "abc"
  =&gt; nil
</description>
<seealso>read-line</seealso>
<seealso>read-into</seealso>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-into</title>
<type>Function</type>
<arguments>read-into STRING &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE MAX-LENGTH</arguments>
<package>editor</package>
<description>
指定された入力ストリームから文字列を読み込み、指定された文字列に格納します。
結果の書き込みは破壊的に行われます。

  STRING       : 結果を格納する文字列。フィルポインタを持たなければならない
  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : non-nil なら、入力ストリームが終端に達しているとエラー
  EOF-VALUE    : 入力ストリームが最初から終端に達していた場合の戻り値
  MAX-LENGTH   : 読み込む長さの上限。デフォルトは STRING の本来の長さ

INPUT-STREAM が終端に達していた場合を除いて戻り値は STRING です。

使用例：
  (let ((x (make-vector 2 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef")))
  =&gt; "ab"

  (let ((x (make-vector 10 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef")))
  =&gt; "abcdef"

  (let ((x (make-vector 10 :element-type 'character :fill-pointer 0)))
    (read-into x (make-string-input-stream "abcdef") t nil 3))
  =&gt; "abc"
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-delimited-list</title>
<type>Function</type>
<arguments>read-delimited-list CHAR &amp;optional INPUT-STREAM RECURSIVE-P</arguments>
<package>lisp</package>
<description>
指定した文字が現れるまで Lisp オブジェクトを読み込み、結果のリストを返します。

  CHAR         : リストの終わりを表す文字
  INPUT-STREAM : 入力元のストリーム
  RECURSIVE-P  : nil ならトップレベル、non-nil なら再帰呼び出しとして読み込む
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-preserving-whitespace</title>
<type>Function</type>
<arguments>read-preserving-whitespace &amp;optional IN-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
ストリームから Lisp のオブジェクトを読み込んで返します。
read とほぼ同じですが、読んだ最後の文字が空白文字だった場合、その文字を
ストリームへ戻します。
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-from-char</title>
<type>Function</type>
<arguments>set-syntax-from-char TO-CHAR FROM-CHAR &amp;optional TO-READTABLE FROM-READTABLE</arguments>
<package>lisp</package>
<description>
文字のシンタックスを変更します。
lisp のリーダの挙動が変わります。

  TO-CHAR        : シンタックスを変更する文字
  FROM-CHAR      : 設定するシンタックスを持つ文字
  TO-READTABLE   : 変更するリードテーブル (指定しなければ *readtable*)
  FROM-READTABLE : 変更元のリードテーブル (指定しなければデフォルトのリードテーブル)

使用例：
  ;;; カンマを whitespace として扱うようにしてみる
  (let ((readtab (copy-readtable)))
    (set-syntax-from-char #\, #\SPC readtab *readtable*)
    (let ((*readtable* readtab))
      (read-from-string "(a,b,c)")))
  =&gt; (a b c)
  =&gt; 7
</description>
<seealso></seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-eol-code</title>
<type>Function</type>
<arguments>buffer-eol-code &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの改行コードを返します。変更する場合はset-buffer-eol-codeを使用
します。

 BUFFER: 改行コードを返すバッファ
         指定が無ければ現在のバッファ

戻り値:
  0  *eol-lf*   LF
  1  *eol-cr*   CR
  2  *eol-crlf* CRLF
</description>
<seealso>set-buffer-eol-code</seealso>
<seealso>*default-eol-code*</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>integer-length</title>
<type>Function</type>
<arguments>integer-length INTEGER</arguments>
<package>lisp</package>
<description>
2進数で表した時の長さを返します。

使用例:
  (integer-length 7) =&gt; 3 ; #b00000111
  (integer-length 8) =&gt; 4 ; #b00001000
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lognot</title>
<type>Function</type>
<arguments>lognot INTEGER</arguments>
<package>lisp</package>
<description>
INTEGERの1の補数(2進数表現で0と1を反転させたもの)を返します。

使用例:
  ;;; INTEGER 00000011
  ;;; 反転    11111100
  ;;; 1の補数 00000011
  ;;; 2の補数 00000100
  (lognot #b0011)
  =&gt; -4
  (format nil "~8,'0b" -4)
  =&gt; "0000-100"
  (format nil "~4,'0b" (lognot -4))
  =&gt; "0011"
</description>
<seealso>logand</seealso>
<seealso>logor</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>logxor</title>
<type>Function</type>
<arguments>logxor &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎の排他的論理和を返します。

使用例:
  (format nil "~4,'0b" (logxor #b0011 #b0101))
  =&gt; "0110"
</description>
<seealso>logeqv</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logeqv</title>
<type>Function</type>
<arguments>logeqv &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎の論理等価を返します。

使用例:
  (format nil "~4,'0b" (logeqv #b0011 #b0101))
  =&gt; "-111"
  (format nil "~4,'0b" (lognot (logxor #b0011 #b0101)))
  =&gt; "-111"
</description>
<seealso>logxor</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>lognand</title>
<type>Function</type>
<arguments>lognand X Y</arguments>
<package>lisp</package>
<description>
ビット毎の否定的論理積(NAND)を返します。

使用例:
  ;;; X        0011
  ;;; Y        0101
  ;;; AND      0001
  ;;; NAND     1110
  ;;; 1の補数  0001
  ;;; 2の補数  0010
  (format nil "~4,'0b" (lognand #b0011 #b0101))
  =&gt; "0-10"
  (format nil "~4,'0b" (lognot (logand #b0011 #b0101)))
  =&gt; "0-10"
</description>
<seealso>logand</seealso>
<seealso>lognor</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logandc1</title>
<arguments>logandc1 X Y</arguments>
<package>lisp</package>
<description>
Xの1の補数 と Y のビット毎の論理積を返します。

使用例:
  (format nil "~4,'0b" (logandc1 #b0011 #b0101))
  =&gt; "0100"
  (format nil "~4,'0b" (logand (lognot #b0011) #b0101))
  =&gt; "0100"
</description>
<seealso>logand</seealso>
<seealso>logandc2</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logandc2</title>
<arguments>logandc2 X Y</arguments>
<package>lisp</package>
<description>
X と Yの1の補数 のビット毎の論理積を返します。

使用例:
  (format nil "~4,'0b" (logandc2 #b0011 #b0101))
  =&gt; "0010"
  (format nil "~4,'0b" (logand #b0011 (lognot #b0101)))
  =&gt; "0010"
</description>
<seealso>logand</seealso>
<seealso>logandc1</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logorc1</title>
<type>Function</type>
<arguments>logorc1 X Y</arguments>
<package>lisp</package>
<description>
Xの1の補数 と Y のビット毎の論理和を返します。

使用例:
  (format nil "~4,'0B" (logorc1 #b0011 #b0101))
  =&gt; "0-11"
  (format nil "~4,'0b" (logior (lognot #b0011) #b0101))
  =&gt; "0-11"
</description>
<seealso>logior</seealso>
<seealso>logorc2</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>logorc2</title>
<type>Function</type>
<arguments>logorc2 X Y</arguments>
<package>lisp</package>
<description>
X と Yの1の補数 のビット毎の論理和を返します。

使用例:
  (format nil "~4,'0B" (logorc2 #b0011 #b0101))
  =&gt; "-101"
  (format nil "~4,'0b" (logior #b0011 (lognot #b0101)))
  =&gt; "-101"
</description>
<seealso>logior</seealso>
<seealso>logorc1</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>lognor</title>
<type>Function</type>
<arguments>lognor X Y</arguments>
<package>lisp</package>
<description>
ビット毎の否定的論理和(NOR)を返します。

使用例:
  ;;; X        0011
  ;;; Y        0101
  ;;; OR       0111
  ;;; NOR      1000
  ;;; 1の補数  0111
  ;;; 2の補数  1000
  (format nil "~4,'0b" (lognor #b0011 #b0101))
  =&gt; "-1000"
  (format nil "~4,'0b" (lognot (logior #b0011 #b0101)))
  =&gt; "-1000"
</description>
<seealso>logior</seealso>
<seealso>lognand</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>*local-abbrev-table*</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファごとのabbrev-tableを設定します。
ここでの定義は*global-abbrev-table*よりも優先して使用されます。
</description>
<seealso>expand-abbrev</seealso>
<seealso>*global-abbrev-table*</seealso>
<seealso>define-abbrev-table</seealso>
<link></link>
<section>テキスト</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>*global-abbrev-table*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
グローバルなabbrev-tableを設定します。
</description>
<seealso>expand-abbrev</seealso>
<seealso>*local-abbrev-table*</seealso>
<seealso>define-abbrev-table</seealso>
<link></link>
<section>テキスト</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>defparameter</title>
<type>Macro</type>
<arguments>defparameter NAME VALUE &amp;optional DOC</arguments>
<package>lisp</package>
<description>
グローバルなスペシャル変数を宣言し、指定した値に設定します。
defvar に似ていますが、VALUE は省略できません。
また NAME がすでに値を持つ場合でも VALUE が評価され、結果が変数値として
設定されます。
</description>
<seealso>defvar</seealso>
<link></link>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>go</title>
<type>Special Form</type>
<arguments>go TAG</arguments>
<package>lisp</package>
<description>
tagbody や prog の中で指定されたタグへジャンプします。

使用例:
  ;;; dotimes 相当のループを tagbody と go で書いてみる
  (let ((x 0) (sum 0))
    (tagbody
      start
      (setq sum (+ sum x)
            x (1+ x))
      (if (&lt;= x 10) (go start)))
    sum)
  =&gt; 55
</description>
<seealso>tagbody</seealso>
<seealso>prog</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*default-eol-code*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
新規に作ったバッファの改行コードのデフォルト値です。
</description>
<seealso>buffer-eol-code</seealso>
<seealso>*default-fileio-encoding*</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*default-fileio-encoding*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
新規に作ったバッファの文字エンコーディングのデフォルト値です。
</description>
<seealso>buffer-fileio-encoding</seealso>
<seealso>*default-eol-code*</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>set-meta-bit</title>
<type>Function</type>
<arguments>set-meta-bit CHAR SET</arguments>
<package>editor</package>
<description>
CHAR を Meta付き、無しの文字に相互変換します。

  SET: non-nil の時、CHAR の Meta付きの文字を返します。
       nil の時、    CHAR の Meta無しの文字を返します。

例:
  (set-meta-bit #\S-C-Right t)
  =&gt;#\S-C-M-Right
  
  (set-meta-bit #\M-S-C-Right nil)
  =&gt;#\S-C-Right
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*inhibit-quit*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
この値が t のとき、 quit-char を入力しても無視されます。
</description>
<seealso>quit-char</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>call-menu</title>
<type>Function</type>
<arguments>call-menu N</arguments>
<package>editor</package>
<description>
「ファイル(F)」「編集(E)」といったメニューの N 番目の項目を開きます。
N には 0 オリジンで位置を指定します。
すなわち 0 を指定したときは通常「ファイル(F)」のメニューを開きます。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*buffer-package*</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイルの先頭のパラメータリストの Package で指定したパッケージ名が保
存されます。
</description>
<seealso>*auto-mode-parameter-alist*</seealso>
<link></link>
<section>バッファ</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>command-keys</title>
<type>Function</type>
<arguments>command-keys COMMAND GLOBAL-KEYMAP LOCAL-KEYMAP &amp;optional MINOR-MODE-KEYMAPS</arguments>
<package>editor</package>
<description>
指定した関数にバインドされたキーのリストを返します。
MINOR-MODE-KEYMAPS LOCAL-KEYMAP GLOBAL-KEYMAPの順に優先されます。

使用例:
  (command-keys 'undo *global-keymap* (local-keymap) (minor-mode-map))
  =&gt; (#\C-\\ #\End)
</description>
<seealso>lookup-keymap</seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>key-to-string</title>
<type>Function</type>
<arguments>key-to-string KEY &amp;optional ESC-TO-META</arguments>
<package>editor</package>
<description>
キーを読みやすいように文字列に変換します。

  ESC-TO-META : non-nilならESCをM-に変換します

使用例:
  (key-to-string '(#\ESC #\C-a))    =&gt; "ESC C-a"
  (key-to-string '(#\ESC #\C-a) t)  =&gt; "M-C-a"
</description>
<seealso></seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>lookup-keymap</title>
<type>Function</type>
<arguments>lookup-keymap KEYMAP KEY &amp;optional IGNORE-CASE SYMBOL-ONLY</arguments>
<package>editor</package>
<description>
指定したキーマップの中で指定したキーにバインドされた関数を返します。
</description>
<seealso>command-keys</seealso>
<seealso>lookup-key-command</seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lookup-key-command</title>
<type>Function</type>
<arguments>lookup-key-command KEY</arguments>
<package>editor</package>
<description>
指定したキーに設定された関数を返します。
lookup-keymapを使って実装されています。
</description>
<seealso>lookup-keymap</seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>region-end</title>
<type>Function</type>
<arguments>region-end</arguments>
<package>editor</package>
<description>
リージョンの終端のポイントを返します。

  ; markやpointとの関係
  (= (region-end) (max (mark) (point)))
  =&gt;t
</description>
<seealso>region-beginning</seealso>
<seealso>selection-point</seealso>
<seealso>mark</seealso>
<seealso>point</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>region-beginning</title>
<type>Function</type>
<arguments>region-beginning</arguments>
<package>editor</package>
<description>
リージョンの開始のポイントを返します。

  ; markやpointとの関係
  (= (region-beginning) (min (mark) (point)))
  =&gt;t
</description>
<seealso>region-end</seealso>
<seealso>selection-mark</seealso>
<seealso>mark</seealso>
<seealso>point</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>deposit-field</title>
<type>Function</type>
<arguments>deposit-field NEWBYTE BYTESPEC INTEGER</arguments>
<package>lisp</package>
<description>
指定されたフィールドを NEWBYTE の同じフィールドの内容で置き換えた値を返
します。

使用例：
  (format nil "~2,'0x" (deposit-field #x0f (byte 4 4) #xa7))
  =&gt;"07"
  (format nil "~2,'0x" (deposit-field #xaa (byte 4 4) #x0f))
  =&gt;"af"
</description>
<seealso>ldb</seealso>
<seealso>dpb</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>dpb</title>
<type>Function</type>
<arguments>dpb NEWBYTE BYTESPEC INTEGER</arguments>
<package>lisp</package>
<description>
指定されたフィールドを NEWBYTE で置き換えた値を返します。

使用例：
  (format nil "~2,'0x" (dpb #x0f (byte 4 4) #xa7))
  =&gt;"f7"
  (format nil "~2,'0x" (dpb #x0a (byte 4 4) #x0f))
  =&gt;"af"
</description>
<seealso>ldb</seealso>
<seealso>deposit-field</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>mask-field</title>
<type>Function</type>
<arguments>mask-field BYTESPEC INTEGER</arguments>
<package>lisp</package>
<description>
指定されたフィールド以外を 0 とした値を返します。

  ;; ldb との比較
  (format nil "~2,'0x" (ldb (byte 4 4) #xaf))
  =&gt;"0a"
  (format nil "~2,'0x" (mask-field (byte 4 4) #xaf))
  =&gt;"a0"
</description>
<seealso>ldb</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>ldb-test</title>
<type>Function</type>
<arguments>ldb-test BYTESPEC INTEGER</arguments>
<package>lisp</package>
<description>
指定されたフィールドが non-zero かどうかを判定します。
(not (zerop (ldb BYTESPEC INTEGER))) と同じです。
</description>
<seealso>ldb</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>ldb</title>
<type>Function</type>
<arguments>ldb BYTESPEC INTEGER</arguments>
<package>lisp</package>
<description>
指定されたフィールドの値を取り出します。
フィールドを指定する byte specifier は関数 byte で作ります。

例：
  ;;; 最下位ビットを取り出す
  (ldb (byte 1 0) #x02)  =&gt; 0
  (ldb (byte 1 0) #x0f)  =&gt; 1
  ;;; (最下位バイトの)上位 4 ビットを取り出す
  (ldb (byte 4 4) #x0f)  =&gt; 0
  (ldb (byte 4 4) #xaf)  =&gt; 10
  (ldb (byte 4 4) #xf0)  =&gt; 15
</description>
<seealso>dpb</seealso>
<seealso>byte</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>byte-position</title>
<type>Function</type>
<arguments>byte-position BYTESPEC</arguments>
<package>lisp</package>
<description>
byte specifier の位置を返します。

内部的には cdr と同じです。
</description>
<seealso>byte</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>byte-size</title>
<type>Function</type>
<arguments>byte-size BYTESPEC</arguments>
<package>lisp</package>
<description>
byte specifier のサイズを返します。

内部的には car と同じです。
</description>
<seealso>byte</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>byte</title>
<type>Function</type>
<arguments>byte SIZE POSITION</arguments>
<package>lisp</package>
<description>
byte specifier を作ります。
「0 を基底として POSITION ビット目から始まる SIZE ビット」
を表すオブジェクトを返します。

内部的には cons と同じです。
</description>
<seealso>dpb</seealso>
<seealso>ldb</seealso>
<seealso>byte-position</seealso>
<seealso>byte-size</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>declaim</title>
<type>Macro</type>
<arguments>declaim &amp;rest DECL-SPECS</arguments>
<package>lisp</package>
<description>
変数をスペシャル変数にします。proclaim のマクロ版です。
</description>
<seealso>declare</seealso>
<seealso>proclaim</seealso>
<link></link>
<section>変数と定数</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>proclaim</title>
<type>Function</type>
<arguments>proclaim DECL-SPEC</arguments>
<package>lisp</package>
<description>
変数をスペシャル変数にします。
declare との違いは、関数であるため引数が評価されることと、効果が大域的で
ある点です。

以下の形で使用します。

  (proclaim '(special var1 var2...))

xyzzy では special 以外の指定をしても効果はありません。
</description>
<seealso>declaim</seealso>
<seealso>declare</seealso>
<link></link>
<section>変数と定数</section>
<file>typespec.l</file>
</chapter>

<chapter>
<title>forward-page</title>
<type>Function</type>
<arguments>forward-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の改ページまで移動します。[C-x []
改ページが無い場合はバッファの末尾に移動します。
一般には制御文字のform feedが単独である行で改ページを表します。

  ARG : ページ数を指定します。デフォルトは 1 です。
        負の値の場合、逆向きに移動します。
</description>
<seealso>backward-page</seealso>
<link></link>
<section>ポジション</section>
<file>page.l</file>
</chapter>

<chapter>
<title>backward-page</title>
<type>Function</type>
<arguments>backward-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
後方の改ページまで移動します。[C-x ]]
改ページが無い場合はバッファの先頭に移動します。
一般には制御文字のform feedが単独である行で改ページを表します。

  ARG : ページ数を指定します。デフォルトは 1 です。
        負の値の場合、逆向きに移動します。
</description>
<seealso>forward-page</seealso>
<link></link>
<section>ポジション</section>
<file>page.l</file>
</chapter>

<chapter>
<title>mark-page</title>
<type>Function</type>
<arguments>mark-page &amp;optional (ARG 0)</arguments>
<package>editor</package>
<description>
改ページで区切られた領域をリージョンに設定します。[C-x C-p]
改ページが無い場合、バッファ全体がリージョンになります。

  ARG : ページ位置を指定します。デフォルトは 0 です。
</description>
<seealso>forward-page</seealso>
<seealso>backward-page</seealso>
<link></link>
<section>ポジション</section>
<file>page.l</file>
</chapter>

<chapter>
<title>get-window-line</title>
<type>Function</type>
<arguments>get-window-line &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウでのカーソルの表示行を返します。
ウィンドウ内の一番上の表示行にカーソルがある場合 0 を返します。
現在のカーソル位置を正確に得るため、行数を取得する前に画面表示
を更新します。

  WINDOW : ウィンドウを指定します。
           指定しなければ (selected-window) が使われます。
</description>
<seealso>window-lines</seealso>
<seealso>refresh-screen</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-window-flags</title>
<type>Function</type>
<arguments>set-window-flags FLAGS</arguments>
<package>editor</package>
<description>
ウィンドウ全体もしくはバッファ全体の各種表示を制御します。

 FLAGS : 下記のフラグのビット和を指定します。
        *window-flag-alternate-vscroll-bar* バッファ全体表示できている
                                            場合の垂直スクロールバー
        *window-flag-cursor-line*           行カーソル
        *window-flag-eof*                   EOF
        *window-flag-fold-line*             折り返しライン
        *window-flag-fold-mark*             折り返し
        *window-flag-full-width-space*      全角スペース
        *window-flag-half-width-space*      半角スペース
        *window-flag-hscroll-bar*           水平スクロールバー
        *window-flag-just-inverse*          （詳細不明）
        *window-flag-line-number*           行番号
        *window-flag-mode-line*             モード行
        *window-flag-newline*               改行
        *window-flag-ruler*                 ルーラ
        *window-flag-scrolling*             描画位置の計算でジャンプスクロール
        *window-flag-tab*                   タブ
        *window-flag-vscroll-bar*           垂直スクロールバー
        *window-flag-zenkaku-space*         全角スペース
                                            (*window-flag-full-width-space*と同じ)
</description>
<seealso>get-window-flags</seealso>
<seealso>set-local-window-flags</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-local-window-flags</title>
<type>Function</type>
<arguments>get-local-window-flags WINDOW-OR-BUFFER</arguments>
<package>editor</package>
<description>
ローカルに設定されたウィンドウフラグの状態を多値で返します。

　 WINDOW-OR-BUFFER : バッファかウィンドウのいずれかを指定します。

戻り値
   一つ目はローカルに t に設定されたフラグ
   二つ目はローカルに nil に設定されたフラグ

使用例 :
  (progn
    (set-local-window-flags (selected-window) *window-flag-line-number* t)
    (set-local-window-flags (selected-window) *window-flag-ruler* t)
    (set-local-window-flags (selected-window) *window-flag-vscroll-bar* nil)
    (get-local-window-flags (selected-window)))
  =&gt;
  3
  32
</description>
<seealso>set-local-window-flags</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

</book>
